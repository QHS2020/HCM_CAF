# -*- coding: utf-8 -*-

"""
This module contains the HCM adjustment factr simulation. 


Tianhe:


    yhbatch -o /BIGDATA1/zju_qhs_1/LateralSDE/tmp.log /BIGDATA1/zju_qhs_1/LateralSDE/codes/run_FD.py



scp:


    scp -i /home/qhs/Qhs_Files/Program/Python/GraphicalSolutionArterialRoad/docs/tianhe2/许骏/zju_qhs_1.id -P 5566 -r /home/qhs/Qhs_Files/Program/Python/MISC/LateralSDE/codes/*.py zju_qhs_1@172.16.22.11:/BIGDATA1/zju_qhs_1/LateralSDE


"""

from RequiredModules import *
from .VehicleModel import IDM
import uuid,builtins
from scipy import integrate

#vehicle parameters, veh_paras['width']
veh_paras = {'lf':1.1, 'lr':1.3, 'lF':2.5, 'lR':2.5, 'width':2.0, 'max_steer':70*np.pi/180.0, 'min_steer':-70*np.pi/180.0, 'max_steer_rate':0.4, 'min_steer_rate':-0.4, }

#idm car following parameters
#   vf unit is m/s; 
idm_paras = {'idm_vf':120.0/3.6, 'idm_T':1.5, 'idm_delta':4.0, 'idm_s0':2.0, 'idm_a':1.0, 'idm_b':3.21, 'a_MAX':3.5, 'veh_len':5}
idm_paras_AV = {'idm_vf':120.0/3.6, 'idm_T':.5, 'idm_delta':4.0, 'idm_s0':2.0, 'idm_a':1.0, 'idm_b':3.21, 'a_MAX':3.5, 'veh_len':5}

#two_dim_paras = {'alpha_roadbounds':1.51, 'beta_lane_marks':3.6, 'beta_lane_middle_line':.56, 'sigma_long':.01, 'sigma_lat':.01, 'sigma_long_drift':1.0, 'sigma_lat_drift':1.0, 'gamma_middle_line':5}
two_dim_paras = {'alpha_roadbounds':.1, 'beta_lane_marks': 1.5, 'beta_lane_middle_line':.56, 'sigma_long':.1, 'sigma_lat':.01, 'sigma_long_drift':1.0, 'sigma_lat_drift':1.0, 'gamma_middle_line':1.0, 'theta_ou':.1, 'amplyfier_bound': 1.0, 'amplyfier_lane_mark': 10, 'amplyfier_intra_lanes':30}
#
"""
two_dim_paras_AV = {'alpha_roadbounds': .1, 'beta_lane_marks':3.6, 'beta_lane_middle_line':.56, \
    'sigma_long':.1, 'sigma_lat':.0002, 'sigma_long_drift':1.0, 'sigma_lat_drift':1.0, 'gamma_middle_line':2.0, 'theta_ou':.1, 'amplyfier_lane_mark':10}
"""
two_dim_paras_AV = {'alpha_roadbounds': .1, 'beta_lane_marks':3.6, 'beta_lane_middle_line':.56, \
    'sigma_long':.1, 'sigma_lat':.0002, 'sigma_long_drift':1.0, 'sigma_lat_drift':1.0, \
    'gamma_middle_line':2.0, 'theta_ou':.1, 'amplyfier_bound': 1.0, 'amplyfier_lane_mark': 1.0, \
    'amplyfier_intra_lanes_long': 1e-6, 'amplyfier_intra_lanes_lat':1e-7}
#
def normal(x, mean, sigma):
    """
    calculate the normal distribution value at x, given the mean and sigma. 
    """
    sigma = abs(sigma)
    return 1.0/(np.sqrt(2.0*np.pi)* sigma)*np.exp(-(x-mean)**2/(2.0*sigma*sigma))

def normal_integral(x, y,  mean, sigma):
    """
    no
    The integration over normal distribution from x to y, with parameters mean and sigma
    
    """
    if x>=y:
        raise ValueError('sfsfasdfsdfasdfasddfasdga')
    
    #-----------------------------------
    if x == -np.inf:
        return scipy.stats.norm(mean, sigma).cdf(y)
    if y==np.inf:
        return 1-scipy.stats.norm(mean, sigma).cdf(x)
    
    #
    return scipy.stats.norm.cdf(y, mean, sigma) - scipy.stats.norm.cdf(x, mean, sigma)
    
    #scipy.stats.norm.cdf(y, loc = , scale = , )-
    
    
    pass


def Transformed_erf_integrator(y, lw = 3.5, rho = 0, alpha = 3.0, y_base = 0):
    """
    
    """
    
    tmp1 = -((y_base+rho*lw-y+lw/2.0)/(lw/alpha))**2
    tmp2 = -((y_base+rho*lw-y-lw/2.0)/(lw/alpha))**2
    
    return np.exp(tmp1) - np.exp(tmp2)


class Lateral_erf_middleline_parabolic_mark():
    """
    The model for the two dimensional car following model. The lane middle line fucntion is erf and the force of lane marks are the parabolick. 
    
    """

    @classmethod
    def PotentialLaneMark_parabolic(self, ego_state, target_y, two_dim_paras = two_dim_paras, right_force_exist = True, left_force_exist = True):
        """
        Difference: 
            - self.PotentialLaneMark_parabolic()
            - self.PotentialLaneMark()
        
        -----------------------------------------
        @input: ego_state
        
            ego_state  = [y, vy, z]
        
            a  state of the ego vehicle. 
            
        
        @input: two_dim_paras
        
            the parameters for the two dimensional microscopic model. 
        
        @input: ego_lane_marks_coor
        
            ego_lane_marks_coor = (float1, float2)
        
        @input: lane_middle_line_ccor
            
            a float which represent the lane middle line coordinate. 
        
        -------------------------------------------------------
        @OUTPUT: potential
        
            a float which represent the force generated by the lane mark. 
            NOTE THAT THE sign. 
            
            
        """
        
        #
        y, vy, Z_lat = ego_state[0],ego_state[1],ego_state[2]
        #
        beta_lane_marks = two_dim_paras['beta_lane_marks']
        #lw = abs(min(ego_lane_marks_coor) - max(ego_lane_marks_coor))
        #
        
        if ego_state[0] > target_y:
            #
            return -(ego_state[0] - target_y)**2
            #
        else:
            #
            return (ego_state[0] - target_y)**2
            #
        ###############################################################################################
        ###############################################################################################
        ###############################################################################################
        #
        y, vy, Z_lat = ego_state[0],ego_state[1],ego_state[2]
        #
        beta_lane_marks = two_dim_paras['beta_lane_marks']
        lw = abs(min(ego_lane_marks_coor) - max(ego_lane_marks_coor))
        #
        potential = 0
        for markcoor in ego_lane_marks_coor:
            deltay = y - markcoor
            #y>markcoor means this mark is at right hand side. Then the force must be positive. 
            if y>markcoor:
                #print(deltay)
                if right_force_exist and deltay<lw/2.0:# and abs(deltay)<lw/2.0:
                    potential = potential + (deltay - lw/2.0)**2
                    #potential = potential + (np.exp(-beta_lane_marks*deltay*deltay) - np.exp(-beta_lane_marks*lw*lw/4.0))
                    #potential = potential + (np.exp(-beta_lane_marks*deltay*deltay))
            #
            else:
                if left_force_exist and deltay>-lw/2.0:# and abs(deltay)<lw/2.0:
                    potential = potential - (deltay - lw/2.0)**2
                    #potential = potential - (np.exp(-beta_lane_marks*deltay*deltay))
                    #potential = potential - (np.exp(-beta_lane_marks*deltay*deltay) - np.exp(-beta_lane_marks*lw*lw/4.0))
            
        return potential
    

    @classmethod
    def PotentialLaneMiddleLine(self, ego_state, ego_lane_lw, lane_middle_line_coor, two_dim_paras = two_dim_paras):
        """
        
        NOTE during the lane changing, the ego_lane_lw and lane_middle_line_coor are the tarrget lane. 
        
        If ego_lateral>lane_middle_line_coor, return a negative value. 
        
        --------------------------------
        
        @input: ego_state = np.array([.01, .01, .0])
            
            ego_state = [lateral_location, lateral_speed, noise]
        
        
        
        @input: lane_middle_line_coor
        
            a float. 
        
        """
        beta = two_dim_paras['beta_lane_middle_line']
        
        #ego_state[2] is y. 
        #if ego_state[2]>lane_middle_line_coor:
        deltay = ego_state[0]-lane_middle_line_coor
        #
        tmp0 = beta*beta*(2.0*deltay-ego_lane_lw)*np.exp(-beta*beta*(deltay-ego_lane_lw/2.0)*(deltay-ego_lane_lw/2.0))
        tmp1 = beta*beta*(2.0*deltay+ego_lane_lw)*np.exp(-beta*beta*(deltay+ego_lane_lw/2.0)*(deltay+ego_lane_lw/2.0))
        #ys2 =  beta*beta*(2.0*deltay-ego_lane_lw)*np.exp(-beta*beta*(deltay-ego_lane_lw/2.0)*(deltay-ego_lane_lw/2.0)) - \
        #        beta*beta*(2.0*deltay+lw)*np.exp(-beta*beta*(deltay+lw/2.0)*(deltay+lw/2.0))
        
        
        return (tmp0 - tmp1)*ego_state[1]

        ################################################################
        ################################################################
        
        beta = two_dim_paras['beta_lane_middle_line']
        #ego_state[2] is y. 
        #if ego_state[2]>lane_middle_line_coor:
        #deltay = ego_state[2]-lane_middle_line_coor
        deltay = y -lane_middle_line_coor
        #
        tmp0 = beta*beta*(2.0*deltay-ego_lane_lw)*np.exp(-beta*beta*(deltay-ego_lane_lw/2.0)*(deltay-ego_lane_lw/2.0))
        tmp1 = beta*beta*(2.0*deltay+ego_lane_lw)*np.exp(-beta*beta*(deltay+ego_lane_lw/2.0)*(deltay+ego_lane_lw/2.0))
        #ys2 =  beta*beta*(2.0*deltay-ego_lane_lw)*np.exp(-beta*beta*(deltay-ego_lane_lw/2.0)*(deltay-ego_lane_lw/2.0)) - \
        #        beta*beta*(2.0*deltay+lw)*np.exp(-beta*beta*(deltay+lw/2.0)*(deltay+lw/2.0))
        return (tmp0 - tmp1)*u
    
    #-----------------------------
    @classmethod
    def plot_paths(self, tspan, sim_res, ax = False, figsize = (5,3), alpha = .4, idx_ploted = 0):
        """
        
        sim_res.shape  is (len(ts), 3)
        
        res = twodim.LateralWanderingSingleLane.sim()
        sim_res,road_attrs = twodim.LateralWanderingMultiLane.sim(stochastic_proecess_name='OU', tspan = np.linspace(0, 100, 400), N_paths=10)
        
        sim_res[idx] shape is (len(ts), n_lanes*3). '*3' because for each lane there are three states: y,u,z. 
        
        road_attrs.keys():
        
            ['lanes_ids',
             'lws',
             'length',
             'lws_dict',
             'two_dim_paras_dict',
             'left_lane_id',
             'right_lane_id',
             'ellipse_y_left',
             'ellipse_y_right',
             'lanes_middle_line',
             'lanes_marks_coors',
             'road_bounds',
             'lw_boundary_lanes']
        
        """
        
        #
        if isinstance(ax, bool):
            fig,ax = plt.subplots(figsize = figsize,)
            #fig,axs = plt.subplots(figsize = figsize, nrows = 2, ncols = 1)
            #ax = host_subplot(111)
            #par = ax.twinx()
        
        #plot the y
        #ax = axs[0]
        for res in sim_res:
            #for i in range(n_lanes):
            ax.plot(tspan, res[:, idx_ploted])
        
        ax.set_xlabel('Time ( sec )');ax.set_ylabel('y (m) '); ax.grid();ax.set_title('(a)')
        
        """
        #plot the u
        ax = axs[1]
        for res in sim_res:
            for i in range(n_lanes):
                ax.plot(tspan, res[:, i*3 + 1])
        ax.set_xlabel('Time ( sec )');ax.set_ylabel('u (m/s) '); ax.grid();ax.set_title('(a)')
        """

        #
        return ax
    
    @classmethod
    def plot_lateral_marginals(self, selected_marginal_ts, tspan, sim_res, lw = 3.5, ax = False, figsize = (5,3), alpha = .4, bins = 20, filtering = True, label = False, idx_ploted = 0):
        """
        
        @input: selected_marginal_ts, tspan,
        
            both are lists or 1d array. 
            
            the former one is the 
        
            tspan = np.linspace(0, 100, 100)
            #
            two_dim_paras = {'alpha_roadbounds': .05, 'beta_lane_marks':3.6, 'beta_lane_middle_line':.56, \
                'sigma_long':.1, 'sigma_lat':.2, 'sigma_long_drift':1.0, 'sigma_lat_drift':1.0, 'gamma_middle_line':2.0, 'theta_ou':.1, \
                        'amplyfier_lane_mark':10}

            sim_res = twodim.LateralWanderingSingleLane.sim(tspan = tspan, two_dim_paras = two_dim_paras)
        
            sim_res[idx] shape is (len(ts), *3). '*3' because for each lane there are three states: y,u,z. 
        

 
        
        """
        
        #
        if isinstance(ax, bool):
            fig,ax = plt.subplots(figsize = figsize,)
            #fig,axs = plt.subplots(figsize = figsize, nrows = 2, ncols = 1)
            #ax = host_subplot(111)
            #par = ax.twinx()
        tspan = np.array(tspan)
        #ax = axs[0]
        
        for t in selected_marginal_ts:
            #----------------------------------
            indexes = np.array(range(len(tspan)))
            #
            tmp = abs(tspan-t)
            idx_most_near = indexes[tmp==min(tmp)][0]
            data = [res[idx_most_near, idx_ploted] for res in sim_res]
            #data = [res[idx_most_near, 0] for res in sim_res if max(res[:,0])<lw/2.0]
            hist0,edges = np.histogram(data, bins = bins)
            #print(sum(hist0), edges[-1] - edges[-2])
            hist = hist0/sum(hist0)/(edges[-1] - edges[-2])
            #
            if isinstance(label, bool):
                ax.plot(edges[1:], hist)
            else:
                ax.plot(edges[1:], hist, label = label)
        
        #ax.set_xlim(road_attrs['lanes_marks_coors'][lane_id])
        ax.set_xlabel('Lateral location (m)');ax.set_ylabel('Frequency'); ax.grid();#ax.set_title('(a)')
        
        """
        #plot the u
        ax = axs[1]
        for res in sim_res:
            for i in range(n_lanes):
                ax.plot(tspan, res[:, i*3 + 1])
        ax.set_xlabel('Time ( sec )');ax.set_ylabel('u (m/s) '); ax.grid();ax.set_title('(a)')
        """

        #
        return ax


    @classmethod
    def SingleLaneSim(self, S0 = np.array([.0, .0, .0]), target_y = .0, \
            ego_lane_marks_coor = (.0, 3.5), \
            tspan = np.linspace(0, 100, 200), \
            stochastic_proecess_name = 'OU', \
            two_dim_paras = two_dim_paras, \
            N_paths = 200, \
            ego_lane_lw = 3.5, \
            alpha_roadbounds = 1.51, \
            left_force_exist = True, \
            right_force_exist = True):
        """
        Generate the simulation path for the erf based noise and tanh type noise and erf based regression.
        
        Difference:
        
            - MonteCarloSimulationPaths_tanh_noise_erf_Y_assymetric(), the doerf function is assymetric. which is represented by alpha_l and alpha_r, while there is only a alpha in the following formula. 
            - MonteCarloSimulationPaths_tanh_noise_erf_Y()
        -----------------------------------------------------------
        @iput: target_y
        
            the target lateral location. 
        
        @input: S0 = np.array([.01, .01, .0])
            
            S0 = [initial_lateral_location, initial_lateral_speed, noise]
        
        
        @output: paths
            
            a pd. 
            
        @output: Ys,Zs
        
            
            Both are pd.dataframe. The index are moments, and each column is a system path. 
            
        """
        import sdeint
        results = []
        #
        #S = [y, vy, z],
        def f_S(S, t, ego_lane_lw = ego_lane_lw, stochastic_proecess_name = stochastic_proecess_name, two_dim_paras = two_dim_paras, ):
            #
            #gamma_middle_line  = two_dim_paras['gamma_middle_line']
            sigma_lat_drift = two_dim_paras['sigma_lat_drift']
            sigma_lat = two_dim_paras['sigma_lat']
            beta = two_dim_paras['beta_lane_middle_line']
            #alpha_roadbounds = two_dim_paras['alpha_roadbounds']
            
            #=====================================================dy
            #S = [y, vy, z], z is the nois. 
            y,vy,Z_lat = S
            #
            diff_y = vy
            #
            #=====================================================dvy
            force_middle_line = self.PotentialLaneMiddleLine(ego_state = S, \
                ego_lane_lw = ego_lane_lw, \
                lane_middle_line_coor = target_y, \
                two_dim_paras = two_dim_paras)
            
            force_marks = self.PotentialLaneMark_parabolic(ego_state = S, \
                target_y = target_y, \
                two_dim_paras = two_dim_paras, \
                right_force_exist = right_force_exist, \
                left_force_exist = left_force_exist)
            #
            #------------------------------------
            diff_vy = force_middle_line + two_dim_paras['amplyfier_lane_mark']*force_marks + Z_lat
            #
            #====================================================diff_Z_lat
            if stochastic_proecess_name=='OU':
                #
                diff_Z_lat = -sigma_lat_drift*Z_lat
            elif stochastic_proecess_name=='simple':
                #
                diff_Z_lat = .0
            elif stochastic_proecess_name=='converted':
                #
                diff_Z_lat = -(sigma_lat**2)*(1-Z_lat**2)*Z_lat
                #
            elif stochastic_proecess_name=='geometric':
                #
                diff_Z_lat = -sigma_lat_drift*(Z_lat)
                #
            elif stochastic_proecess_name=='jacobi':
                #
                diff_Z_lat = -sigma_lat_drift*(Z_lat - .0)
                #
            elif stochastic_proecess_name=='hyperparabolic':
                #
                diff_Z_lat = -Z_lat-sigma_lat_drift*Z_lat
                #print(diff_Z_long, diff_Z_lat)
            elif stochastic_proecess_name=='ROU':

                diff_Z_lat = -sigma_lat_drift/Z_lat +  Z_lat #-sigma_lat_drift*(Z_lat - .0)
            
            #===============================================
            return np.array([diff_y, diff_vy, diff_Z_lat])
            
        def g_S(S, t, ego_lane_lw = 3.5, stochastic_proecess_name = stochastic_proecess_name, two_dim_paras = two_dim_paras):
            #S = [y, vy, z], z is the nois. 
            y,vy,Z_lat = S

            sigma_lat = two_dim_paras['sigma_lat']
            
            #------------------------------------------
            if stochastic_proecess_name=='OU':
                tmp_lat = sigma_lat
                #
            elif stochastic_proecess_name=='simple':
                tmp_lat = sigma_lat*vy
                
            elif stochastic_proecess_name=='converted':
                tmp_lat = sigma_lat*(1-Z_lat**2)
                #
            elif stochastic_proecess_name=='geometric':
                tmp_lat = sigma_lat*(Z_lat)
                #
            elif stochastic_proecess_name=='hyperparabolic':

                tmp_lat = sigma_lat
                
            elif stochastic_proecess_name=='jacobi':
                #print(Z_lat, (.5-Z_lat), (Z_lat+.5))
                Z_lat = max(-.499999, min(Z_lat, .4999999))
                tmp_lat = np.sqrt(sigma_lat*(Z_lat+.5)*(.5-Z_lat))
            elif stochastic_proecess_name=='ROU':

                tmp_lat = sigma_lat
            
            #
            #tmp_long =  sigma_long*(1.0-Z_long**2)
            #tmp_lat = sigma_lat*(1-Z_lat**2)
            array = np.array([[0.0, .0, tmp_lat]])
            #array = np.array([[.0, .0, .0, .0, tmp_long, .0], \
            #                  [.0, .0, .0, .0, 0, tmp_lat]])
            
            
            return array.T
            
        #---------------------------------------------
        for iterr in range(N_paths):
            #result.shape is (len(tspan),2), '2' corresponds to Z.
            #   the first column is lateral displacement, and the 2nd columns is the noize. 
            result = sdeint.itoint(f_S, g_S, S0, tspan)
            results.append(result)
            #res_Y.append(result[:,0])
            #res_Z.append(result[:,1])
        #-----------------------------------------
        #np.array(res_Y) shape is N_paths,len(tspan)
        #np.array(res_Z) shape is N_paths,len(tspan)
        return results
        #return pd.DataFrame(res_Y, columns =  tspan).T,pd.DataFrame(res_Z, columns =  tspan).T

    
    
    pass

class erf_lateral_sim():
    """
    Simulate the lateral dynamics specified by the erf function. 
    
    """
    
    
    @classmethod
    def plot_state_idxs(self, list_of_states, idxs_plotted = [0, 1]):
        """
        
        """
        
        
        
        pass
    

    @classmethod
    def SimTest_OV(self, S0 = np.array([.0, .0, .0]), tspan = np.linspace(0, 100, 200), stochastic_proecess_name = 'converted', two_dim_paras = two_dim_paras, N_paths = 1000):
        """
        Generate the simulation path for the erf based noise and tanh type noise and erf based regression.
        
        Difference:
        
            - MonteCarloSimulationPaths_tanh_noise_erf_Y_assymetric(), the doerf function is assymetric. which is represented by alpha_l and alpha_r, while there is only a alpha in the following formula. 
            - MonteCarloSimulationPaths_tanh_noise_erf_Y()
        -----------------------------------------------------------
        @input: Z0 = np.array([.01, .01])
            
            Z0 = [lateral_inital, noise]
        
        
        @output: paths
            
            a pd. 
            
        @output: Ys,Zs
        
            
            Both are pd.dataframe. The index are moments, and each column is a system path. 
            
        """
        import sdeint
        results = []
        #
        res_Y = []
        res_Z = []

        #S = [y, vy, z],
        def f_S(S, t, ego_lane_lw = 3.5, stochastic_proecess_name = 'converted', two_dim_paras = two_dim_paras):
            #
            gamma_middle_line  = two_dim_paras['gamma_middle_line']
            sigma_lat_drift = two_dim_paras['sigma_lat_drift']
            sigma_lat = two_dim_paras['sigma_lat']
            beta = two_dim_paras['beta_lane_middle_line']
            
            #S = [y, vy, z], z is the nois. 
            y,vy,Z_lat = S
            #
            tmp0 = vy
            
            tmp1 = np.tanh(y-2) + np.tanh(-2) - vy + Z_lat
            #
            #tmp1a = beta*beta*(2.0*y-ego_lane_lw)*np.exp(-beta*beta*(y-ego_lane_lw/2.0)*(y-ego_lane_lw/2.0))
            #tmp1b = beta*beta*(2.0*y+ego_lane_lw)*np.exp(-beta*beta*(y+ego_lane_lw/2.0)*(y+ego_lane_lw/2.0))
            #vy_function = np.exp(-beta*beta*(y+ego_lane_lw/2.0)*(y+ego_lane_lw/2.0))-np.exp(-beta*beta*(y-ego_lane_lw/2.0)*(y-ego_lane_lw/2.0))
            #
            #tmp_equi_a = beta*beta*(2.0*.0-ego_lane_lw)*np.exp(-beta*beta*(.0-ego_lane_lw/2.0)*(.0-ego_lane_lw/2.0))
            #tmp_equi_b = beta*beta*(2.0*.0+ego_lane_lw)*np.exp(-beta*beta*(.0+ego_lane_lw/2.0)*(.0+ego_lane_lw/2.0))
            #tmp1 = (tmp1a - tmp1b - (tmp_equi_a - tmp_equi_b))*gamma_middle_line  + Z_lat
            #tmp1 = vy_function*(tmp1a - tmp1b)*gamma_middle_line  + Z_lat
            
            #==============================diff_Z_long, diff_Z_lat
            if stochastic_proecess_name=='OU':

                diff_Z_lat = -sigma_lat_drift*Z_lat
            elif stochastic_proecess_name=='simple':

                diff_Z_lat = 0
            elif stochastic_proecess_name=='converted':

                diff_Z_lat = -(sigma_lat**2)*(1-Z_lat**2)*Z_lat
                
            elif stochastic_proecess_name=='geometric':

                diff_Z_lat = -sigma_lat_drift*(Z_lat)
                #
            elif stochastic_proecess_name=='jacobi':

                diff_Z_lat = -sigma_lat_drift*(Z_lat - .0)
                #
            elif stochastic_proecess_name=='hyperparabolic':
                #

                diff_Z_lat = -Z_lat-sigma_lat_drift*Z_lat
                #print(diff_Z_long, diff_Z_lat)
            elif stochastic_proecess_name=='ROU':

                diff_Z_lat = -sigma_lat_drift/Z_lat +  Z_lat #-sigma_lat_drift*(Z_lat - .0)
            
            return np.array([tmp0, tmp1, diff_Z_lat])
            
        def g_S(S, t, ego_lane_lw = 3.5, stochastic_proecess_name = 'converted', two_dim_paras = two_dim_paras):
            #S = [y, vy, z], z is the nois. 
            y,vy,Z_lat = S

            sigma_lat = two_dim_paras['sigma_lat']
            
            #------------------------------------------
            if stochastic_proecess_name=='OU':
                tmp_lat = sigma_lat
                #
            elif stochastic_proecess_name=='simple':
                tmp_lat = sigma_lat
                
            elif stochastic_proecess_name=='converted':
                tmp_lat = sigma_lat*(1-Z_lat**2)
                #
            elif stochastic_proecess_name=='geometric':
                tmp_lat = sigma_lat*(Z_lat)
                #
            elif stochastic_proecess_name=='hyperparabolic':

                tmp_lat = sigma_lat
                
            elif stochastic_proecess_name=='jacobi':
                #print(Z_lat, (.5-Z_lat), (Z_lat+.5))
                Z_lat = max(-.499999, min(Z_lat, .4999999))
                tmp_lat = np.sqrt(sigma_lat*(Z_lat+.5)*(.5-Z_lat))
            elif stochastic_proecess_name=='ROU':

                tmp_lat = sigma_lat
            
            #
            #tmp_long =  sigma_long*(1.0-Z_long**2)
            #tmp_lat = sigma_lat*(1-Z_lat**2)
            array = np.array([[0.0, .0, tmp_lat]])
            #array = np.array([[.0, .0, .0, .0, tmp_long, .0], \
            #                  [.0, .0, .0, .0, 0, tmp_lat]])
            
            
            return array.T
            
        #---------------------------------------------
        for iterr in range(N_paths):
            #result.shape is (len(tspan),2), '2' corresponds to Z.
            #   the first column is lateral displacement, and the 2nd columns is the noize. 
            result = sdeint.itoint(f_S, g_S, S0, tspan)
            results.append(result)
            #res_Y.append(result[:,0])
            #res_Z.append(result[:,1])
        #-----------------------------------------
        #np.array(res_Y) shape is N_paths,len(tspan)
        #np.array(res_Z) shape is N_paths,len(tspan)
        return results
        #return pd.DataFrame(res_Y, columns =  tspan).T,pd.DataFrame(res_Z, columns =  tspan).T




    @classmethod
    def SimTest_WithoutAcceleration(self, S0 = np.array([.0, .0]), tspan = np.linspace(0, 100, 200), stochastic_proecess_name = 'converted', two_dim_paras = two_dim_paras, N_paths = 1000):
        """
        Generate the simulation path for the erf based noise and tanh type noise and erf based regression.
        
        Difference:
        
            - MonteCarloSimulationPaths_tanh_noise_erf_Y_assymetric(), the doerf function is assymetric. which is represented by alpha_l and alpha_r, while there is only a alpha in the following formula. 
            - MonteCarloSimulationPaths_tanh_noise_erf_Y()
        -----------------------------------------------------------
        @input: Z0 = np.array([.01, .01])
            
            Z0 = [lateral_inital, noise]
        
        
        @output: paths
            
            a pd. 
            
        @output: Ys,Zs
        
            
            Both are pd.dataframe. The index are moments, and each column is a system path. 
            
        """
        import sdeint
        results = []
        #
        res_Y = []
        res_Z = []

        #S = [y, vy, z],
        def f_S(S, t, ego_lane_lw = 3.5, stochastic_proecess_name = 'converted', two_dim_paras = two_dim_paras):
            #
            gamma_middle_line  = two_dim_paras['gamma_middle_line']
            sigma_lat_drift = two_dim_paras['sigma_lat_drift']
            sigma_lat = two_dim_paras['sigma_lat']
            beta = two_dim_paras['beta_lane_middle_line']
            
            #S = [y,  z], z is the nois. 
            y,Z_lat = S
            #
            tmp0 = gamma_middle_line*(np.exp(-beta*beta*(y+ego_lane_lw/2.0)*(y+ego_lane_lw/2.0))-np.exp(-beta*beta*(y-ego_lane_lw/2.0)*(y-ego_lane_lw/2.0)))# + Z_lat
            #
            
            #==============================diff_Z_long, diff_Z_lat
            if stochastic_proecess_name=='OU':

                diff_Z_lat = -sigma_lat_drift*Z_lat
            elif stochastic_proecess_name=='simple':

                diff_Z_lat = 0
            elif stochastic_proecess_name=='converted':

                diff_Z_lat = -(sigma_lat**2)*(1-Z_lat**2)*Z_lat
                
            elif stochastic_proecess_name=='geometric':

                diff_Z_lat = -sigma_lat_drift*(Z_lat)
                #
            elif stochastic_proecess_name=='jacobi':

                diff_Z_lat = -sigma_lat_drift*(Z_lat - .0)
                #
            elif stochastic_proecess_name=='hyperparabolic':
                #

                diff_Z_lat = -Z_lat-sigma_lat_drift*Z_lat
                #print(diff_Z_long, diff_Z_lat)
            elif stochastic_proecess_name=='ROU':

                diff_Z_lat = -sigma_lat_drift/Z_lat +  Z_lat #-sigma_lat_drift*(Z_lat - .0)
            
            return np.array([tmp0,  diff_Z_lat])
            
        def g_S(S, t, ego_lane_lw = 3.5, stochastic_proecess_name = 'converted', two_dim_paras = two_dim_paras):
            #S = [y, vy, z], z is the nois. 
            y,Z_lat = S

            sigma_lat = two_dim_paras['sigma_lat']
            
            #------------------------------------------
            if stochastic_proecess_name=='OU':
                tmp_lat = sigma_lat
                #
            elif stochastic_proecess_name=='simple':
                tmp_lat = sigma_lat
                
            elif stochastic_proecess_name=='converted':
                tmp_lat = sigma_lat*(1-Z_lat**2)
                #
            elif stochastic_proecess_name=='geometric':
                tmp_lat = sigma_lat*(Z_lat)
                #
            elif stochastic_proecess_name=='hyperparabolic':

                tmp_lat = sigma_lat
                
            elif stochastic_proecess_name=='jacobi':
                #print(Z_lat, (.5-Z_lat), (Z_lat+.5))
                Z_lat = max(-.499999, min(Z_lat, .4999999))
                tmp_lat = np.sqrt(sigma_lat*(Z_lat+.5)*(.5-Z_lat))
            elif stochastic_proecess_name=='ROU':

                tmp_lat = sigma_lat
            
            #
            #tmp_long =  sigma_long*(1.0-Z_long**2)
            #tmp_lat = sigma_lat*(1-Z_lat**2)
            array = np.array([[0.0, tmp_lat]])
            #array = np.array([[.0, .0, .0, .0, tmp_long, .0], \
            #                  [.0, .0, .0, .0, 0, tmp_lat]])
            
            
            return array.T
            
        #---------------------------------------------
        for iterr in range(N_paths):
            #result.shape is (len(tspan),2), '2' corresponds to Z.
            #   the first column is lateral displacement, and the 2nd columns is the noize. 
            result = sdeint.itoint(f_S, g_S, S0, tspan)
            results.append(result)
            #res_Y.append(result[:,0])
            #res_Z.append(result[:,1])
        #-----------------------------------------
        #np.array(res_Y) shape is N_paths,len(tspan)
        #np.array(res_Z) shape is N_paths,len(tspan)
        return results
        #return pd.DataFrame(res_Y, columns =  tspan).T,pd.DataFrame(res_Z, columns =  tspan).T

    def __init__(self, lanes_ids = [0, 1, 2, 3], lws = [3.5, 3.5, 3.5, 3.5], length = 1000):
        """
        
        ---------------------------------------------------------------
        @input: lws
        
            a lists containing the lane withs of each lane. 
            
            
            
        """
        #========================================self.lanes_ids, self.lws, self.length
        #   lane id
        self.lanes_ids = lanes_ids
        self.lws = lws
        self.length = length
        
        #========================================self.lws_dict
        self.lws_dict = {laneid:lw for laneid,lw in zip(lanes_ids, lws)}
        #========================================self.left_lane_id and self.right_lane_id
        #   calculate the left-lane and right_lane. 
        self.left_lane_id = {}
        self.right_lane_id = {}
        for idx in range(len(lanes_ids)-1):
            laneid = self.lanes_ids[idx]
            self.right_lane_id[laneid] = self.lanes_ids[idx + 1] 
        #
        for idx in range(1, len(lanes_ids)):
            laneid = self.lanes_ids[idx]
            self.left_lane_id[laneid] = self.lanes_ids[idx - 1] 
        #========================================self.ellipse_y_left and self.ellipse_y_right
        #calcualte the ellipse_y
        self.ellipse_y_left = {}
        self.ellipse_y_right = {}
        for idx in range( len(lanes_ids)):
            laneid = self.lanes_ids[idx]
            #self.ellipse_y_left
            if idx==0:
                self.ellipse_y_left[laneid] = 0
                #
                self.ellipse_y_right[laneid] = self.lws_dict[laneid]/2.0 + self.lws_dict[self.right_lane_id[laneid]]/2.0
                continue
            #self.ellipse_y_left
            if idx==len(lanes_ids)-1:
                self.ellipse_y_right[laneid] = 0
                self.ellipse_y_left[laneid] = self.lws_dict[laneid]/2.0 + self.lws_dict[self.left_lane_id[laneid]]/2.0
                continue
            #-----------
            self.ellipse_y_left[laneid] = self.lws_dict[laneid]/2.0 + self.lws_dict[self.left_lane_id[laneid]]/2.0
            self.ellipse_y_right[laneid] = self.lws_dict[laneid]/2.0 + self.lws_dict[self.right_lane_id[laneid]]/2.0
        
        #========================================self.length
        self.length = length
        #
        #========================================self.lanes_middle_line
        #calculate the lanes middle line coordinate. 
        #self.lanes_middle_line[land_id] = the lateral coordinate of the lane middle line. 
        #   NOTE that the origin locates at the rightmost lane boundary. 
        self.lanes_middle_line = {}
        for idx in range(len(lanes_ids)):
            #
            laneid = self.lanes_ids[idx]
            #
            self.lanes_middle_line[laneid]  = self.lws_dict[laneid]/2.0 + sum(lws[idx+1:])
            #
        #========================================self.lanes_marks_coors
        #self.lanes_marks_coors[laneid] = (left_mark_coor, right_mark_coor), both are floats. 
        self.lanes_marks_coors = {}
        for idx in range(len(lanes_ids)):
            #
            laneid = self.lanes_ids[idx]
            #
            self.lanes_marks_coors[laneid]  = (self.lanes_middle_line[laneid] - self.lws_dict[laneid]/2.0, self.lanes_middle_line[laneid] + self.lws_dict[laneid]/2.0)
        #======================================self.road_bounds
        self.road_bounds = (0, sum(lws))
        #lw_boundary_lanes
        self.lw_boundary_lanes = (self.lws[0], self.lws[-1])
        
        #========================================Dynmaic properties. 
        #   ----------------self.vehs_at_lanes, self.vehs_dict,self.vehs_target_lane
        #self.vehs_at_lanes[lane_id] = [vid1, vid2,....]. NOTE THAT THEY ARE SPORTED FROM 1st vehicle to last vehicle. 
        self.vehs_at_lanes  =  {lane_ids:[] for lane_ids in lanes_ids}
        #self.vehs_dict[vehicle_id] = [x, vx, y, vy, zlon, zlat]
        self.vehs_dict = {}
        #self.vehs_target_lane = {vid:lane_id}, the target lane id of each vehicle. 
        #   then the target lateral location is determined via: self.lanes_middle_line[self.vehs_target_lane[vid]]
        self.vehs_target_lane = {}
        #   self.snapshots[moment] is a dict. 
        #   self.snapshots[moment][vid] is a dict. 
        #   self.snapshots[moment][vid] keys include 'leader','neighbores','potentials.'
        self.snapshots = {}
        #-------------------------------

    @classmethod
    def SingleLaneSim(self, S0 = np.array([.0, .0, .0]), tspan = np.linspace(0, 100, 200), stochastic_proecess_name = 'converted', two_dim_paras = two_dim_paras, N_paths = 1000, lw = 3.5, alpha_roadbounds = 1.51):
        """
        Generate the simulation path for the erf based noise and tanh type noise and erf based regression.
        
        Difference:
        
            - MonteCarloSimulationPaths_tanh_noise_erf_Y_assymetric(), the doerf function is assymetric. which is represented by alpha_l and alpha_r, while there is only a alpha in the following formula. 
            - MonteCarloSimulationPaths_tanh_noise_erf_Y()
        -----------------------------------------------------------
        @input: Z0 = np.array([.01, .01])
            
            Z0 = [lateral_inital, noise]
        
        
        @output: paths
            
            a pd. 
            
        @output: Ys,Zs
        
            
            Both are pd.dataframe. The index are moments, and each column is a system path. 
            
        """
        import sdeint
        results = []
        #
        #S = [y, vy, z],
        def f_S(S, t, ego_lane_lw = 3.5, stochastic_proecess_name = stochastic_proecess_name, two_dim_paras = two_dim_paras):
            #
            gamma_middle_line  = two_dim_paras['gamma_middle_line']
            sigma_lat_drift = two_dim_paras['sigma_lat_drift']
            sigma_lat = two_dim_paras['sigma_lat']
            beta = two_dim_paras['beta_lane_middle_line']
            alpha_roadbounds = two_dim_paras['alpha_roadbounds']
            
            #S = [y, vy, z], z is the nois. 
            y,vy,Z_lat = S
            #
            tmp0 = vy
            #
            tmp1a = beta*beta*(2.0*y-ego_lane_lw)*np.exp(-beta*beta*(y-ego_lane_lw/2.0)*(y-ego_lane_lw/2.0))
            tmp1b = beta*beta*(2.0*y+ego_lane_lw)*np.exp(-beta*beta*(y+ego_lane_lw/2.0)*(y+ego_lane_lw/2.0))
            vy_function = np.exp(-beta*beta*(y+ego_lane_lw/2.0)*(y+ego_lane_lw/2.0))-np.exp(-beta*beta*(y-ego_lane_lw/2.0)*(y-ego_lane_lw/2.0))
            #tmp0 = vy_function#  + Z_lat
            #
            #
            #tmp_equi_a = beta*beta*(2.0*.0-ego_lane_lw)*np.exp(-beta*beta*(.0-ego_lane_lw/2.0)*(.0-ego_lane_lw/2.0))
            #tmp_equi_b = beta*beta*(2.0*.0+ego_lane_lw)*np.exp(-beta*beta*(.0+ego_lane_lw/2.0)*(.0+ego_lane_lw/2.0))
            #tmp1 = (tmp1a - tmp1b - (tmp_equi_a - tmp_equi_b))*gamma_middle_line  + Z_lat
            #calculate the lane boundary force. 

            #potential0 must be negative. 
            #deltay = y-road_bounds[0]
            deltay = y - lw/2.0
            y0 = max(1e-10, min(abs(deltay), ego_lane_lw/2.0))
            #print(y, road_bounds[0])
            if deltay>0:
                potential0 = 1.0/(np.power(y0*2.0/ego_lane_lw, alpha_roadbounds)) - 1
            else:
                potential0 = -(1.0/(np.power(y0*2.0/ego_lane_lw, alpha_roadbounds)) - 1)
            
            #
            deltay = y + lw/2.0
            y1 = max(1e-10, min(abs(deltay), ego_lane_lw/2.0))
            #print(deltay1*2.0/lw_boundary_lanes[1], alpha_roadbounds)
            if deltay>0:
                potential1 = 1.0/(np.power(y1*2.0/ego_lane_lw, alpha_roadbounds)) - 1
            else:
                #print(deltay1)
                potential1 = -(1.0/(np.power(y1*2.0/ego_lane_lw, alpha_roadbounds)) -1)
            
            #
            boundarypotential =  potential0 + potential1

            #
            tmp1 = vy*(tmp1a - tmp1b)*gamma_middle_line + Z_lat +boundarypotential
            
            #==============================diff_Z_long, diff_Z_lat
            if stochastic_proecess_name=='OU':

                diff_Z_lat = -sigma_lat_drift*Z_lat
            elif stochastic_proecess_name=='simple':

                diff_Z_lat = .0
            elif stochastic_proecess_name=='converted':

                diff_Z_lat = -(sigma_lat**2)*(1-Z_lat**2)*Z_lat
                
            elif stochastic_proecess_name=='geometric':

                diff_Z_lat = -sigma_lat_drift*(Z_lat)
                #
            elif stochastic_proecess_name=='jacobi':

                diff_Z_lat = -sigma_lat_drift*(Z_lat - .0)
                #
            elif stochastic_proecess_name=='hyperparabolic':
                #

                diff_Z_lat = -Z_lat-sigma_lat_drift*Z_lat
                #print(diff_Z_long, diff_Z_lat)
            elif stochastic_proecess_name=='ROU':

                diff_Z_lat = -sigma_lat_drift/Z_lat +  Z_lat #-sigma_lat_drift*(Z_lat - .0)
            
            return np.array([tmp0, tmp1, diff_Z_lat])
            
        def g_S(S, t, ego_lane_lw = 3.5, stochastic_proecess_name = stochastic_proecess_name, two_dim_paras = two_dim_paras):
            #S = [y, vy, z], z is the nois. 
            y,vy,Z_lat = S

            sigma_lat = two_dim_paras['sigma_lat']
            
            #------------------------------------------
            if stochastic_proecess_name=='OU':
                tmp_lat = sigma_lat
                #
            elif stochastic_proecess_name=='simple':
                tmp_lat = sigma_lat*vy
                
            elif stochastic_proecess_name=='converted':
                tmp_lat = sigma_lat*(1-Z_lat**2)
                #
            elif stochastic_proecess_name=='geometric':
                tmp_lat = sigma_lat*(Z_lat)
                #
            elif stochastic_proecess_name=='hyperparabolic':

                tmp_lat = sigma_lat
                
            elif stochastic_proecess_name=='jacobi':
                #print(Z_lat, (.5-Z_lat), (Z_lat+.5))
                Z_lat = max(-.499999, min(Z_lat, .4999999))
                tmp_lat = np.sqrt(sigma_lat*(Z_lat+.5)*(.5-Z_lat))
            elif stochastic_proecess_name=='ROU':

                tmp_lat = sigma_lat
            
            #
            #tmp_long =  sigma_long*(1.0-Z_long**2)
            #tmp_lat = sigma_lat*(1-Z_lat**2)
            array = np.array([[0.0, .0, tmp_lat]])
            #array = np.array([[.0, .0, .0, .0, tmp_long, .0], \
            #                  [.0, .0, .0, .0, 0, tmp_lat]])
            
            
            return array.T
            
        #---------------------------------------------
        for iterr in range(N_paths):
            #result.shape is (len(tspan),2), '2' corresponds to Z.
            #   the first column is lateral displacement, and the 2nd columns is the noize. 
            result = sdeint.itoint(f_S, g_S, S0, tspan)
            results.append(result)
            #res_Y.append(result[:,0])
            #res_Z.append(result[:,1])
        #-----------------------------------------
        #np.array(res_Y) shape is N_paths,len(tspan)
        #np.array(res_Z) shape is N_paths,len(tspan)
        return results
        #return pd.DataFrame(res_Y, columns =  tspan).T,pd.DataFrame(res_Z, columns =  tspan).T



    @classmethod
    def SimTest_noise_not_integrate(self, S0 = np.array([.0, .0]), tspan = np.linspace(0, 100, 200), stochastic_proecess_name = 'converted', two_dim_paras = two_dim_paras, N_paths = 1000):
        """
        Generate the simulation path for the erf based noise and tanh type noise and erf based regression.
        
        Difference:
        
            - MonteCarloSimulationPaths_tanh_noise_erf_Y_assymetric(), the doerf function is assymetric. which is represented by alpha_l and alpha_r, while there is only a alpha in the following formula. 
            - MonteCarloSimulationPaths_tanh_noise_erf_Y()
        -----------------------------------------------------------
        @input: Z0 = np.array([.01, .01])
            
            Z0 = [lateral_inital, noise]
        
        
        @output: paths
            
            a pd. 
            
        @output: Ys,Zs
        
            
            Both are pd.dataframe. The index are moments, and each column is a system path. 
            
        """
        import sdeint
        results = []
        #
        #S = [y, vy, z],
        def f_S(S, t, ego_lane_lw = 3.5, stochastic_proecess_name = stochastic_proecess_name, two_dim_paras = two_dim_paras):
            #
            gamma_middle_line  = two_dim_paras['gamma_middle_line']
            sigma_lat_drift = two_dim_paras['sigma_lat_drift']
            sigma_lat = two_dim_paras['sigma_lat']
            beta = two_dim_paras['beta_lane_middle_line']
            
            #S = [y, vy, z], z is the nois. 
            y,vy = S
            #
            tmp0 = vy
            #
            tmp1a = beta*beta*(2.0*y-ego_lane_lw)*np.exp(-beta*beta*(y-ego_lane_lw/2.0)*(y-ego_lane_lw/2.0))
            tmp1b = beta*beta*(2.0*y+ego_lane_lw)*np.exp(-beta*beta*(y+ego_lane_lw/2.0)*(y+ego_lane_lw/2.0))
            vy_function = np.exp(-beta*beta*(y+ego_lane_lw/2.0)*(y+ego_lane_lw/2.0))-np.exp(-beta*beta*(y-ego_lane_lw/2.0)*(y-ego_lane_lw/2.0))
            #tmp0 = vy_function#  + Z_lat
            #
            #
            #tmp_equi_a = beta*beta*(2.0*.0-ego_lane_lw)*np.exp(-beta*beta*(.0-ego_lane_lw/2.0)*(.0-ego_lane_lw/2.0))
            #tmp_equi_b = beta*beta*(2.0*.0+ego_lane_lw)*np.exp(-beta*beta*(.0+ego_lane_lw/2.0)*(.0+ego_lane_lw/2.0))
            #tmp1 = (tmp1a - tmp1b - (tmp_equi_a - tmp_equi_b))*gamma_middle_line  + Z_lat
            tmp1 = vy*(tmp1a - tmp1b)*gamma_middle_line

            
            return np.array([tmp0, tmp1])
            
        def g_S(S, t, ego_lane_lw = 3.5, stochastic_proecess_name = stochastic_proecess_name, two_dim_paras = two_dim_paras):
            #S = [y, vy, z], z is the nois. 
            y,vy = S

            sigma_lat = two_dim_paras['sigma_lat']

            
            tmp_lat = (-vy)*sigma_lat#min(1, vy)
            
            #
            #tmp_long =  sigma_long*(1.0-Z_long**2)
            #tmp_lat = sigma_lat*(1-Z_lat**2)
            array = np.array([[0.0, tmp_lat]])
            #array = np.array([[.0, .0, .0, .0, tmp_long, .0], \
            #                  [.0, .0, .0, .0, 0, tmp_lat]])
            
            
            return array.T
            
        #---------------------------------------------
        for iterr in range(N_paths):
            #result.shape is (len(tspan),2), '2' corresponds to Z.
            #   the first column is lateral displacement, and the 2nd columns is the noize. 
            result = sdeint.itoint(f_S, g_S, S0, tspan)
            results.append(result)
            #res_Y.append(result[:,0])
            #res_Z.append(result[:,1])
        #-----------------------------------------
        #np.array(res_Y) shape is N_paths,len(tspan)
        #np.array(res_Z) shape is N_paths,len(tspan)
        return results
        #return pd.DataFrame(res_Y, columns =  tspan).T,pd.DataFrame(res_Z, columns =  tspan).T
    
    
    @classmethod
    def marginaldistribution_lastmoment(self, paths_list, bins = 50, lw = 3.5):
        """
        edges,hs = twodim.erf_lateral_sim.marginaldistribution_lastmoment(paths_list)
        
        calculate the marginal distribution from the simulated paths. only for the last moment
        
        @input: ts
        
            a list or array containing the moments of the simulation moments in paths_list. 
        
        @input: paths_list
        
            a list containing the simulated path. 
            
            path = paths_list[idx]
            path is an 2d array, and shape is (len(ts), 3). '3' means [y,u,z]. They are lateral location,lateral speed and 
        
        @OUTPUT: marginals
        
            marginals = (edges, hs)
            
            ys and hs are both list, len(ys) = bins - 1.
            
            hs*deltay
            
        """
        #
        ys =[path[-1, 0] for path in paths_list]
        
        #
        hists, edges0 = np.histogram(ys, bins = bins, range = (-lw/2.0, lw/2.0))
        #
        edges = edges0[1:]
        #print(sum(hists))
        #
        hs = hists/sum(hists)/(edges0[-1] - edges0[-2])
        
        return hs,edges
        
        
        pass

    @classmethod
    def SimTest_BKP(self, S0 = np.array([.0, .0, .0]), tspan = np.linspace(0, 100, 200), stochastic_proecess_name = 'converted', two_dim_paras = two_dim_paras, N_paths = 1000):
        """
        Generate the simulation path for the erf based noise and tanh type noise and erf based regression.
        
        Difference:
        
            - MonteCarloSimulationPaths_tanh_noise_erf_Y_assymetric(), the doerf function is assymetric. which is represented by alpha_l and alpha_r, while there is only a alpha in the following formula. 
            - MonteCarloSimulationPaths_tanh_noise_erf_Y()
        -----------------------------------------------------------
        @input: Z0 = np.array([.01, .01])
            
            Z0 = [lateral_inital, noise]
        
        
        @output: paths
            
            a pd. 
            
        @output: Ys,Zs
        
            
            Both are pd.dataframe. The index are moments, and each column is a system path. 
            
        """
        import sdeint
        results = []
        #
        res_Y = []
        res_Z = []

        #S = [y, vy, z],
        def f_S(S, t, ego_lane_lw = 3.5, stochastic_proecess_name = 'converted', two_dim_paras = two_dim_paras):
            #
            gamma_middle_line  = two_dim_paras['gamma_middle_line']
            sigma_lat_drift = two_dim_paras['sigma_lat_drift']
            sigma_lat = two_dim_paras['sigma_lat']
            beta = two_dim_paras['beta_lane_middle_line']
            
            #S = [y, vy, z], z is the nois. 
            y,vy,Z_lat = S
            #
            tmp0 = vy
            #
            tmp1a = beta*beta*(2.0*y-ego_lane_lw)*np.exp(-beta*beta*(y-ego_lane_lw/2.0)*(y-ego_lane_lw/2.0))
            tmp1b = beta*beta*(2.0*y+ego_lane_lw)*np.exp(-beta*beta*(y+ego_lane_lw/2.0)*(y+ego_lane_lw/2.0))
            vy_function = np.exp(-beta*beta*(y+ego_lane_lw/2.0)*(y+ego_lane_lw/2.0))-np.exp(-beta*beta*(y-ego_lane_lw/2.0)*(y-ego_lane_lw/2.0))
            #
            tmp_equi_a = beta*beta*(2.0*.0-ego_lane_lw)*np.exp(-beta*beta*(.0-ego_lane_lw/2.0)*(.0-ego_lane_lw/2.0))
            tmp_equi_b = beta*beta*(2.0*.0+ego_lane_lw)*np.exp(-beta*beta*(.0+ego_lane_lw/2.0)*(.0+ego_lane_lw/2.0))
            #tmp1 = (tmp1a - tmp1b - (tmp_equi_a - tmp_equi_b))*gamma_middle_line  + Z_lat
            tmp1 = vy*(tmp1a - tmp1b)*gamma_middle_line  + Z_lat
            
            #==============================diff_Z_long, diff_Z_lat
            if stochastic_proecess_name=='OU':

                diff_Z_lat = -sigma_lat_drift*Z_lat
            elif stochastic_proecess_name=='simple':

                diff_Z_lat = 0
            elif stochastic_proecess_name=='converted':

                diff_Z_lat = -(sigma_lat**2)*(1-Z_lat**2)*Z_lat
                
            elif stochastic_proecess_name=='geometric':

                diff_Z_lat = -sigma_lat_drift*(Z_lat)
                #
            elif stochastic_proecess_name=='jacobi':

                diff_Z_lat = -sigma_lat_drift*(Z_lat - .0)
                #
            elif stochastic_proecess_name=='hyperparabolic':
                #

                diff_Z_lat = -Z_lat-sigma_lat_drift*Z_lat
                #print(diff_Z_long, diff_Z_lat)
            elif stochastic_proecess_name=='ROU':

                diff_Z_lat = -sigma_lat_drift/Z_lat +  Z_lat #-sigma_lat_drift*(Z_lat - .0)
            
            return np.array([tmp0, tmp1, diff_Z_lat])
            
        def g_S(S, t, ego_lane_lw = 3.5, stochastic_proecess_name = 'converted', two_dim_paras = two_dim_paras):
            #S = [y, vy, z], z is the nois. 
            y,vy,Z_lat = S

            sigma_lat = two_dim_paras['sigma_lat']
            
            #------------------------------------------
            if stochastic_proecess_name=='OU':
                tmp_lat = sigma_lat
                #
            elif stochastic_proecess_name=='simple':
                tmp_lat = sigma_lat
                
            elif stochastic_proecess_name=='converted':
                tmp_lat = sigma_lat*(1-Z_lat**2)
                #
            elif stochastic_proecess_name=='geometric':
                tmp_lat = sigma_lat*(Z_lat)
                #
            elif stochastic_proecess_name=='hyperparabolic':

                tmp_lat = sigma_lat
                
            elif stochastic_proecess_name=='jacobi':
                #print(Z_lat, (.5-Z_lat), (Z_lat+.5))
                Z_lat = max(-.499999, min(Z_lat, .4999999))
                tmp_lat = np.sqrt(sigma_lat*(Z_lat+.5)*(.5-Z_lat))
            elif stochastic_proecess_name=='ROU':

                tmp_lat = sigma_lat
            
            #
            #tmp_long =  sigma_long*(1.0-Z_long**2)
            #tmp_lat = sigma_lat*(1-Z_lat**2)
            array = np.array([[0.0, .0, tmp_lat]])
            #array = np.array([[.0, .0, .0, .0, tmp_long, .0], \
            #                  [.0, .0, .0, .0, 0, tmp_lat]])
            
            
            return array.T
            
        #---------------------------------------------
        for iterr in range(N_paths):
            #result.shape is (len(tspan),2), '2' corresponds to Z.
            #   the first column is lateral displacement, and the 2nd columns is the noize. 
            result = sdeint.itoint(f_S, g_S, S0, tspan)
            results.append(result)
            #res_Y.append(result[:,0])
            #res_Z.append(result[:,1])
        #-----------------------------------------
        #np.array(res_Y) shape is N_paths,len(tspan)
        #np.array(res_Z) shape is N_paths,len(tspan)
        return results
        #return pd.DataFrame(res_Y, columns =  tspan).T,pd.DataFrame(res_Z, columns =  tspan).T




def plot_tmp(STATES, tspan = np.linspace(0, 100, 200),figsize = (5,3), alpha = .4, idx = 0, ax = False):
    """"""
    if isinstance(ax, bool):

        fig,ax = plt.subplots(figsize = figsize)

    
    for state in STATES:
        
        ax.plot(tspan, state[:, idx])
    
    return ax


class SingleLaneSim():
    """
    
    """
    
    @classmethod
    def TrimUpdate(self, old_state, deltat_sec, F, L, brownian, idm_paras = idm_paras):
        """
        The update of the state is calculated as:
        
            new_state = old_state + F*deltat_sec + np.matmul(L, brownian)
            
        Or equilivalently:
        
            new_state = old_state + (F + np.matmul(L, brownian/deltat_sec))*deltat_sec
        
        The above is for the sysmtem dynamics dS = F(S)dt + L(S) dW. 
        
        
        However, the acceleration may exceed the maximum acceleration. 
        
        -----------------------------------
        @input: deltat_sec
        
            a float. 
        
        @input: F L
        
            both are array. 
            
            F.shape is (6,)
            
            L.shape is (6, 2)
            
            brownian shape is (2,)
            
            
        
        """
        
        #increment shape is (6,)
        increment = F + np.matmul(L, brownian/deltat_sec)
        
        #the speed. must be positive. 
        increment[0] = max(0, increment[0])
        
        #the acceelration, must be fall in reasonable interval 
        increment[1] = min(idm_paras['a_MAX'], max(-idm_paras['a_MAX'], increment[1]))
        
        feasible_increment = increment*deltat_sec
        
        return old_state + increment*deltat_sec,feasible_increment


    @classmethod
    def Get_QK(self, snapshots, length = 500, Deltat_FD_sec = 30):
        """
        calculate the Qand K
        
            = 
        
        @input: snapshots
        
            snapshots[moment].kesys() are:
            
                self.snapshots[T]['vehs_at_lanes'] = copy.deepcopy(self.vehs_at_lanes)
                self.snapshots[T][vid] = {'S':copy.deepcopy(self.vehs_dict[vid]), \
                    #'feasibleincrement':copy.deepcopy(feasible_increment), \
                    'L':copy.deepcopy(L_dicts[vid]), \
                    'F':copy.deepcopy(F_dicts[vid]), \
                    'vehs_info_within_area_left':copy.deepcopy(vehs_info_within_area_left_dict[vid]), \
                    'vehs_info_within_area_right':copy.deepcopy(vehs_info_within_area_right_dict[vid]), \
                    'potentials':copy.deepcopy(potentials_dict[vid]), }
        
        @input: Deltat_FD_sec
        
            the time step that calculate the FD parameters. 
        
        @OUTPUT: Q and K
        
            both are dicts. 
            
            Q[laneid] = [q1, q2, q3, q4...]
            K[laneid] = [k1, k2, k3, k4...]
            
            Q unit is veh/h
            K unit is veh/km
        
        
        
        
        -----------------------------
        Q = dA/|A|, d is the distance travelled by all vehicles.
        K = t(A)/|A|, t is the total time travelled. 
        """
        #Q[laneid] = [q1, q2, q3, q4...]
        #K[laneid] = [k1, k2, k3, k4...]
        t = sorted(snapshots.keys())[0]
        Q = {lane_id:[] for lane_id in snapshots[t]['vehs_at_lanes'].keys()}
        K = {lane_id:[] for lane_id in snapshots[t]['vehs_at_lanes'].keys()}
        
        #unit is km.h
        area = (length/1000.0)*(Deltat_FD_sec/3600.0)
        #
        Ts = sorted(snapshots.keys())
        #
        start = 0.0
        end = start + Deltat_FD_sec
        while end<=max(Ts):
            #unit is sec and meter.
            totaltimetravelled_sec = 0
            totaldistancetravelled_meter = 0
            #
            interval_ts = sorted(Ts[Ts>start and Ts<=end])
            for t0,t1 in zip(interval_ts[:-1], interval_ts[1:]):
                #
                #for lane_id in snapshots[t]['vehs_at_lanes'].keys():
                    #
                for vid in snapshots[t]['vehs_at_lanes']:
                    #time travelled
                    totaltimetravelled_sec = totaltimetravelled_sec + t1 - t0
                    #distancetravelled
                    if snapshots[t1][vid]['S'][0]<=snapshots[t0][vid]['S'][0]:
                        distance_travelled_vid = snapshots[t1][vid]['S'][0] + length - snapshots[t0][vid]['S'][0]
                    else:
                        distance_travelled_vid = snapshots[t1][vid]['S'][0]  - snapshots[t0][vid]['S'][0]
                    #
                    totaldistancetravelled_meter = totaldistancetravelled_meter  + distance_travelled_vid
                #
                Q_interval = totaldistancetravelled_meter/1000.0/area
                K_interval = totaldistancetravelled_meter/3600.0/area
                #
                Q[lane_id].append(Q_interval)
                K[lane_id].append(K_interval)
            start = end
        
        return Q,K
        
    def get_lanes_densities(self, ):
        """
        Get the density of all lanes.
        
        -------------------------------
        @output: lanesdensities
        
            lanesdensities[lane_id] = float.
        
        """
        
        return len(self.vehs_dict)/(self.length/1000.0)
    
    
    def plot_lanemarks_boundary(self, ax = False, figsize = (5,3), alpha = .4, markcolor = 'y', boundarycolor = 'k'):
        """
        
        """
        #==========================================
        if isinstance(ax, bool):
            fig,ax = plt.subplots(figsize = figsize)
            ax.set_xlabel('x');ax.set_ylabel('y'); 
            #ax.grid();
            #ax = host_subplot(111)
            #par = ax.twinx()
            #fig,ax = plt.subplots(figsize = figsize, nrows = 1, ncols = 1)
        
        #
        ax.plot([0, self.length], (self.road_bounds[0],  self.road_bounds[0]), 'k.-', linewidth = 4 )
        ax.plot([0, self.length], (self.road_bounds[1],  self.road_bounds[1]), 'k.-', linewidth = 4 )
        
        return ax


    def __init__(self, lw = 3.5, length = 500):
        """
        
        ---------------------------------------------------------------
        @input: lws
        
            a lists containing the lane withs of each lane. 
            
            
            
        """
        #======================================self.road_bounds
        self.road_bounds = (0, lw)
        #lw_boundary_lanes
        #self.lw_boundary_lanes = (self.lws[0], self.lws[-1])
        
        
        
        #========================================self.lanes_ids, self.lws, self.length
        #   lane id
        self.lw = lw
        self.length = length
        

        #======================================self.road_bounds

        
        #========================================Dynmaic properties. 
        #   ----------------self.vehs_at_lanes, self.vehs_dict,self.vehs_target_lane
        #self.vehs_at_lanes= [vid1, vid2,....]. NOTE THAT THEY ARE SPORTED FROM 1st vehicle to last vehicle. 
        self.vehs_at_lanes  =  []
        #self.vehs_dict[vehicle_id] = [x, vx, y, vy, zlon, zlat]
        self.vehs_dict = {}
        #   self.snapshots[moment] is a dict. 
        #   self.snapshots[moment][vid] is a dict. 
        #   self.snapshots[moment][vid] keys include 'leader','neighbores','potentials.'
        self.snapshots = {}
        #-------------------------------

    @classmethod
    def plot_speed_color(self, STATES, ax = False, figsize = (5,3), alpha = .4, vmax = 200/3.6):
        """
        
        @input: STATES
        
            STATES[moment] = {vid:np.array([x,vx, y, vy, zlon, zlat])}
            
            
        """
        
        if isinstance(ax, bool):
            fig,ax = plt.subplots(figsize = figsize)
            ax.set_xlabel('Time (sec)');ax.set_ylabel('x (m)'); 
            #ax.grid();
            #ax = host_subplot(111)
            #par = ax.twinx()
            #fig,ax = plt.subplots(figsize = figsize, nrows = 1, ncols = 1)
        for t in sorted(STATES.keys()):
            #SNAPSHOTS[t].keys are the vids
            vids = set(STATES[t].keys())
            xs = [STATES[t][vid][0] for vid in vids]
            #make color
            vxs = [STATES[t][vid][1] for vid in vids]
            vxs1 = list(np.array(vxs)/vmax)
            vxs2 = [np.array([v, v, 0]) for v in vxs1]
            #print(max(vxs1))
            #
            ts = np.array([t]*len(xs))
            
            ax.scatter(ts, xs, c = np.tan(vxs1), marker = '.')
        
        #
        #ax.set_xlabel('x ( m )');ax.set_ylabel('y ( m )'); ax.grid()
        
        #plt.colorbar()
        plt.tight_layout()
        
        return ax


    @classmethod
    def plot_sim(self, STATES, ax = False, figsize = (5,3), alpha = .4,):
        """
        
        @input: STATES
        
            STATES[moment] = {vid:np.array([x,vx, y, vy, zlon, zlat])}
        
        
        """
        
        
        if isinstance(ax, bool):
            fig,ax = plt.subplots(figsize = figsize)
            ax.set_xlabel('x');ax.set_ylabel('y'); 
            #ax.grid();
            #ax = host_subplot(111)
            #par = ax.twinx()
            #fig,ax = plt.subplots(figsize = figsize, nrows = 1, ncols = 1)
        
        #vids_startmoments[vid] = t, means that the vid first appear at moment t. 
        vids_startmoments = {}
        vids_existing = set()
        for t in sorted(STATES.keys()):
            #SNAPSHOTS[t].keys are the vids
            vids = set(STATES[t].keys())
            #
            #find the 
            new_vids = vids.difference(vids_existing)
            for vid in new_vids:
                vids_startmoments[vid] = t
                
            vids_existing = vids
        
        #
        for vid in vids_startmoments:
            #
            t = vids_startmoments[vid]
            #find the keys (effective_ts) that vid have data. 
            tmp = np.array(sorted(STATES.keys()))
            effective_ts =tmp[tmp>=t]
            
            #
            xs = [STATES[t][vid][0] for t  in effective_ts]
            ys = [STATES[t][vid][2] for t  in effective_ts]
            ax.plot(xs, ys, '.', alpha = alpha)
            #ax = self.plot_path(path = sim_res, ax = ax, figsize = figsize, alpha = alpha,)
        
        #
        ax.set_xlabel('x ( m )');ax.set_ylabel('y ( m )'); ax.grid()
        
            
        plt.tight_layout()
        
        return ax


    @classmethod
    def plot_sim_from_snapshots(self, snapshots, ax = False, figsize = (5,3), alpha = .4,):
        """
        
        state variable is self.vehs_dict[vehicle_id] = [x, vx, y, vy, zlon, zlat]
        
        ------------------------------------------------
        @input: STATES
        
            STATES[moment] = {vid:np.array([x,vx, y, vy, zlon, zlat])}

        @input: snapshots
                
                #
                self.snapshots[T]['vehs_at_lanes'] = copy.deepcopy(self.vehs_at_lanes)
                self.snapshots[T][vid] = {'S':copy.deepcopy(self.vehs_dict[vid]), \
                    'feasibleincrement':copy.deepcopy(feasible_increment), \
                    'L':copy.deepcopy(L_dicts[vid]), \
                    'F':copy.deepcopy(F_dicts[vid]), \
                    'potentials':copy.deepcopy(potentials_dict[vid]),}
        
        """
        
        
        if isinstance(ax, bool):
            fig,ax = plt.subplots(figsize = figsize)
            ax.set_xlabel('x');ax.set_ylabel('y'); 
            #ax.grid();
            #ax = host_subplot(111)
            #par = ax.twinx()
            #fig,ax = plt.subplots(figsize = figsize, nrows = 1, ncols = 1)
        
        #vids_startmoments[vid] = t, means that the vid first appear at moment t. 
        t0 = max(snapshots.keys())
        vids = snapshots[t0]['vehs_at_lanes']
        """
        vids_startmoments = {}
        vids_existing = set()
        for t in sorted(snapshots.keys()):
            #SNAPSHOTS[t].keys are the vids
            vids = snapshots[t]['vehs_at_lanes']
            #
            #find the 
            new_vids = vids.difference(vids_existing)
            for vid in new_vids:
                vids_startmoments[vid] = t
                
            vids_existing = vids
        
        """
        
        #
        for vid in vids:
            #
            #t = vids_startmoments[vid]
            #find the keys (effective_ts) that vid have data. 
            ts = np.array(sorted(snapshots.keys()))
            effective_ts =  [t for t in ts if vid in snapshots[t]['vehs_at_lanes']]#tmp[tmp>=t]
            
            #
            #print(snapshots[0][vid].keys())
            xs = [snapshots[t][vid]['S'][0] for t in effective_ts]
            ys = [snapshots[t][vid]['S'][2] for t in effective_ts]
            ax.plot(xs, ys, '.', alpha = alpha)
            #ax = self.plot_path(path = sim_res, ax = ax, figsize = figsize, alpha = alpha,)
        
        #
        ax.set_xlabel('x ( m )');ax.set_ylabel('y ( m )'); ax.grid()
        
            
        plt.tight_layout()
        
        return ax
    
    
    @classmethod
    def plot_sim_marginal_distribution(self, STATES, roadlength, ax = False, figsize = (5,3), alpha = .4, n_xs_marginal = 10, tolerance_x_find_y = 1.0, bins = 20):
        """
        plot the xy and the p(y | x), i.e. the marginal distribution. 
        
        
        @input: STATES
        
            STATES[moment] = {vid:np.array([x,vx, y, vy, zlon, zlat])}
        
        @input: tolerance_x_find_y
        
            given x0, when finding y, the method is that:
            
                - find the idx that with x sasitf abs(x-x0)<tolerance_x_find_y
                - get the y. 
        
        @input: n_xs_marginal
        
            the number of the marginals to be calculated and plotted. 
        
        """
        #
        xs_marginals  = np.linspace(1, roadlength-1, n_xs_marginal)
        
        if isinstance(ax, bool):
            fig,axs = plt.subplots(figsize = figsize, ncols = 1, nrows = 2)
            #ax.set_xlabel('x');ax.set_ylabel('y'); 
            #ax.grid();
            #ax = host_subplot(111)
            #par = ax.twinx()
            #fig,ax = plt.subplots(figsize = figsize, nrows = 1, ncols = 1)
        ##############################First plot
        ax = axs[0]
        #vids_startmoments[vid] = t, means that the vid first appear at moment t. 
        vids_startmoments = {}
        vids_existing = set()
        for t in sorted(STATES.keys()):
            #SNAPSHOTS[t].keys are the vids
            vids = set(STATES[t].keys())
            #
            #find the 
            new_vids = vids.difference(vids_existing)
            for vid in new_vids:
                vids_startmoments[vid] = t
            vids_existing = vids
        #
        for vid in vids_startmoments:
            #
            t = vids_startmoments[vid]
            #find the keys (effective_ts) that vid have data. 
            tmp = np.array(sorted(STATES.keys()))
            effective_ts =tmp[tmp>=t]
            
            #
            xs = [STATES[t][vid][0] for t  in effective_ts]
            ys = [STATES[t][vid][2] for t  in effective_ts]
            ax.plot(xs, ys, '.', alpha = alpha)
            #ax = self.plot_path(path = sim_res, ax = ax, figsize = figsize, alpha = alpha,)
        
        ax.set_ylim([0, 3.5])
        ax.set_xlabel('x ( m )');ax.set_ylabel('y ( m )'); ax.grid()
        
        #############################second plot
        ax = axs[1]
        for x in xs_marginals:
            ys = []
            for t in sorted(STATES.keys()):
                for vid in STATES[t].keys():
                    if abs(STATES[t][vid][0] - x)<=tolerance_x_find_y:
                        ys.append(STATES[t][vid][2])
            #
            hist, edges = np.histogram(ys, bins = bins)
            ax.plot(edges[1:], hist/sum(hist)/(edges[-1] - edges[-2]), label = 'loc = ' + str(int(x*100)/100.0) + ' m')
        ax.set_xlim([0, 3.5])
        ax.legend()
        ax.set_xlabel('lateral location y ( m )')
        ax.set_ylabel('probability')
        ax.grid()
        
        plt.tight_layout()
        
        return axs



    @classmethod
    def plot_speed_profile_singlelane_trajectories(self, snapshots, length = 500, laneid = 0, ax = False, figsize = (5,3), alpha = .4, vmax = 200/3.6, timeintervalploted = (100, 200), cmap = 'Blues', ):
        """
        plot the speed profile of 3D, i.e. (t, x, v)
        
        
        @input: snapshots
        
                self.snapshots[T][vid] = {'S':copy.deepcopy(self.vehs_dict[vid]), \
                    'feasibleincrement':copy.deepcopy(feasible_increment), \
                    'L':copy.deepcopy(L_dicts[vid]), \
                    'F':copy.deepcopy(F_dicts[vid]), \
                    'potentials':copy.deepcopy(potentials_dict[vid]), }
        
        
        
        @input: cmap
        
        ValueError: 'OrangeBlue' is not a valid value for name; supported values are 'Accent', 'Accent_r', 'Blues', 'Blues_r', 'BrBG', 'BrBG_r', 'BuGn', 'BuGn_r', 'BuPu', 'BuPu_r', 'CMRmap', 'CMRmap_r', 'Dark2', 'Dark2_r', 'GnBu', 'GnBu_r', 'Greens', 'Greens_r', 'Greys', 'Greys_r', 'OrRd', 'OrRd_r', 'Oranges', 'Oranges_r', 'PRGn', 'PRGn_r', 'Paired', 'Paired_r', 'Pastel1', 'Pastel1_r', 'Pastel2', 'Pastel2_r', 'PiYG', 'PiYG_r', 'PuBu', 'PuBuGn', 'PuBuGn_r', 'PuBu_r', 'PuOr', 'PuOr_r', 'PuRd', 'PuRd_r', 'Purples', 'Purples_r', 'RdBu', 'RdBu_r', 'RdGy', 'RdGy_r', 'RdPu', 'RdPu_r', 'RdYlBu', 'RdYlBu_r', 'RdYlGn', 'RdYlGn_r', 'Reds', 'Reds_r', 'Set1', 'Set1_r', 'Set2', 'Set2_r', 'Set3', 'Set3_r', 'Spectral', 'Spectral_r', 'Wistia', 'Wistia_r', 'YlGn', 'YlGnBu', 'YlGnBu_r', 'YlGn_r', 'YlOrBr', 'YlOrBr_r', 'YlOrRd', 'YlOrRd_r', 'afmhot', 'afmhot_r', 'autumn', 'autumn_r', 'binary', 'binary_r', 'bone', 'bone_r', 'brg', 'brg_r', 'bwr', 'bwr_r', 'cividis', 'cividis_r', 'cool', 'cool_r', 'coolwarm', 'coolwarm_r', 'copper', 'copper_r', 'crest', 'crest_r', 'cubehelix', 'cubehelix_r', 'flag', 'flag_r', 'flare', 'flare_r', 'gist_earth', 'gist_earth_r', 'gist_gray', 'gist_gray_r', 'gist_heat', 'gist_heat_r', 'gist_ncar', 'gist_ncar_r', 'gist_rainbow', 'gist_rainbow_r', 'gist_stern', 'gist_stern_r', 'gist_yarg', 'gist_yarg_r', 'gnuplot', 'gnuplot2', 'gnuplot2_r', 'gnuplot_r', 'gray', 'gray_r', 'hot', 'hot_r', 'hsv', 'hsv_r', 'icefire', 'icefire_r', 'inferno', 'inferno_r', 'jet', 'jet_r', 'magma', 'magma_r', 'mako', 'mako_r', 'nipy_spectral', 'nipy_spectral_r', 'ocean', 'ocean_r', 'pink', 'pink_r', 'plasma', 'plasma_r', 'prism', 'prism_r', 'rainbow', 'rainbow_r', 'rocket', 'rocket_r', 'seismic', 'seismic_r', 'spring', 'spring_r', 'summer', 'summer_r', 'tab10', 'tab10_r', 'tab20', 'tab20_r', 'tab20b', 'tab20b_r', 'tab20c', 'tab20c_r', 'terrain', 'terrain_r', 'turbo', 'turbo_r', 'twilight', 'twilight_r', 'twilight_shifted', 'twilight_shifted_r', 'viridis', 'viridis_r', 'vlag', 'vlag_r', 'winter', 'winter_r'
        
        @input: 
        
                #SNAPSHOT
                self.snapshots[T]['vehs_at_lanes'] = copy.deepcopy(self.vehs_at_lanes)
                self.snapshots[T][vid] = {'S':copy.deepcopy(self.vehs_dict[vid]), \
                    #'feasibleincrement':copy.deepcopy(feasible_increment), \
                    'L':copy.deepcopy(L_dicts[vid]), \
                    'F':copy.deepcopy(F_dicts[vid]), \
                    'vehs_info_within_area_left':copy.deepcopy(vehs_info_within_area_left_dict[vid]), \
                    'vehs_info_within_area_right':copy.deepcopy(vehs_info_within_area_right_dict[vid]), \
                    'potentials':copy.deepcopy(potentials_dict[vid]), }
                #
        """
        from matplotlib.collections import LineCollection
        #from mpl_toolkits.mplot3d.axes3d import get_test_data
        # This import registers the 3D projection, but is otherwise unused.
        #from mpl_toolkits.mplot3d import Axes3D  # noqa: F401 unused import
        
        t0 = sorted(snapshots.keys())[0]
        #lanes_ids = snapshots[t]['vehs_at_lanes'].keys()
        #lanes_number = len(snapshots[t]['vehs_at_lanes'])
        #==========================================
        if isinstance(ax, bool):
            #fig, ax = plt.subplots(figsize = figsize, ncols = 1, nrows = 1, projection='3d')
            fig, ax = plt.subplots(figsize = figsize)
            #ax = plt.figure(figsize = figsize).add_subplot(projection='3d')
            #ax.set_xlabel('t');ax.set_ylabel('x');ax.set_zlabel('speed'); 
            #ax.grid();
            #ax = host_subplot(111)
            #par = ax.twinx()
            #fig,ax = plt.subplots(figsize = figsize, nrows = 1, ncols = 1)
        #
        #--------------------------------------
        #fig = plt.figure(figsize=plt.figaspect(0.5))
        #fig = plt.figure(figsize=figsize)
        TS = np.array(sorted(snapshots.keys()))
        #for laneidx,laneid in enumerate(lanes_ids):
        #for laneidx in range(lanes_number):
        #ax = axs[laneidx]
        #ax = fig.add_subplot(lanes_number, 1, laneidx, projection='3d')
        #
        #vids = snapshots[t0]['vehs_at_lanes'][laneid]#set(snapshots[t].keys())
        vids0 = []
        for t in TS:vids0.extend(snapshots[t].keys())
        vids = set(vids0)
        #
        #
        TS_es = []
        XS_es = []
        VXs1  = []
        for vid in vids:
            color = np.random.uniform(size = (3,))
            #
            #print(snapshots[t][vid])
            xs0 = [snapshots[t][vid]['S'][0] for t in TS if vid in snapshots[t]['vehs_at_lanes']]
            #
            vxs = [snapshots[t][vid]['S'][1] for t in TS if vid in snapshots[t]['vehs_at_lanes']]
            vxs1 = list(np.array(vxs)/vmax)

            #SEE https://stackoverflow.com/questions/64267329/how-to-plot-a-gradient-color-line
            #cut the trajectories into multi segments, becaus ethe period condition. 
            idxs_segments = TwoDimMicroModel.TransformPeriodic_ys_2MultiSegment_return_idxs_segments(ys = xs0, length = length)
            #ts_es,xs_es = TwoDimMicroModel.TransformPeriodic_ys_2MultiSegment(ys = xs0, length = length, ts = TS)
            #
            for segment in idxs_segments:
                TS_es.append(np.array(TS)[segment])
                XS_es.append(np.array(xs0)[segment])
                VXs1.append(np.array(vxs1)[segment])
        ##################
        for ts,xs,vs in zip(TS_es,XS_es, VXs1):
            points = np.array([ts, xs]).T.reshape(-1, 1, 2)
            segments = np.concatenate([points[:-1], points[1:]], axis=1)
            #lc = LineCollection(segments, cmap='viridis', alpha = alpha)
            lc = LineCollection(segments, cmap = cmap, alpha = alpha)
            lc.set_array(vs)
            ax.add_collection(lc)
            
            """
            #cut the trajectories into multi segments, becaus ethe period condition. 
            ts_es,xs_es = TwoDimMicroModel.TransformPeriodic_ys_2MultiSegment(ys = xs0, length = length, ts = TS)
            for ts,xs in zip(ts_es,xs_es):
                #ax.plot(ts,xs, color = color)
                ax.plot(ts,xs, cmap=plt.get_cmap('jet'))
            """
            #ax.plot(TS, xs0)
        #fig.colorbar(ax=ax)
        ax.set_xlabel('Time');ax.set_ylabel('x (m)');#ax.set_zlabel('speed');
        
        return ax
    



    @classmethod
    def plot_speed_profile_2D_singlelane_trajectories_BKP(self, snapshots, length = 500, ax = False, figsize = (5,3), alpha = .4, vmax = 200/3.6, timeintervalploted = (100, 200)):
        """
        plot the speed profile of 3D, i.e. (t, x, v)
        
        
        @input: 
        
                self.snapshots[T][vid] = {'S':copy.deepcopy(self.vehs_dict[vid]), \
                    'feasibleincrement':copy.deepcopy(feasible_increment), \
                    'L':copy.deepcopy(L_dicts[vid]), \
                    'F':copy.deepcopy(F_dicts[vid]), \
                    'potentials':copy.deepcopy(potentials_dict[vid]), }

                #
        """
        from matplotlib.collections import LineCollection
        #from mpl_toolkits.mplot3d.axes3d import get_test_data
        # This import registers the 3D projection, but is otherwise unused.
        #from mpl_toolkits.mplot3d import Axes3D  # noqa: F401 unused import
        
        t0 = sorted(snapshots.keys())[0]
        #lanes_ids = snapshots[t]['vehs_at_lanes'].keys()
        #lanes_number = len(snapshots[t]['vehs_at_lanes'])
        #==========================================
        if isinstance(ax, bool):
            #fig, ax = plt.subplots(figsize = figsize, ncols = 1, nrows = 1, projection='3d')
            fig, ax = plt.subplots(figsize = figsize)
            #ax = plt.figure(figsize = figsize).add_subplot(projection='3d')
            #ax.set_xlabel('t');ax.set_ylabel('x');ax.set_zlabel('speed'); 
            #ax.grid();
            #ax = host_subplot(111)
            #par = ax.twinx()
            #fig,ax = plt.subplots(figsize = figsize, nrows = 1, ncols = 1)
        #
        #--------------------------------------
        #fig = plt.figure(figsize=plt.figaspect(0.5))
        #fig = plt.figure(figsize=figsize)
        TS = np.array(sorted(snapshots.keys()))
        #for laneidx,laneid in enumerate(lanes_ids):
        #for laneidx in range(lanes_number):
        #ax = axs[laneidx]
        #ax = fig.add_subplot(lanes_number, 1, laneidx, projection='3d')
        #
        #vids = snapshots[t0]['vehs_at_lanes'][laneid]#set(snapshots[t].keys())
        vids0 = []
        for t in TS:vids0.extend(snapshots[t].keys())
        vids = set(vids0)
        #
        #
        for vid in vids:
            color = np.random.uniform(size = (3,))
            #
            print(snapshots[t][vid].keys())
            xs0 = [snapshots[t][vid]['S'][0] for t in TS if vid in snapshots[t]]
            #
            vxs = [snapshots[t][vid]['S'][1] for t in TS if vid in snapshots[t]]
            vxs1 = list(np.array(vxs)/vmax)

            #SEE https://stackoverflow.com/questions/64267329/how-to-plot-a-gradient-color-line
            #cut the trajectories into multi segments, becaus ethe period condition. 
            
            ts_es,xs_es = TwoDimMicroModel.TransformPeriodic_ys_2MultiSegment(ys = xs0, length = length, ts = TS)
            for ts,xs in zip(ts_es,xs_es):
                #ax.plot(ts,xs, color = color)
                #ax.plot(ts,xs, cmap=plt.get_cmap('jet'))
                points = np.array([ts, xs]).T.reshape(-1, 1, 2)
                segments = np.concatenate([points[:-1], points[1:]], axis=1)
                #
                lc = LineCollection(segments, cmap='viridis')
                lc.set_array(vxs1)
                ax.add_collection(lc)
            """
            #cut the trajectories into multi segments, becaus ethe period condition. 
            ts_es,xs_es = TwoDimMicroModel.TransformPeriodic_ys_2MultiSegment(ys = xs0, length = length, ts = TS)
            for ts,xs in zip(ts_es,xs_es):
                #ax.plot(ts,xs, color = color)
                ax.plot(ts,xs, cmap=plt.get_cmap('jet'))
            """
            #ax.plot(TS, xs0)
        #fig.colorbar(ax=ax)
        ax.set_xlabel('Time');ax.set_ylabel('x (m)');#ax.set_zlabel('speed');
        
        return ax
    
    @classmethod
    def plot_twodim_trajectories_givensnapshots_singlelane(self, snapshots, length = 500, ax = False, figsize = (5,3), alpha = .4, vmax = 200/3.6, timeintervalploted = (100, 200), cmap = 'Blues', N_plotted = 20):
        """
        plot the speed profile of 3D, i.e. (t, x, v)
        
        {vid:np.array([x,vx, y, vy, zlon, zlat])}
        
        
        @input: cmap
        
        ValueError: 'OrangeBlue' is not a valid value for name; supported values are 'Accent', 'Accent_r', 'Blues', 'Blues_r', 'BrBG', 'BrBG_r', 'BuGn', 'BuGn_r', 'BuPu', 'BuPu_r', 'CMRmap', 'CMRmap_r', 'Dark2', 'Dark2_r', 'GnBu', 'GnBu_r', 'Greens', 'Greens_r', 'Greys', 'Greys_r', 'OrRd', 'OrRd_r', 'Oranges', 'Oranges_r', 'PRGn', 'PRGn_r', 'Paired', 'Paired_r', 'Pastel1', 'Pastel1_r', 'Pastel2', 'Pastel2_r', 'PiYG', 'PiYG_r', 'PuBu', 'PuBuGn', 'PuBuGn_r', 'PuBu_r', 'PuOr', 'PuOr_r', 'PuRd', 'PuRd_r', 'Purples', 'Purples_r', 'RdBu', 'RdBu_r', 'RdGy', 'RdGy_r', 'RdPu', 'RdPu_r', 'RdYlBu', 'RdYlBu_r', 'RdYlGn', 'RdYlGn_r', 'Reds', 'Reds_r', 'Set1', 'Set1_r', 'Set2', 'Set2_r', 'Set3', 'Set3_r', 'Spectral', 'Spectral_r', 'Wistia', 'Wistia_r', 'YlGn', 'YlGnBu', 'YlGnBu_r', 'YlGn_r', 'YlOrBr', 'YlOrBr_r', 'YlOrRd', 'YlOrRd_r', 'afmhot', 'afmhot_r', 'autumn', 'autumn_r', 'binary', 'binary_r', 'bone', 'bone_r', 'brg', 'brg_r', 'bwr', 'bwr_r', 'cividis', 'cividis_r', 'cool', 'cool_r', 'coolwarm', 'coolwarm_r', 'copper', 'copper_r', 'crest', 'crest_r', 'cubehelix', 'cubehelix_r', 'flag', 'flag_r', 'flare', 'flare_r', 'gist_earth', 'gist_earth_r', 'gist_gray', 'gist_gray_r', 'gist_heat', 'gist_heat_r', 'gist_ncar', 'gist_ncar_r', 'gist_rainbow', 'gist_rainbow_r', 'gist_stern', 'gist_stern_r', 'gist_yarg', 'gist_yarg_r', 'gnuplot', 'gnuplot2', 'gnuplot2_r', 'gnuplot_r', 'gray', 'gray_r', 'hot', 'hot_r', 'hsv', 'hsv_r', 'icefire', 'icefire_r', 'inferno', 'inferno_r', 'jet', 'jet_r', 'magma', 'magma_r', 'mako', 'mako_r', 'nipy_spectral', 'nipy_spectral_r', 'ocean', 'ocean_r', 'pink', 'pink_r', 'plasma', 'plasma_r', 'prism', 'prism_r', 'rainbow', 'rainbow_r', 'rocket', 'rocket_r', 'seismic', 'seismic_r', 'spring', 'spring_r', 'summer', 'summer_r', 'tab10', 'tab10_r', 'tab20', 'tab20_r', 'tab20b', 'tab20b_r', 'tab20c', 'tab20c_r', 'terrain', 'terrain_r', 'turbo', 'turbo_r', 'twilight', 'twilight_r', 'twilight_shifted', 'twilight_shifted_r', 'viridis', 'viridis_r', 'vlag', 'vlag_r', 'winter', 'winter_r'
        
        @input: snapshots
        
                #
                self.snapshots[T]['vehs_at_lanes'] = copy.deepcopy(self.vehs_at_lanes)
                self.snapshots[T][vid] = {'S':copy.deepcopy(self.vehs_dict[vid]), \
                    'feasibleincrement':copy.deepcopy(feasible_increment), \
                    'L':copy.deepcopy(L_dicts[vid]), \
                    'F':copy.deepcopy(F_dicts[vid]), \
                    'potentials':copy.deepcopy(potentials_dict[vid]),}
                
        """
        from matplotlib.collections import LineCollection
        #from mpl_toolkits.mplot3d.axes3d import get_test_data
        # This import registers the 3D projection, but is otherwise unused.
        #from mpl_toolkits.mplot3d import Axes3D  # noqa: F401 unused import
        
        t0 = sorted(snapshots.keys())[0]
        #lanes_ids = snapshots[t]['vehs_at_lanes'].keys()
        #lanes_number = len(snapshots[t]['vehs_at_lanes'])
        #==========================================
        if isinstance(ax, bool):
            #fig, ax = plt.subplots(figsize = figsize, ncols = 1, nrows = 1, projection='3d')
            fig, ax = plt.subplots(figsize = figsize)
            ax.set_xlabel('x');ax.set_ylabel('y'); 
            #ax = plt.figure(figsize = figsize).add_subplot(projection='3d')
            #ax.set_xlabel('t');ax.set_ylabel('x');ax.set_zlabel('speed'); 
            #ax.grid();
            #ax = host_subplot(111)
            #par = ax.twinx()
            #fig,ax = plt.subplots(figsize = figsize, nrows = 1, ncols = 1)
        #
        #--------------------------------------
        #fig = plt.figure(figsize=plt.figaspect(0.5))
        #fig = plt.figure(figsize=figsize)
        TS = np.array(sorted(snapshots.keys()))
        #for laneidx,laneid in enumerate(lanes_ids):
        #for laneidx in range(lanes_number):
        #ax = axs[laneidx]
        #ax = fig.add_subplot(lanes_number, 1, laneidx, projection='3d')
        #
        #vids = snapshots[t0]['vehs_at_lanes'][laneid]#set(snapshots[t].keys())
        vids0 = []
        for t in TS:
            vids0.extend(snapshots[t]['vehs_at_lanes'])
        vids = set(vids0)
        #
        #
        TS_es = []
        XS_es = []
        YS_es = []
        VXs1  = []
        for vid in vids:
            color = np.random.uniform(size = (3,))
            #Note that the state is [x, vx, y, vy, zlon, zlat]
            ts0 = [t for t in TS if vid in snapshots[t]]
            xs0 = [snapshots[t][vid]['S'][0] for t in TS if vid in snapshots[t]]
            ys0 = [snapshots[t][vid]['S'][2] for t in TS if vid in snapshots[t]]
            #
            vxs = [snapshots[t][vid]['S'][1] for t in TS if vid in snapshots[t]]
            vxs1 = list(np.array(vxs)/vmax)

            #SEE https://stackoverflow.com/questions/64267329/how-to-plot-a-gradient-color-line
            #cut the trajectories into multi segments, becaus ethe period condition. 
            idxs_segments = TwoDimMicroModel.TransformPeriodic_ys_2MultiSegment_return_idxs_segments(ys = xs0, length = length)
            #ts_es,xs_es = TwoDimMicroModel.TransformPeriodic_ys_2MultiSegment(ys = xs0, length = length, ts = TS)
            #
            for segment in idxs_segments:
                TS_es.append(np.array(ts0)[segment])
                #
                XS_es.append(np.array(xs0)[segment])
                YS_es.append(np.array(ys0)[segment])
                #
                VXs1.append(np.array(vxs1)[segment])
        ##################
        N_plotted = min(N_plotted, len(TS_es))
        selected_idxes = np.random.choice(list(range(len(TS_es))), N_plotted)
        #for ts,xs,ys,vs in zip(TS_es,XS_es, YS_es, VXs1):
        for idx in selected_idxes:
            ts = TS_es[idx]
            xs = XS_es[idx]
            ys = YS_es[idx]
            vs = VXs1[idx]
            #
            points = np.array([xs,ys]).T.reshape(-1, 1, 2)
            segments = np.concatenate([points[:-1], points[1:]], axis=1)
            #lc = LineCollection(segments, cmap='viridis', alpha = alpha)
            lc = LineCollection(segments, cmap = cmap, alpha = alpha)
            lc.set_array(vs)
            ax.add_collection(lc)
            
            """
            #cut the trajectories into multi segments, becaus ethe period condition. 
            ts_es,xs_es = TwoDimMicroModel.TransformPeriodic_ys_2MultiSegment(ys = xs0, length = length, ts = TS)
            for ts,xs in zip(ts_es,xs_es):
                #ax.plot(ts,xs, color = color)
                ax.plot(ts,xs, cmap=plt.get_cmap('jet'))
            """
        
        return ax
    


    @classmethod
    def plot_speed_profile_3D_singlelane(self, snapshots, ax = False, figsize = (5,3), alpha = .4,):
        """
        plot the speed profile of 3D, i.e. (t, x, v)
        
        
        @input: 
        
                #SNAPSHOT
                self.snapshots[T]['vehs_at_lanes'] = copy.deepcopy(self.vehs_at_lanes)
                self.snapshots[T][vid] = {'S':copy.deepcopy(self.vehs_dict[vid]), \
                    #'feasibleincrement':copy.deepcopy(feasible_increment), \
                    'L':copy.deepcopy(L_dicts[vid]), \
                    'F':copy.deepcopy(F_dicts[vid]), \
                    'vehs_info_within_area_left':copy.deepcopy(vehs_info_within_area_left_dict[vid]), \
                    'vehs_info_within_area_right':copy.deepcopy(vehs_info_within_area_right_dict[vid]), \
                    'potentials':copy.deepcopy(potentials_dict[vid]), }
                #
        """
        
        #from mpl_toolkits.mplot3d.axes3d import get_test_data
        # This import registers the 3D projection, but is otherwise unused.
        #from mpl_toolkits.mplot3d import Axes3D  # noqa: F401 unused import
        
        t = sorted(snapshots.keys())[0]
        #lanes_ids = snapshots[t]['vehs_at_lanes'].keys()
        #lanes_number = len(snapshots[t]['vehs_at_lanes'])
        #==========================================
        if isinstance(ax, bool):
            #fig, ax = plt.subplots(figsize = figsize, ncols = 1, nrows = 1, projection='3d')
            
            ax = plt.figure().add_subplot(projection='3d')
            #ax.set_xlabel('t');ax.set_ylabel('x');ax.set_zlabel('speed'); 
            #ax.grid();
            #ax = host_subplot(111)
            #par = ax.twinx()
            #fig,ax = plt.subplots(figsize = figsize, nrows = 1, ncols = 1)
        #
        #--------------------------------------
        #fig = plt.figure(figsize=plt.figaspect(0.5))
        #fig = plt.figure(figsize=figsize)
        Ts = np.array(sorted(snapshots.keys()))
        #for laneidx,laneid in enumerate(lanes_ids):
        #for laneidx in range(lanes_number):
        #ax = axs[laneidx]
        #ax = fig.add_subplot(lanes_number, 1, laneidx, projection='3d')
        #
        for t in Ts:
            #SNAPSHOTS[t].keys are the vids
            vids = snapshots[t].keys()#set(snapshots[t].keys())
            #print(laneidx, vids)
            xs = [snapshots[t][vid]['S'][0] for vid in vids]
            #make color
            vxs = [snapshots[t][vid]['S'][1] for vid in vids]
            #vxs1 = list(np.array(vxs)/vmax)
            #vxs2 = [np.array([v, v, 0]) for v in vxs1]
            #print(max(vxs1))
            #
            ts = np.array([t]*len(xs))
            
            
            ax.plot(ts, xs, vxs,  marker = '.')
        ax.set_xlabel('Time');ax.set_ylabel('x (m)');ax.set_zlabel('speed');
    
    
    def sim_insert_all_vehs_at_once_mixedAVs(self, deltat_sec =.5, \
            T_horizon_sec = 3600.0, \
            desired_density = 100, \
            inserted_initial_state = np.array([.0, .0, 1.75, 0, .000001, .00001]), \
            safety_gap2downstream_when_insert = 10, \
            safety_gap2upstream_when_insert = 10,  \
            stochastic_proecess_name = 'OU', \
            two_dim_paras = two_dim_paras, \
            leader_state_infinity = np.array([1e10, .0, .0, 0, .0, .0]), \
            intert_tolerance = 1e-1, \
            deltax_2d_or_not = False, \
            two_dim_paras_AV = two_dim_paras_AV, \
            idm_paras = idm_paras, \
            idm_paras_AV = idm_paras_AV, \
            mpr = .0 ):
        """
        state variable is self.vehs_dict[vehicle_id] = [x, vx, y, vy, zlon, zlat]
        
        
        
        
        """
        self.vehs_two_dim_paras = {}
        self.vehs_idm_paras = {}
        #======================Insert vehicles. 
        #   determine the locs of the vehicles.
        vehs_number = int(max(2, min(desired_density/1000.0*(self.length), (self.length)/1000.0*135)))
        space = self.length/vehs_number
        equilibrium_v = TwoDimMicroModel.IDM_equilibrium_v_from_deltax(deltax = space)
        #
        locs_inserted = [intert_tolerance]
        for i in range(vehs_number):
            tmp = locs_inserted[-1] + space
            if tmp<=self.length:
                locs_inserted.append(tmp)
            else:
                break
        #   Insert vehicles
        for i,loc in enumerate(locs_inserted):
            state = np.array([loc, equilibrium_v, self.lw/2.0, 1e-5, .0000001, .0000001])#inserted_initial_state
            #state[0] = loc
            #state[2] = self.lw/2.0
            #np.array([loc, .0, self.lw/2.0, .0, .0, .0])
            self.vehs_at_lanes.append(i)
            #self.vehs_dict[vehicle_id] = [x, vx, y, vy, zlon, zlat]
            self.vehs_dict[i] = state
            #
            if np.random.uniform()<mpr:
                self.vehs_two_dim_paras[i] = copy.deepcopy(two_dim_paras_AV)
                self.vehs_idm_paras[i] = copy.deepcopy(idm_paras_AV)
            else:
                self.vehs_two_dim_paras[i] = copy.deepcopy(two_dim_paras)
                self.vehs_idm_paras[i] = copy.deepcopy(idm_paras)
        #
        #==============================
        #
        T = 0
        STATES = {}
        while T<T_horizon_sec:
            self.snapshots[T] = {}
            #=======================================================
            #calcualte F and L. keys are the vehicle ids. 
            #   F_dicts[vid] is a 1d array. 
            #   L_dicts[vid] is a N*2 array. 2 means lon and lat noise. 
            F_dicts = {}
            L_dicts = {}
            leader_state_dict = {}
            potentials_dict = {}
            for i,vid in enumerate(self.vehs_at_lanes):
                # ----------------------------
                ego_state = self.vehs_dict[vid]
                #
                #------------------------------------------
                #find the leader 
                if len(self.vehs_at_lanes)==1:
                    leader_state = copy.deepcopy(ego_state)
                    leader_state[0] = ego_state[0]+1e10
                else:
                    if i==len(self.vehs_at_lanes)-1:
                        #
                        leader_id = self.vehs_at_lanes[0]
                        leader_state = copy.deepcopy(self.vehs_dict[leader_id])
                        leader_state[0] = leader_state[0]+ self.length
                        
                    else:
                        leader_id = self.vehs_at_lanes[i+1]
                        leader_state = self.vehs_dict[leader_id]
                    #------------------search leader at ego lane. 
                leader_state_dict[vid] = copy.deepcopy(leader_state)
                #
                #-----------------
                #--------------calculate the F and L
                #   F_dicts[vid] is a 1d array. 
                F_dicts[vid],potentials_dict[vid] = TwoDimMicroModel.F_SingleLane(ego_state  = ego_state, \
                    ego_lane_lw = self.lw, \
                    ego_lane_middle_line_coor = self.lw/2.0, \
                    ego_lane_marks_coor = (0, self.lw), \
                    road_bounds = (0, self.lw), \
                    lw_boundary_lanes = (self.lw, self.lw), \
                    leader_state = leader_state, \
                    two_dim_paras = self.vehs_two_dim_paras[vid], \
                    idm_paras = self.vehs_idm_paras[vid], \
                    stochastic_proecess_name = stochastic_proecess_name, \
                    deltax_2d_or_not = deltax_2d_or_not)
                #
                L_dicts[vid] = TwoDimMicroModel.L(state  = ego_state, two_dim_paras = two_dim_paras, stochastic_proecess_name = stochastic_proecess_name)

                
            ################################UPDATE
            for vid in self.vehs_dict.keys():
                brownian = np.random.normal(loc = np.zeros((2,)), scale = deltat_sec)
                
                #
                #print(self.vehs_dict[vid], vid in F_dicts, vid in L_dicts)
                #
                #new_state = self.vehs_dict[vid] + F_dicts[vid] + np.matmul(L_dicts[vid], brownian/deltat_sec)
                new_state,feasible_increment = self.TrimUpdate(old_state = self.vehs_dict[vid], deltat_sec = deltat_sec, F = F_dicts[vid], L = L_dicts[vid], brownian = brownian, idm_paras = idm_paras)
                #
                #print(F_dicts[vid].shape, np.matmul(L_dicts[vid], brownian).shape)
                #new_state = self.vehs_dict[vid] + F_dicts[vid]*deltat_sec + np.matmul(L_dicts[vid], brownian)
                #---------------------UPDATE systen variables. 
                #SNAPSHOT
                #
                self.snapshots[T]['vehs_at_lanes'] = copy.deepcopy(self.vehs_at_lanes)
                self.snapshots[T][vid] = {'S':copy.deepcopy(self.vehs_dict[vid]), \
                    'feasibleincrement':copy.deepcopy(feasible_increment), \
                    'L':copy.deepcopy(L_dicts[vid]), \
                    'F':copy.deepcopy(F_dicts[vid]), \
                    'potentials':copy.deepcopy(potentials_dict[vid]),}

                #
                
                if new_state[0]>self.length:
                    new_state[0] = new_state[0] - self.length
                    #print(new_state.shape)
                    self.vehs_dict[vid] = new_state
                    #
                    tmp = copy.deepcopy([self.vehs_at_lanes[-1]] + self.vehs_at_lanes[:-1])
                    self.vehs_at_lanes = tmp
                else:
                    #print(new_state.shape)
                    self.vehs_dict[vid] = new_state
            #
            #############################RECORD the state
            STATES[T] = copy.deepcopy(self.vehs_dict)
            
            #
            T = T + deltat_sec
            builtins.tmp = STATES
        
        return STATES


    
    def sim_insert_all_vehs_at_once(self, deltat_sec =.5, T_horizon_sec = 3600.0, desired_density = 100, inserted_initial_state = np.array([.0, .0, 1.75, 0, .000001, .00001]), safety_gap2downstream_when_insert = 10, safety_gap2upstream_when_insert = 10,  idm_paras = idm_paras, stochastic_proecess_name = 'OU', two_dim_paras = two_dim_paras, leader_state_infinity = np.array([1e10, .0, .0, 0, .0, .0]), intert_tolerance = 1e-1, deltax_2d_or_not = False, two_dim_paras_AV = two_dim_paras_AV ):
        """
        state variable is self.vehs_dict[vehicle_id] = [x, vx, y, vy, zlon, zlat]
        
        
        
        
        """
        #======================Insert vehicles. 
        #   determine the locs of the vehicles.
        vehs_number = int(max(2, min(desired_density/1000.0*(self.length), (self.length)/1000.0*135)))
        space = self.length/vehs_number
        equilibrium_v = TwoDimMicroModel.IDM_equilibrium_v_from_deltax(deltax = space)
        #
        locs_inserted = [intert_tolerance]
        for i in range(vehs_number):
            tmp = locs_inserted[-1] + space
            if tmp<=self.length:
                locs_inserted.append(tmp)
            else:
                break
        #   Insert vehicles
        for i,loc in enumerate(locs_inserted):
            state = np.array([loc, equilibrium_v, self.lw/2.0, 1e-5, .0000001, .0000001])#inserted_initial_state
            #state[0] = loc
            #state[2] = self.lw/2.0
            #np.array([loc, .0, self.lw/2.0, .0, .0, .0])
            self.vehs_at_lanes.append(i)
            #self.vehs_dict[vehicle_id] = [x, vx, y, vy, zlon, zlat]
            self.vehs_dict[i] = state
            
        #==============================
        #
        T = 0
        STATES = {}
        while T<T_horizon_sec:
            self.snapshots[T] = {}
            #=======================================================
            #calcualte F and L. keys are the vehicle ids. 
            #   F_dicts[vid] is a 1d array. 
            #   L_dicts[vid] is a N*2 array. 2 means lon and lat noise. 
            F_dicts = {}
            L_dicts = {}
            leader_state_dict = {}
            potentials_dict = {}
            for i,vid in enumerate(self.vehs_at_lanes):
                # ----------------------------
                ego_state = self.vehs_dict[vid]
                #
                #------------------------------------------
                #find the leader 
                if len(self.vehs_at_lanes)==1:
                    leader_state = copy.deepcopy(ego_state)
                    leader_state[0] = ego_state[0]+1e10
                else:
                    if i==len(self.vehs_at_lanes)-1:
                        #
                        leader_id = self.vehs_at_lanes[0]
                        leader_state = copy.deepcopy(self.vehs_dict[leader_id])
                        leader_state[0] = leader_state[0]+ self.length
                        
                    else:
                        leader_id = self.vehs_at_lanes[i+1]
                        leader_state = self.vehs_dict[leader_id]
                    #------------------search leader at ego lane. 
                leader_state_dict[vid] = copy.deepcopy(leader_state)
                #
                #-----------------
                #--------------calculate the F and L
                #   F_dicts[vid] is a 1d array. 
                F_dicts[vid],potentials_dict[vid] = TwoDimMicroModel.F_SingleLane(ego_state  = ego_state, \
                    ego_lane_lw = self.lw, \
                    ego_lane_middle_line_coor = self.lw/2.0, \
                    ego_lane_marks_coor = (0, self.lw), \
                    road_bounds = (0, self.lw), \
                    lw_boundary_lanes = (self.lw, self.lw), \
                    leader_state = leader_state, \
                    two_dim_paras = two_dim_paras, \
                    stochastic_proecess_name = stochastic_proecess_name, \
                    deltax_2d_or_not = deltax_2d_or_not)
                #
                L_dicts[vid] = TwoDimMicroModel.L(state  = ego_state, two_dim_paras = two_dim_paras, stochastic_proecess_name = stochastic_proecess_name)

                
            ################################UPDATE
            for vid in self.vehs_dict.keys():
                brownian = np.random.normal(loc = np.zeros((2,)), scale = deltat_sec)
                
                #
                #print(self.vehs_dict[vid], vid in F_dicts, vid in L_dicts)
                #
                #new_state = self.vehs_dict[vid] + F_dicts[vid] + np.matmul(L_dicts[vid], brownian/deltat_sec)
                new_state,feasible_increment = self.TrimUpdate(old_state = self.vehs_dict[vid], deltat_sec = deltat_sec, F = F_dicts[vid], L = L_dicts[vid], brownian = brownian, idm_paras = idm_paras)
                #
                #print(F_dicts[vid].shape, np.matmul(L_dicts[vid], brownian).shape)
                #new_state = self.vehs_dict[vid] + F_dicts[vid]*deltat_sec + np.matmul(L_dicts[vid], brownian)
                #---------------------UPDATE systen variables. 
                #SNAPSHOT
                #
                self.snapshots[T]['vehs_at_lanes'] = copy.deepcopy(self.vehs_at_lanes)
                self.snapshots[T][vid] = {'S':copy.deepcopy(self.vehs_dict[vid]), \
                    'feasibleincrement':copy.deepcopy(feasible_increment), \
                    'L':copy.deepcopy(L_dicts[vid]), \
                    'F':copy.deepcopy(F_dicts[vid]), \
                    'potentials':copy.deepcopy(potentials_dict[vid]),}

                #
                
                if new_state[0]>self.length:
                    new_state[0] = new_state[0] - self.length
                    #print(new_state.shape)
                    self.vehs_dict[vid] = new_state
                    #
                    tmp = copy.deepcopy([self.vehs_at_lanes[-1]] + self.vehs_at_lanes[:-1])
                    self.vehs_at_lanes = tmp
                else:
                    #print(new_state.shape)
                    self.vehs_dict[vid] = new_state
            #
            #############################RECORD the state
            STATES[T] = copy.deepcopy(self.vehs_dict)
            
            #
            T = T + deltat_sec
            builtins.tmp = STATES
        
        return STATES









    def sim(self, deltat_sec =.5, T_horizon_sec = 3600.0, desired_density = 100, inserted_initial_state = np.array([.0, .0, .0, 0, .000001, .00001]), safety_gap2downstream_when_insert = 10, safety_gap2upstream_when_insert = 10,  idm_paras = idm_paras, stochastic_proecess_name = 'converted', two_dim_paras = two_dim_paras, leader_state_infinity = np.array([1e10, .0, .0, 0, .0, .0]), intert_tolerance = 1e-1, deltax_2d_or_not = False ):
        """
        
        """
        #STATES[t] = {vid:veh_state}
        STATES = {}
        self.snapshots = {}
        #
        T = 0
        while T<T_horizon_sec:
            self.snapshots[T] = {}
            ####################################Insert vehices 
            #obtain the densityed. lanesdensities[vid] = float, the density at the road. 
            density = self.get_lanes_densities()
            #
            if density>=desired_density:continue
            #
            if density>0:
                #
                vid_downstream =  self.vehs_at_lanes[0]
                vid_upstream = self.vehs_at_lanes[-1]
                if not (self.vehs_dict[vid_downstream][0]<=safety_gap2downstream_when_insert or self.length-self.vehs_dict[vid_upstream][0]<safety_gap2upstream_when_insert):
                    #INSERT VEHICLE.
                    vid_new = len(self.vehs_dict)#uuid.uuid1()
                    inserted_initial_state0 =  inserted_initial_state
                    inserted_initial_state0[0] = .0#np.random.uniform(0, safety_gap2downstream_when_insert)
                    inserted_initial_state0[2] = self.lw/2.0
                    #
                    self.vehs_dict[vid_new] = copy.deepcopy(inserted_initial_state0)
                    self.vehs_at_lanes.insert(0, vid_new)
                #
            else:
                #INSERT VEHICLE.
                vid_new = len(self.vehs_dict)#uuid.uuid1()
                inserted_initial_state0 =  inserted_initial_state
                inserted_initial_state0[0] = 0.0#np.random.uniform(0, safety_gap2downstream_when_insert)
                inserted_initial_state0[2] = self.lw/2.0
                #
                self.vehs_dict[vid_new] = copy.deepcopy(inserted_initial_state0)
                self.vehs_at_lanes.insert(0, vid_new)
            #
            #=======================================================
            #calcualte F and L. keys are the vehicle ids. 
            #   F_dicts[vid] is a 1d array. 
            #   L_dicts[vid] is a N*2 array. 2 means lon and lat noise. 
            F_dicts = {}
            L_dicts = {}
            leader_state_dict = {}
            potentials_dict = {}
            for i,vid in enumerate(self.vehs_at_lanes):
                # ----------------------------
                ego_state = self.vehs_dict[vid]
                #
                #------------------------------------------
                #find the leader 
                if len(self.vehs_at_lanes)==1:
                    leader_state = copy.deepcopy(ego_state)
                    leader_state[0] = ego_state[0]+1e10
                else:
                    if i==len(self.vehs_at_lanes)-1:
                        #
                        leader_id = self.vehs_at_lanes[0]
                        leader_state = copy.deepcopy(self.vehs_dict[leader_id])
                        leader_state[0] = leader_state[0]+ self.length
                        
                    else:
                        leader_id = self.vehs_at_lanes[i+1]
                        leader_state = self.vehs_dict[leader_id]
                    #------------------search leader at ego lane. 
                leader_state_dict[vid] = copy.deepcopy(leader_state)
                #
                #-----------------
                #--------------calculate the F and L
                #   F_dicts[vid] is a 1d array. 
                F_dicts[vid],potentials_dict[vid] = TwoDimMicroModel.F_SingleLane(ego_state  = ego_state, \
                    ego_lane_lw = self.lw, \
                    ego_lane_middle_line_coor = self.lw/2.0, \
                    ego_lane_marks_coor = (0, self.lw), \
                    road_bounds = (0, self.lw), \
                    lw_boundary_lanes = (self.lw, self.lw), \
                    leader_state = leader_state, \
                    two_dim_paras = two_dim_paras, \
                    stochastic_proecess_name = stochastic_proecess_name, deltax_2d_or_not = deltax_2d_or_not)
                L_dicts[vid] = TwoDimMicroModel.L(state  = ego_state, two_dim_paras = two_dim_paras, stochastic_proecess_name = stochastic_proecess_name)

                
            ################################UPDATE
            for vid in self.vehs_dict.keys():
                brownian = np.random.normal(loc = np.zeros((2,)), scale = deltat_sec)
                
                #
                #print(self.vehs_dict[vid], vid in F_dicts, vid in L_dicts)
                #
                #new_state = F_dicts[vid] + np.matmul(L_dicts[vid], brownian/deltat_sec)
                new_state,feasible_increment = self.TrimUpdate(old_state = self.vehs_dict[vid], deltat_sec = deltat_sec, F = F_dicts[vid], L = L_dicts[vid], brownian = brownian, idm_paras = idm_paras)
                #
                #print(F_dicts[vid].shape, np.matmul(L_dicts[vid], brownian).shape)
                #new_state = self.vehs_dict[vid] + F_dicts[vid]*deltat_sec + np.matmul(L_dicts[vid], brownian)
                #---------------------UPDATE systen variables. 
                #SNAPSHOT
                
                """
                
                self.snapshots[T][vid] = {'S':copy.deepcopy(self.vehs_dict[vid]), \
                    'feasibleincrement':copy.deepcopy(feasible_increment), \
                    'L':copy.deepcopy(L_dicts[vid]), \
                    'F':copy.deepcopy(F_dicts[vid]), \
                    'potentials':copy.deepcopy(potentials_dict[vid]), }
                """

                #
                
                if new_state[0]>self.length:
                    new_state[0] = new_state[0] - self.length
                    #print(new_state.shape)
                    self.vehs_dict[vid] = new_state
                    #
                    tmp = copy.deepcopy([self.vehs_at_lanes[-1]] + self.vehs_at_lanes[:-1])
                    self.vehs_at_lanes = tmp
                else:
                    #print(new_state.shape)
                    self.vehs_dict[vid] = new_state
            #
            #############################RECORD the state
            STATES[T] = copy.deepcopy(self.vehs_dict)
            
            #
            T = T + deltat_sec
            builtins.tmp = STATES
        
        return STATES



class MultiLaneSim():
    """
    Simulate multi lane dynamics using the model specified in class TwoDim. 
    
    The methods begins with "Period_***()" is for simulate the period condition. 
    
    
    
    """
    
    @classmethod
    def ExtractSnapshot2CSV(self, snapshots):
        """
        exteact the snapshot data to cav. 
        """
        
        
        
        pass
    
    @classmethod
    def LateralDistribution_multilane(self, snapshots, length, selected_marginal_xs, bins = 10, tolerance_x_longitudinaldistance = 1, ax =  False, plott = False, figsize = (5,5)):
        """
        
        lateraldistribution,stds = 
        
        -------------------------------------------
        
        @input: tolerance_x_longitudinaldistance
        
            if the trajectory is away from the sliced x, then the data is discarded. 
        
        @input: snapshots
        
            a dict. 
            
                    self.snapshots[T]['vehs_at_lanes'] = copy.deepcopy(self.vehs_at_lanes)
                    self.snapshots[T][vid] = {'S':copy.deepcopy(self.vehs_dict[vid]), \
                        #'feasibleincrement':copy.deepcopy(feasible_increment), \
                        'L':copy.deepcopy(L_dicts[vid]), \
                        'F':copy.deepcopy(F_dicts[vid]), \
                        'vehs_info_within_area_left':copy.deepcopy(vehs_info_within_area_left_dict[vid]), \
                        'vehs_info_within_area_right':copy.deepcopy(vehs_info_within_area_right_dict[vid]), \
                        'potentials':copy.deepcopy(potentials_dict[vid]), }
        
        @input: selected_marginal_xs
        
            a list or 1d array that descirbe the 
        
        @OUTPUT: lateraldistribution
        
            lateraldistribution[lanes_ids][selected_x] = (hs, es)
        
        
        
        
            sim_res = twodim.LateralWanderingSingleLane.sim(tspan = tspan, two_dim_paras = two_dim_paras)
        
            sim_res[idx] shape is (len(ts), *3). '*3' because for each lane there are three states: y,u,z. 
        
        
        """
        #lateraldistribution[lanes_ids][selected_x] = (hs, es), hs and es are the same length. 
        lateraldistribution = {}
        #stds[lanes_ids][selected_x] = (hs, es), hs and es are the same length. 
        stds = {}
        #
        if plott:
            if isinstance(ax, bool):
                fig,ax = plt.subplots(figsize = figsize,)
                ax.set_xlabel('Lateral location (m)');ax.set_ylabel('Distribution');#ax.set_zlabel('speed');
                #fig,axs = plt.subplots(figsize = figsize, nrows = 2, ncols = 1)
                #ax = host_subplot(111)
                #par = ax.twinx()
        

        TS = np.array(sorted(snapshots.keys()))
        #for laneidx,laneid in enumerate(lanes_ids):
        #for laneidx in range(lanes_number):
        #ax = axs[laneidx]
        #ax = fig.add_subplot(lanes_number, 1, laneidx, projection='3d')
        #vids = snapshots[t0]['vehs_at_lanes'][laneid]#set(snapshots[t].keys())
        #
        lanes_ids = snapshots[TS[0]]['vehs_at_lanes'].keys()
        for lane_id in lanes_ids:
            lateraldistribution[lane_id] = {}
            stds[lane_id] = {}
            #
            #---------------get the vids set
            vids0 = []
            for t in TS:vids0.extend(snapshots[t]['vehs_at_lanes'][lane_id])
            vids = set(vids0)
            #----------------
            #
            ###########################################################################################
            ##############convert the snapshots to the TS_es, XS_es and YS_es###########
            TS_es = []
            XS_es = []
            YS_es = []
            VXs1  = []
            for vid in vids:
                #color = np.random.uniform(size = (3,))
                #
                xs0 = [snapshots[t][vid]['S'][0] for t in TS if vid in snapshots[t]]
                ys0 = [snapshots[t][vid]['S'][2] for t in TS if vid in snapshots[t]]
                #
                #vxs = [snapshots[t][vid]['S'][1] for t in TS if vid in snapshots[t]]
                #vxs1 = list(np.array(vxs)/vmax)

                #SEE https://stackoverflow.com/questions/64267329/how-to-plot-a-gradient-color-line
                #cut the trajectories into multi segments, becaus ethe period condition. 
                idxs_segments = TwoDimMicroModel.TransformPeriodic_ys_2MultiSegment_return_idxs_segments(ys = xs0, length = length)
                #ts_es,xs_es = TwoDimMicroModel.TransformPeriodic_ys_2MultiSegment(ys = xs0, length = length, ts = TS)
                #
                for segment in idxs_segments:
                    TS_es.append(np.array(TS)[segment])
                    #
                    XS_es.append(np.array(xs0)[segment])
                    YS_es.append(np.array(ys0)[segment])
                    #
                    #VXs1.append(np.array(vxs1)[segment])
            #####################################convert the snapshots to the TS_es, XS_es and YS_es###########
            ####################################################################################################
            for x in selected_marginal_xs:
                data = []
                for xs,ys in zip(XS_es, YS_es):
                    #
                    tmp = abs(xs-x)
                    #print(typ)
                    #print(x, tmp.shape, tolerance_x_longitudinaldistance)
                    if min(tmp)>tolerance_x_longitudinaldistance:continue
                    #
                    indexes = np.array(range(len(xs)))
                    idx_most_near = indexes[tmp==min(tmp)][0]
                    #
                    data.append(ys[idx_most_near])
                #
                hist0,edges = np.histogram(data, bins = bins)
                #print(sum(hist0), edges[-1] - edges[-2])
                hist = hist0/sum(hist0)/(edges[-1] - edges[-2])
                #
                stds[lane_id][x] = np.std(data)
                lateraldistribution[lane_id][x] = (hist, edges[1:])
                #if not instance(ax,bool)
                if plott:
                    ax.plot(edges[1:], hist)
        

        #
        return lateraldistribution,stds,ax

    
    @classmethod
    def get_downstream_vehicles(self, ego_state, ):
        """
        
        """
        
        
        
        pass
    
    
    @classmethod
    def TrimUpdate(self, old_state, deltat_sec, F, L, brownian, idm_paras = idm_paras):
        """
        The update of the state is calculated as:
        
            new_state = old_state + F*deltat_sec + np.matmul(L, brownian)
            
        Or equilivalently:
        
            new_state = old_state + (F + np.matmul(L, brownian/deltat_sec))*deltat_sec
        
        The above is for the sysmtem dynamics dS = F(S)dt + L(S) dW. 
        
        
        However, the acceleration may exceed the maximum acceleration. 
        
        -----------------------------------
        @input: deltat_sec
        
            a float. 
        
        @input: F L
        
            both are array. 
            
            F.shape is (6,)
            
            L.shape is (6, 2)
            
            brownian shape is (2,)
            
            
        
        """
        
        #increment shape is (6,)
        increment = F + np.matmul(L, brownian/deltat_sec)
        
        #
        #increment[0] = min(idm_paras['idm_vf'], max(0, increment[0]))
        increment[0] = min(idm_paras['idm_vf'], max(0, increment[0]))
        #max(0, increment[0])
        
        #
        increment[1] = min(idm_paras['a_MAX'], max(-idm_paras['a_MAX'], increment[1]))
        
        feasible_increment = increment*deltat_sec
        
        return old_state + increment*deltat_sec,feasible_increment
        #return old_state + increment*deltat_sec,feasible_increment
    
    
    @classmethod
    def TrimF(self, F):
        """
        as the state variables is ego_state = [x, vx, y ,vy, zlon, zlat], sometimes the 
        
        """
        
        
        
        pass
    
    
    @classmethod
    def ellipse_x(self, ego_state, a_x_MAX = 3.5, ellipse_x_min = 30, ellipse_x_max = 100):
        """
        ego_state = [x, vx, y ,vy, zlon, zlat]
        
        vx and vy unit are m/s
        
        """
        ego_speed = ego_state[1]
        
        return min(max(ego_speed**2/(2.0*a_x_MAX), ellipse_x_min), ellipse_x_max)
        
    
    def PeriodSim(self, road_geo, T_horizon_sec = 3600):
        """
        Simulate the period condition. 
        
        ----------------------------------------------
        
        
        @input: T_horizon_sec
        
            the simulation horizon .unit is second. 
        
        @input: road_geo
        
            the geometry of the road. 
            
            It is a dict. keys are from 0, 1, 2,.... Each index represents one lane. 
            
            
            road_geo[idx_lane] is a dict. 'lw' is a float, 'left' is a idx_lane, 'right' is a idx_lane. 
            
        
        -----------------------------------------------
        
        @OUTPUT: 
            
        
        ----------------------------------------------
        @Steps:
            - Determine whether insert vehicle and where the vehicle is inserted. 
            - For each vehicle, find its downstream vehicles. 
            - Update the vehicle state. 
        
        
        """
        
        
        
        pass
    
    
    
    def PeriodDownstreamVehsEllipseFinder(self, state_veh, x_ellise, y_ellipse):
        """
        Find the downstream vehicles that are within the ellipse area. 
        
        --------------------------------------------
        @input: x_ellise, y_ellipse
        
            both are floats. 
            
            They are the major and minor axis of the ellipse area. 
            
        @input: 
        
        """
        
        
        pass

    
    
    
    pass




class MultiLaneHomogeneousSim(MultiLaneSim):
    """
    Simulation of the homogeneous lane. 
    
    
    
    
    """

    @classmethod
    def Get_Q_K(self, snapshots, Deltat_FD_sec = 30, road_length_meter = 1000.0, start_omit_sec = 50, rolling_step_sec = 10):
        """
        
        Difference:
        
            self.Get_Q_K_lane_specific(), returns Q[lane_id] and K[lane_id] = [k0,k1...]
            self.Get_Q_K(), return Q = [q0, q1, q2...]
        
        calculate the Qand K
        
            = 
        
        @input: start_omit_sec
        
            omit the onset moments. 
        
        @input: snapshots
        
            snapshots[moment].kesys() are:
            
                self.snapshots[T]['vehs_at_lanes'] = copy.deepcopy(self.vehs_at_lanes)
                self.snapshots[T][vid] = {'S':copy.deepcopy(self.vehs_dict[vid]), \
                    #'feasibleincrement':copy.deepcopy(feasible_increment), \
                    'L':copy.deepcopy(L_dicts[vid]), \
                    'F':copy.deepcopy(F_dicts[vid]), \
                    'vehs_info_within_area_left':copy.deepcopy(vehs_info_within_area_left_dict[vid]), \
                    'vehs_info_within_area_right':copy.deepcopy(vehs_info_within_area_right_dict[vid]), \
                    'potentials':copy.deepcopy(potentials_dict[vid]), }
        
        @input: Deltat_FD_sec
        
            the time step that calculate the FD parameters. 
        
        @OUTPUT: Q and K
        
            both are dicts. 
            
            Q[laneid] = [q1, q2, q3, q4...]
            K[laneid] = [k1, k2, k3, k4...]
            
            Q unit is veh/h
            K unit is veh/km
        
        
        
        
        -----------------------------
        Q = dA/|A|, d is the distance travelled by all vehicles.
        K = t(A)/|A|, t is the total time travelled. 
        """
        #Q[laneid] = [q1, q2, q3, q4...]
        #K[laneid] = [k1, k2, k3, k4...]
        t = sorted(snapshots.keys())[0]
        lanes_number = len(snapshots[t]['vehs_at_lanes'])
        Q = []
        K = []
        
        #unit is km.h
        area = (road_length_meter/1000.0)*(Deltat_FD_sec/3600.0)
        #
        Ts = np.array(sorted(snapshots.keys()))
        #
        start = 0.0
        end = start + Deltat_FD_sec
        #print(end, max(Ts))
        while end<=max(Ts):
            if start<=start_omit_sec:
                start = start + rolling_step_sec
                end = start + Deltat_FD_sec
                continue
            #print(end, max(Ts))
            #unit is sec and meter.
            totaltimetravelled_sec = 0
            totaldistancetravelled_meter = 0
            #
            interval_ts = Ts[(Ts>start) & (Ts<=end)]
            for t0,t1 in zip(interplot_speed_colorval_ts[:-1], interval_ts[1:]):
                #
                for lane_id in snapshots[t]['vehs_at_lanes'].keys():
                    #
                    for vid in snapshots[t]['vehs_at_lanes'][lane_id]:
                        #time travelled
                        totaltimetravelled_sec = totaltimetravelled_sec + t1 - t0
                        #distancetravelled
                        if snapshots[t1][vid]['S'][0]<=snapshots[t0][vid]['S'][0]:
                            distance_travelled_vid = snapshots[t1][vid]['S'][0] + road_length_meter - snapshots[t0][vid]['S'][0]
                        else:
                            distance_travelled_vid = snapshots[t1][vid]['S'][0]  - snapshots[t0][vid]['S'][0]
                        #
                        totaldistancetravelled_meter = totaldistancetravelled_meter  + distance_travelled_vid
            #
            Q_interval = totaldistancetravelled_meter/1000.0/area/lanes_number
            K_interval = totaltimetravelled_sec/3600.0/area/lanes_number
            #
            Q.append(Q_interval)
            K.append(K_interval)
            #
            start = start + rolling_step_sec
            end = start + Deltat_FD_sec
        
        return Q,K


    @classmethod
    def Get_Q_K_lane_specific(self, snapshots, Deltat_FD_sec = 30, road_length_meter = 1000.0):
        """
        calculate the Qand K
        
            = 
        
        @input: snapshots
        
            snapshots[moment].kesys() are:
            
                self.snapshots[T]['vehs_at_lanes'] = copy.deepcopy(self.vehs_at_lanes)
                self.snapshots[T][vid] = {'S':copy.deepcopy(self.vehs_dict[vid]), \
                    #'feasibleincrement':copy.deepcopy(feasible_increment), \
                    'L':copy.deepcopy(L_dicts[vid]), \
                    'F':copy.deepcopy(F_dicts[vid]), \
                    'vehs_info_within_area_left':copy.deepcopy(vehs_info_within_area_left_dict[vid]), \
                    'vehs_info_within_area_right':copy.deepcopy(vehs_info_within_area_right_dict[vid]), \
                    'potentials':copy.deepcopy(potentials_dict[vid]), }
        
        @input: Deltat_FD_sec
        
            the time step that calculate the FD parameters. 
        
        @OUTPUT: Q and K
        
            both are dicts. 
            
            Q[laneid] = [q1, q2, q3, q4...]
            K[laneid] = [k1, k2, k3, k4...]
            
            Q unit is veh/h
            K unit is veh/km
        
        
        
        
        -----------------------------
        Q = dA/|A|, d is the distance travelled by all vehicles.
        K = t(A)/|A|, t is the total time travelled. 
        """
        #Q[laneid] = [q1, q2, q3, q4...]
        #K[laneid] = [k1, k2, k3, k4...]
        t = sorted(snapshots.keys())[0]
        Q = {lane_id:[] for lane_id in snapshots[t]['vehs_at_lanes'].keys()}
        K = {lane_id:[] for lane_id in snapshots[t]['vehs_at_lanes'].keys()}
        
        #unit is km.h
        area = (road_length_meter/1000.0)*(Deltat_FD_sec/3600.0)
        #
        Ts = np.array(sorted(snapshots.keys()))
        #
        start = 0.0
        end = start + Deltat_FD_sec
        while end<=max(Ts):
            #
            interval_ts = Ts[(Ts>start) & (Ts<=end)]
            for t0,t1 in zip(interval_ts[:-1], interval_ts[1:]):
                #
                #unit is sec and meter.
                totaltimetravelled_sec = 0
                totaldistancetravelled_meter = 0
                for lane_id in snapshots[t]['vehs_at_lanes'].keys():
                    #
                    for vid in snapshots[t]['vehs_at_lanes'][lane_id]:
                        #time travelled
                        totaltimetravelled_sec = totaltimetravelled_sec + t1 - t0
                        #distancetravelled
                        if snapshots[t1][vid]['S'][0]<=snapshots[t0][vid]['S'][0]:
                            distance_travelled_vid = snapshots[t1][vid]['S'][0] + road_length_meter - snapshots[t0][vid]['S'][0]
                        else:
                            distance_travelled_vid = snapshots[t1][vid]['S'][0]  - snapshots[t0][vid]['S'][0]
                        #
                        totaldistancetravelled_meter = totaldistancetravelled_meter  + distance_travelled_vid
                    #
                    Q_interval = totaldistancetravelled_meter/1000.0/area
                    K_interval = totaldistancetravelled_meter/3600.0/area
                    #
                    Q[lane_id].append(Q_interval)
                    K[lane_id].append(K_interval)
            start = end
            end = start + Deltat_FD_sec
        
        return Q,K
    

    @classmethod
    def plot_trajectories_2D_singlelane_scatter(self, snapshots, laneid = 0, ax = False, figsize = (5,3), alpha = .4,vmax = 200/3.6, timeintervalploted = (100, 200)):
        """
        plot the speed profile of 3D, i.e. (t, x, v)
        
        
        
        
        @input: 
        
                #SNAPSHOT
                self.snapshots[T]['vehs_at_lanes'] = copy.deepcopy(self.vehs_at_lanes)
                self.snapshots[T][vid] = {'S':copy.deepcopy(self.vehs_dict[vid]), \
                    #'feasibleincrement':copy.deepcopy(feasible_increment), \
                    'L':copy.deepcopy(L_dicts[vid]), \
                    'F':copy.deepcopy(F_dicts[vid]), \
                    'vehs_info_within_area_left':copy.deepcopy(vehs_info_within_area_left_dict[vid]), \
                    'vehs_info_within_area_right':copy.deepcopy(vehs_info_within_area_right_dict[vid]), \
                    'potentials':copy.deepcopy(potentials_dict[vid]), }
                #
        """
        
        #from mpl_toolkits.mplot3d.axes3d import get_test_data
        # This import registers the 3D projection, but is otherwise unused.
        #from mpl_toolkits.mplot3d import Axes3D  # noqa: F401 unused import
        
        t = sorted(snapshots.keys())[0]
        #lanes_ids = snapshots[t]['vehs_at_lanes'].keys()
        #lanes_number = len(snapshots[t]['vehs_at_lanes'])
        #==========================================
        if isinstance(ax, bool):
            #fig, ax = plt.subplots(figsize = figsize, ncols = 1, nrows = 1, projection='3d')
            fig, ax = plt.subplots(figsize = figsize)
            #ax = plt.figure(figsize = figsize).add_subplot(projection='3d')
            #ax.set_xlabel('t');ax.set_ylabel('x');ax.set_zlabel('speed'); 
            #ax.grid();
            #ax = host_subplot(111)
            #par = ax.twinx()
            #fig,ax = plt.subplots(figsize = figsize, nrows = 1, ncols = 1)
        #
        #--------------------------------------
        #fig = plt.figure(figsize=plt.figaspect(0.5))
        #fig = plt.figure(figsize=figsize)
        Ts = np.array(sorted(snapshots.keys()))
        #for laneidx,laneid in enumerate(lanes_ids):
        #for laneidx in range(lanes_number):
        #ax = axs[laneidx]
        #ax = fig.add_subplot(lanes_number, 1, laneidx, projection='3d')
        #
        for t in Ts:
            if t<min(timeintervalploted):continue
            if t>=max(timeintervalploted):break
            #SNAPSHOTS[t].keys are the vids
            vids = snapshots[t]['vehs_at_lanes'][laneid]#set(snapshots[t].keys())
            #print(laneidx, vids)
            xs = [snapshots[t][vid]['S'][0] for vid in vids]
            ys = [snapshots[t][vid]['S'][2] for vid in vids]
            
            #make color
            vxs = [snapshots[t][vid]['S'][1] for vid in vids]
            vxs1 = list(np.array(vxs)/vmax)
            vxs2 = [np.array([v, v, 0]) for v in vxs1]
            
            #print(max(vxs1))
            #
            #ts = np.array([t]*len(xs))
            
            ax.scatter(xs, ys)#,  c = np.tan(vxs1))
            #ax.scatter(ts, xs, vxs,  c = np.tan(vxs1))
            
        ax.set_xlabel('x (m)');ax.set_ylabel('y (m)');#ax.set_zlabel('speed');
        
        return ax

    @classmethod
    def plot_twodim_trajectories_givensnapshots_singlelane(self, snapshots, length = 500, laneid = 0, ax = False, figsize = (5,3), alpha = .4, vmax = 200/3.6, timeintervalploted = (100, 200), cmap = 'Blues', N_plotted = 20):
        """
        plot the speed profile of 3D, i.e. (t, x, v)
        
        {vid:np.array([x,vx, y, vy, zlon, zlat])}
        
        
        @input: cmap
        
        ValueError: 'OrangeBlue' is not a valid value for name; supported values are 'Accent', 'Accent_r', 'Blues', 'Blues_r', 'BrBG', 'BrBG_r', 'BuGn', 'BuGn_r', 'BuPu', 'BuPu_r', 'CMRmap', 'CMRmap_r', 'Dark2', 'Dark2_r', 'GnBu', 'GnBu_r', 'Greens', 'Greens_r', 'Greys', 'Greys_r', 'OrRd', 'OrRd_r', 'Oranges', 'Oranges_r', 'PRGn', 'PRGn_r', 'Paired', 'Paired_r', 'Pastel1', 'Pastel1_r', 'Pastel2', 'Pastel2_r', 'PiYG', 'PiYG_r', 'PuBu', 'PuBuGn', 'PuBuGn_r', 'PuBu_r', 'PuOr', 'PuOr_r', 'PuRd', 'PuRd_r', 'Purples', 'Purples_r', 'RdBu', 'RdBu_r', 'RdGy', 'RdGy_r', 'RdPu', 'RdPu_r', 'RdYlBu', 'RdYlBu_r', 'RdYlGn', 'RdYlGn_r', 'Reds', 'Reds_r', 'Set1', 'Set1_r', 'Set2', 'Set2_r', 'Set3', 'Set3_r', 'Spectral', 'Spectral_r', 'Wistia', 'Wistia_r', 'YlGn', 'YlGnBu', 'YlGnBu_r', 'YlGn_r', 'YlOrBr', 'YlOrBr_r', 'YlOrRd', 'YlOrRd_r', 'afmhot', 'afmhot_r', 'autumn', 'autumn_r', 'binary', 'binary_r', 'bone', 'bone_r', 'brg', 'brg_r', 'bwr', 'bwr_r', 'cividis', 'cividis_r', 'cool', 'cool_r', 'coolwarm', 'coolwarm_r', 'copper', 'copper_r', 'crest', 'crest_r', 'cubehelix', 'cubehelix_r', 'flag', 'flag_r', 'flare', 'flare_r', 'gist_earth', 'gist_earth_r', 'gist_gray', 'gist_gray_r', 'gist_heat', 'gist_heat_r', 'gist_ncar', 'gist_ncar_r', 'gist_rainbow', 'gist_rainbow_r', 'gist_stern', 'gist_stern_r', 'gist_yarg', 'gist_yarg_r', 'gnuplot', 'gnuplot2', 'gnuplot2_r', 'gnuplot_r', 'gray', 'gray_r', 'hot', 'hot_r', 'hsv', 'hsv_r', 'icefire', 'icefire_r', 'inferno', 'inferno_r', 'jet', 'jet_r', 'magma', 'magma_r', 'mako', 'mako_r', 'nipy_spectral', 'nipy_spectral_r', 'ocean', 'ocean_r', 'pink', 'pink_r', 'plasma', 'plasma_r', 'prism', 'prism_r', 'rainbow', 'rainbow_r', 'rocket', 'rocket_r', 'seismic', 'seismic_r', 'spring', 'spring_r', 'summer', 'summer_r', 'tab10', 'tab10_r', 'tab20', 'tab20_r', 'tab20b', 'tab20b_r', 'tab20c', 'tab20c_r', 'terrain', 'terrain_r', 'turbo', 'turbo_r', 'twilight', 'twilight_r', 'twilight_shifted', 'twilight_shifted_r', 'viridis', 'viridis_r', 'vlag', 'vlag_r', 'winter', 'winter_r'
        
        @input: 
        
                #SNAPSHOT
                self.snapshots[T]['vehs_at_lanes'] = copy.deepcopy(self.vehs_at_lanes)
                self.snapshots[T][vid] = {'S':copy.deepcopy(self.vehs_dict[vid]), \
                    #'feasibleincrement':copy.deepcopy(feasible_increment), \
                    'L':copy.deepcopy(L_dicts[vid]), \
                    'F':copy.deepcopy(F_dicts[vid]), \
                    'vehs_info_within_area_left':copy.deepcopy(vehs_info_within_area_left_dict[vid]), \
                    'vehs_info_within_area_right':copy.deepcopy(vehs_info_within_area_right_dict[vid]), \
                    'potentials':copy.deepcopy(potentials_dict[vid]), }
                
        """
        from matplotlib.collections import LineCollection
        #from mpl_toolkits.mplot3d.axes3d import get_test_data
        # This import registers the 3D projection, but is otherwise unused.
        #from mpl_toolkits.mplot3d import Axes3D  # noqa: F401 unused import
        
        t0 = sorted(snapshots.keys())[0]
        #lanes_ids = snapshots[t]['vehs_at_lanes'].keys()
        #lanes_number = len(snapshots[t]['vehs_at_lanes'])
        #==========================================
        if isinstance(ax, bool):
            #fig, ax = plt.subplots(figsize = figsize, ncols = 1, nrows = 1, projection='3d')
            fig, ax = plt.subplots(figsize = figsize)
            ax.set_xlabel('x');ax.set_ylabel('y'); 
            #ax = plt.figure(figsize = figsize).add_subplot(projection='3d')
            #ax.set_xlabel('t');ax.set_ylabel('x');ax.set_zlabel('speed'); 
            #ax.grid();
            #ax = host_subplot(111)
            #par = ax.twinx()
            #fig,ax = plt.subplots(figsize = figsize, nrows = 1, ncols = 1)
        #
        #--------------------------------------
        #fig = plt.figure(figsize=plt.figaspect(0.5))
        #fig = plt.figure(figsize=figsize)
        TS = np.array(sorted(snapshots.keys()))
        #for laneidx,laneid in enumerate(lanes_ids):
        #for laneidx in range(lanes_number):
        #ax = axs[laneidx]
        #ax = fig.add_subplot(lanes_number, 1, laneidx, projection='3d')
        #
        #vids = snapshots[t0]['vehs_at_lanes'][laneid]#set(snapshots[t].keys())
        vids0 = []
        for t in TS:vids0.extend(snapshots[t]['vehs_at_lanes'][laneid])
        vids = set(vids0)
        #
        #
        TS_es = []
        XS_es = []
        YS_es = []
        VXs1  = []
        for vid in vids:
            color = np.random.uniform(size = (3,))
            #
            xs0 = [snapshots[t][vid]['S'][0] for t in TS if vid in snapshots[t]]
            ys0 = [snapshots[t][vid]['S'][2] for t in TS if vid in snapshots[t]]
            #
            vxs = [snapshots[t][vid]['S'][1] for t in TS if vid in snapshots[t]]
            vxs1 = list(np.array(vxs)/vmax)

            #SEE https://stackoverflow.com/questions/64267329/how-to-plot-a-gradient-color-line
            #cut the trajectories into multi segments, becaus ethe period condition. 
            idxs_segments = TwoDimMicroModel.TransformPeriodic_ys_2MultiSegment_return_idxs_segments(ys = xs0, length = length)
            #ts_es,xs_es = TwoDimMicroModel.TransformPeriodic_ys_2MultiSegment(ys = xs0, length = length, ts = TS)
            #
            for segment in idxs_segments:
                TS_es.append(np.array(TS)[segment])
                #
                XS_es.append(np.array(xs0)[segment])
                YS_es.append(np.array(ys0)[segment])
                #
                VXs1.append(np.array(vxs1)[segment])
        ##################
        N_plotted = min(N_plotted, len(TS_es))
        selected_idxes = np.random.choice(list(range(len(TS_es))), N_plotted)
        #for ts,xs,ys,vs in zip(TS_es,XS_es, YS_es, VXs1):
        for idx in selected_idxes:
            ts = TS_es[idx]
            xs = XS_es[idx]
            ys = YS_es[idx]
            vs = VXs1[idx]
            #
            points = np.array([xs,ys]).T.reshape(-1, 1, 2)
            segments = np.concatenate([points[:-1], points[1:]], axis=1)
            #lc = LineCollection(segments, cmap='viridis', alpha = alpha)
            lc = LineCollection(segments, cmap = cmap, alpha = alpha)
            lc.set_array(vs)
            ax.add_collection(lc)
            
            """
            #cut the trajectories into multi segments, becaus ethe period condition. 
            ts_es,xs_es = TwoDimMicroModel.TransformPeriodic_ys_2MultiSegment(ys = xs0, length = length, ts = TS)
            for ts,xs in zip(ts_es,xs_es):
                #ax.plot(ts,xs, color = color)
                ax.plot(ts,xs, cmap=plt.get_cmap('jet'))
            """
        
        return ax
    





















        for t in sorted(STATES.keys()):
            
            
            xs = [STATES[t][vid][0] for vid in STATES[t].keys()]
            ys = [STATES[t][vid][2] for vid in STATES[t].keys()]
            
            ax.plot(xs, ys, '.')
            #ax = self.plot_path(path = sim_res, ax = ax, figsize = figsize, alpha = alpha,)
        
        #
        ax.set_xlabel('x ( m )');ax.set_ylabel('y ( m )'); ax.grid()
        
            
        plt.tight_layout()
        
        return ax
        

    @classmethod
    def plot_trajectory_profile_singlelane(self, snapshots, length = 500, laneid = 0, ax = False, figsize = (5,3), alpha = .4, vmax = 200/3.6, timeintervalploted = (100, 200), cmap = 'Blues'):
        """
        plot the speed profile of 3D, i.e. (t, x, v)
        
        @input: cmap
        
        ValueError: 'OrangeBlue' is not a valid value for name; supported values are 'Accent', 'Accent_r', 'Blues', 'Blues_r', 'BrBG', 'BrBG_r', 'BuGn', 'BuGn_r', 'BuPu', 'BuPu_r', 'CMRmap', 'CMRmap_r', 'Dark2', 'Dark2_r', 'GnBu', 'GnBu_r', 'Greens', 'Greens_r', 'Greys', 'Greys_r', 'OrRd', 'OrRd_r', 'Oranges', 'Oranges_r', 'PRGn', 'PRGn_r', 'Paired', 'Paired_r', 'Pastel1', 'Pastel1_r', 'Pastel2', 'Pastel2_r', 'PiYG', 'PiYG_r', 'PuBu', 'PuBuGn', 'PuBuGn_r', 'PuBu_r', 'PuOr', 'PuOr_r', 'PuRd', 'PuRd_r', 'Purples', 'Purples_r', 'RdBu', 'RdBu_r', 'RdGy', 'RdGy_r', 'RdPu', 'RdPu_r', 'RdYlBu', 'RdYlBu_r', 'RdYlGn', 'RdYlGn_r', 'Reds', 'Reds_r', 'Set1', 'Set1_r', 'Set2', 'Set2_r', 'Set3', 'Set3_r', 'Spectral', 'Spectral_r', 'Wistia', 'Wistia_r', 'YlGn', 'YlGnBu', 'YlGnBu_r', 'YlGn_r', 'YlOrBr', 'YlOrBr_r', 'YlOrRd', 'YlOrRd_r', 'afmhot', 'afmhot_r', 'autumn', 'autumn_r', 'binary', 'binary_r', 'bone', 'bone_r', 'brg', 'brg_r', 'bwr', 'bwr_r', 'cividis', 'cividis_r', 'cool', 'cool_r', 'coolwarm', 'coolwarm_r', 'copper', 'copper_r', 'crest', 'crest_r', 'cubehelix', 'cubehelix_r', 'flag', 'flag_r', 'flare', 'flare_r', 'gist_earth', 'gist_earth_r', 'gist_gray', 'gist_gray_r', 'gist_heat', 'gist_heat_r', 'gist_ncar', 'gist_ncar_r', 'gist_rainbow', 'gist_rainbow_r', 'gist_stern', 'gist_stern_r', 'gist_yarg', 'gist_yarg_r', 'gnuplot', 'gnuplot2', 'gnuplot2_r', 'gnuplot_r', 'gray', 'gray_r', 'hot', 'hot_r', 'hsv', 'hsv_r', 'icefire', 'icefire_r', 'inferno', 'inferno_r', 'jet', 'jet_r', 'magma', 'magma_r', 'mako', 'mako_r', 'nipy_spectral', 'nipy_spectral_r', 'ocean', 'ocean_r', 'pink', 'pink_r', 'plasma', 'plasma_r', 'prism', 'prism_r', 'rainbow', 'rainbow_r', 'rocket', 'rocket_r', 'seismic', 'seismic_r', 'spring', 'spring_r', 'summer', 'summer_r', 'tab10', 'tab10_r', 'tab20', 'tab20_r', 'tab20b', 'tab20b_r', 'tab20c', 'tab20c_r', 'terrain', 'terrain_r', 'turbo', 'turbo_r', 'twilight', 'twilight_r', 'twilight_shifted', 'twilight_shifted_r', 'viridis', 'viridis_r', 'vlag', 'vlag_r', 'winter', 'winter_r'
        
        @input: 
        
                #SNAPSHOT
                self.snapshots[T]['vehs_at_lanes'] = copy.deepcopy(self.vehs_at_lanes)
                self.snapshots[T][vid] = {'S':copy.deepcopy(self.vehs_dict[vid]), \
                    #'feasibleincrement':copy.deepcopy(feasible_increment), \
                    'L':copy.deepcopy(L_dicts[vid]), \
                    'F':copy.deepcopy(F_dicts[vid]), \
                    'vehs_info_within_area_left':copy.deepcopy(vehs_info_within_area_left_dict[vid]), \
                    'vehs_info_within_area_right':copy.deepcopy(vehs_info_within_area_right_dict[vid]), \
                    'potentials':copy.deepcopy(potentials_dict[vid]), }
                #
        """
        from matplotlib.collections import LineCollection
        #from mpl_toolkits.mplot3d.axes3d import get_test_data
        # This import registers the 3D projection, but is otherwise unused.
        #from mpl_toolkits.mplot3d import Axes3D  # noqa: F401 unused import
        
        t0 = sorted(snapshots.keys())[0]
        #lanes_ids = snapshots[t]['vehs_at_lanes'].keys()
        #lanes_number = len(snapshots[t]['vehs_at_lanes'])
        #==========================================
        if isinstance(ax, bool):
            #fig, ax = plt.subplots(figsize = figsize, ncols = 1, nrows = 1, projection='3d')
            fig, ax = plt.subplots(figsize = figsize)
            #ax = plt.figure(figsize = figsize).add_subplot(projection='3d')
            #ax.set_xlabel('t');ax.set_ylabel('x');ax.set_zlabel('speed'); 
            #ax.grid();
            #ax = host_subplot(111)
            #par = ax.twinx()
            #fig,ax = plt.subplots(figsize = figsize, nrows = 1, ncols = 1)
        #
        #--------------------------------------
        #fig = plt.figure(figsize=plt.figaspect(0.5))
        #fig = plt.figure(figsize=figsize)
        TS = np.array(sorted(snapshots.keys()))
        #for laneidx,laneid in enumerate(lanes_ids):
        #for laneidx in range(lanes_number):
        #ax = axs[laneidx]
        #ax = fig.add_subplot(lanes_number, 1, laneidx, projection='3d')
        #
        #vids = snapshots[t0]['vehs_at_lanes'][laneid]#set(snapshots[t].keys())
        vids0 = []
        for t in TS:vids0.extend(snapshots[t]['vehs_at_lanes'][laneid])
        vids = set(vids0)
        #
        #
        TS_es = []
        XS_es = []
        VXs1  = []
        for vid in vids:
            color = np.random.uniform(size = (3,))
            #
            xs0 = [snapshots[t][vid]['S'][0] for t in TS if vid in snapshots[t]]
            #
            vxs = [snapshots[t][vid]['S'][1] for t in TS if vid in snapshots[t]]
            vxs1 = list(np.array(vxs)/vmax)

            #SEE https://stackoverflow.com/questions/64267329/how-to-plot-a-gradient-color-line
            #cut the trajectories into multi segments, becaus ethe period condition. 
            idxs_segments = TwoDimMicroModel.TransformPeriodic_ys_2MultiSegment_return_idxs_segments(ys = xs0, length = length)
            #ts_es,xs_es = TwoDimMicroModel.TransformPeriodic_ys_2MultiSegment(ys = xs0, length = length, ts = TS)
            #
            for segment in idxs_segments:
                TS_es.append(np.array(TS)[segment])
                XS_es.append(np.array(xs0)[segment])
                VXs1.append(np.array(vxs1)[segment])
        ##################
        for ts,xs,vs in zip(TS_es,XS_es, VXs1):
            points = np.array([ts, xs]).T.reshape(-1, 1, 2)
            segments = np.concatenate([points[:-1], points[1:]], axis=1)
            #lc = LineCollection(segments, cmap='viridis', alpha = alpha)
            lc = LineCollection(segments, cmap = cmap, alpha = alpha)
            lc.set_array(vs)
            ax.add_collection(lc)
            
            """
            #cut the trajectories into multi segments, becaus ethe period condition. 
            ts_es,xs_es = TwoDimMicroModel.TransformPeriodic_ys_2MultiSegment(ys = xs0, length = length, ts = TS)
            for ts,xs in zip(ts_es,xs_es):
                #ax.plot(ts,xs, color = color)
                ax.plot(ts,xs, cmap=plt.get_cmap('jet'))
            """
            #ax.plot(TS, xs0)
        #fig.colorbar(ax=ax)
        ax.set_xlabel('Time (sec)');ax.set_ylabel('Longitudinal coordinate (m)');#ax.set_zlabel('speed');
        
        return ax
    



    @classmethod
    def plot_speed_profile_singlelane_trajectories(self, snapshots, length = 500, laneid = 0, ax = False, figsize = (5,3), alpha = .4, vmax = 200/3.6, timeintervalploted = (100, 200), cmap = 'Blues'):
        """
        plot the speed profile of 3D, i.e. (t, x, v)
        
        @input: cmap
        
        ValueError: 'OrangeBlue' is not a valid value for name; supported values are 'Accent', 'Accent_r', 'Blues', 'Blues_r', 'BrBG', 'BrBG_r', 'BuGn', 'BuGn_r', 'BuPu', 'BuPu_r', 'CMRmap', 'CMRmap_r', 'Dark2', 'Dark2_r', 'GnBu', 'GnBu_r', 'Greens', 'Greens_r', 'Greys', 'Greys_r', 'OrRd', 'OrRd_r', 'Oranges', 'Oranges_r', 'PRGn', 'PRGn_r', 'Paired', 'Paired_r', 'Pastel1', 'Pastel1_r', 'Pastel2', 'Pastel2_r', 'PiYG', 'PiYG_r', 'PuBu', 'PuBuGn', 'PuBuGn_r', 'PuBu_r', 'PuOr', 'PuOr_r', 'PuRd', 'PuRd_r', 'Purples', 'Purples_r', 'RdBu', 'RdBu_r', 'RdGy', 'RdGy_r', 'RdPu', 'RdPu_r', 'RdYlBu', 'RdYlBu_r', 'RdYlGn', 'RdYlGn_r', 'Reds', 'Reds_r', 'Set1', 'Set1_r', 'Set2', 'Set2_r', 'Set3', 'Set3_r', 'Spectral', 'Spectral_r', 'Wistia', 'Wistia_r', 'YlGn', 'YlGnBu', 'YlGnBu_r', 'YlGn_r', 'YlOrBr', 'YlOrBr_r', 'YlOrRd', 'YlOrRd_r', 'afmhot', 'afmhot_r', 'autumn', 'autumn_r', 'binary', 'binary_r', 'bone', 'bone_r', 'brg', 'brg_r', 'bwr', 'bwr_r', 'cividis', 'cividis_r', 'cool', 'cool_r', 'coolwarm', 'coolwarm_r', 'copper', 'copper_r', 'crest', 'crest_r', 'cubehelix', 'cubehelix_r', 'flag', 'flag_r', 'flare', 'flare_r', 'gist_earth', 'gist_earth_r', 'gist_gray', 'gist_gray_r', 'gist_heat', 'gist_heat_r', 'gist_ncar', 'gist_ncar_r', 'gist_rainbow', 'gist_rainbow_r', 'gist_stern', 'gist_stern_r', 'gist_yarg', 'gist_yarg_r', 'gnuplot', 'gnuplot2', 'gnuplot2_r', 'gnuplot_r', 'gray', 'gray_r', 'hot', 'hot_r', 'hsv', 'hsv_r', 'icefire', 'icefire_r', 'inferno', 'inferno_r', 'jet', 'jet_r', 'magma', 'magma_r', 'mako', 'mako_r', 'nipy_spectral', 'nipy_spectral_r', 'ocean', 'ocean_r', 'pink', 'pink_r', 'plasma', 'plasma_r', 'prism', 'prism_r', 'rainbow', 'rainbow_r', 'rocket', 'rocket_r', 'seismic', 'seismic_r', 'spring', 'spring_r', 'summer', 'summer_r', 'tab10', 'tab10_r', 'tab20', 'tab20_r', 'tab20b', 'tab20b_r', 'tab20c', 'tab20c_r', 'terrain', 'terrain_r', 'turbo', 'turbo_r', 'twilight', 'twilight_r', 'twilight_shifted', 'twilight_shifted_r', 'viridis', 'viridis_r', 'vlag', 'vlag_r', 'winter', 'winter_r'
        
        @input: 
        
                #SNAPSHOT
                self.snapshots[T]['vehs_at_lanes'] = copy.deepcopy(self.vehs_at_lanes)
                self.snapshots[T][vid] = {'S':copy.deepcopy(self.vehs_dict[vid]), \
                    #'feasibleincrement':copy.deepcopy(feasible_increment), \
                    'L':copy.deepcopy(L_dicts[vid]), \
                    'F':copy.deepcopy(F_dicts[vid]), \
                    'vehs_info_within_area_left':copy.deepcopy(vehs_info_within_area_left_dict[vid]), \
                    'vehs_info_within_area_right':copy.deepcopy(vehs_info_within_area_right_dict[vid]), \
                    'potentials':copy.deepcopy(potentials_dict[vid]), }
                #
        """
        from matplotlib.collections import LineCollection
        #from mpl_toolkits.mplot3d.axes3d import get_test_data
        # This import registers the 3D projection, but is otherwise unused.
        #from mpl_toolkits.mplot3d import Axes3D  # noqa: F401 unused import
        
        t0 = sorted(snapshots.keys())[0]
        #lanes_ids = snapshots[t]['vehs_at_lanes'].keys()
        #lanes_number = len(snapshots[t]['vehs_at_lanes'])
        #==========================================
        if isinstance(ax, bool):
            #fig, ax = plt.subplots(figsize = figsize, ncols = 1, nrows = 1, projection='3d')
            fig, ax = plt.subplots(figsize = figsize)
            #ax = plt.figure(figsize = figsize).add_subplot(projection='3d')
            #ax.set_xlabel('t');ax.set_ylabel('x');ax.set_zlabel('speed'); 
            #ax.grid();
            #ax = host_subplot(111)
            #par = ax.twinx()
            #fig,ax = plt.subplots(figsize = figsize, nrows = 1, ncols = 1)
        #
        #--------------------------------------
        #fig = plt.figure(figsize=plt.figaspect(0.5))
        #fig = plt.figure(figsize=figsize)
        TS = np.array(sorted(snapshots.keys()))
        #for laneidx,laneid in enumerate(lanes_ids):
        #for laneidx in range(lanes_number):
        #ax = axs[laneidx]
        #ax = fig.add_subplot(lanes_number, 1, laneidx, projection='3d')
        #
        #vids = snapshots[t0]['vehs_at_lanes'][laneid]#set(snapshots[t].keys())
        vids0 = []
        for t in TS:vids0.extend(snapshots[t]['vehs_at_lanes'][laneid])
        vids = set(vids0)
        #
        #
        TS_es = []
        XS_es = []
        VXs1  = []
        for vid in vids:
            color = np.random.uniform(size = (3,))
            #
            xs0 = [snapshots[t][vid]['S'][0] for t in TS if vid in snapshots[t]]
            #
            vxs = [snapshots[t][vid]['S'][1] for t in TS if vid in snapshots[t]]
            vxs1 = list(np.array(vxs)/vmax)

            #SEE https://stackoverflow.com/questions/64267329/how-to-plot-a-gradient-color-line
            #cut the trajectories into multi segments, becaus ethe period condition. 
            idxs_segments = TwoDimMicroModel.TransformPeriodic_ys_2MultiSegment_return_idxs_segments(ys = xs0, length = length)
            #ts_es,xs_es = TwoDimMicroModel.TransformPeriodic_ys_2MultiSegment(ys = xs0, length = length, ts = TS)
            #
            for segment in idxs_segments:
                TS_es.append(np.array(TS)[segment])
                XS_es.append(np.array(xs0)[segment])
                VXs1.append(np.array(vxs1)[segment])
        ##################
        for ts,xs,vs in zip(TS_es,XS_es, VXs1):
            points = np.array([ts, xs]).T.reshape(-1, 1, 2)
            segments = np.concatenate([points[:-1], points[1:]], axis=1)
            #lc = LineCollection(segments, cmap='viridis', alpha = alpha)
            lc = LineCollection(segments, cmap = cmap, alpha = alpha)
            lc.set_array(vs)
            ax.add_collection(lc)
            
            """
            #cut the trajectories into multi segments, becaus ethe period condition. 
            ts_es,xs_es = TwoDimMicroModel.TransformPeriodic_ys_2MultiSegment(ys = xs0, length = length, ts = TS)
            for ts,xs in zip(ts_es,xs_es):
                #ax.plot(ts,xs, color = color)
                ax.plot(ts,xs, cmap=plt.get_cmap('jet'))
            """
            #ax.plot(TS, xs0)
        #fig.colorbar(ax=ax)
        ax.set_xlabel('Time (sec)');ax.set_ylabel('x (m)');#ax.set_zlabel('speed');
        
        return ax
    

    @classmethod
    def plot_speed_profile_2D_singlelane_trajectories_BKP(self, snapshots, length = 500, laneid = 0, ax = False, figsize = (5,3), alpha = .4, vmax = 200/3.6, timeintervalploted = (100, 200)):
        """
        plot the speed profile of 3D, i.e. (t, x, v)
        
        
        @input: 
        
                #SNAPSHOT
                self.snapshots[T]['vehs_at_lanes'] = copy.deepcopy(self.vehs_at_lanes)
                self.snapshots[T][vid] = {'S':copy.deepcopy(self.vehs_dict[vid]), \
                    #'feasibleincrement':copy.deepcopy(feasible_increment), \
                    'L':copy.deepcopy(L_dicts[vid]), \
                    'F':copy.deepcopy(F_dicts[vid]), \
                    'vehs_info_within_area_left':copy.deepcopy(vehs_info_within_area_left_dict[vid]), \
                    'vehs_info_within_area_right':copy.deepcopy(vehs_info_within_area_right_dict[vid]), \
                    'potentials':copy.deepcopy(potentials_dict[vid]), }
                #
        """
        from matplotlib.collections import LineCollection
        #from mpl_toolkits.mplot3d.axes3d import get_test_data
        # This import registers the 3D projection, but is otherwise unused.
        #from mpl_toolkits.mplot3d import Axes3D  # noqa: F401 unused import
        
        t0 = sorted(snapshots.keys())[0]
        #lanes_ids = snapshots[t]['vehs_at_lanes'].keys()
        #lanes_number = len(snapshots[t]['vehs_at_lanes'])
        #==========================================
        if isinstance(ax, bool):
            #fig, ax = plt.subplots(figsize = figsize, ncols = 1, nrows = 1, projection='3d')
            fig, ax = plt.subplots(figsize = figsize)
            #ax = plt.figure(figsize = figsize).add_subplot(projection='3d')
            #ax.set_xlabel('t');ax.set_ylabel('x');ax.set_zlabel('speed'); 
            #ax.grid();
            #ax = host_subplot(111)
            #par = ax.twinx()
            #fig,ax = plt.subplots(figsize = figsize, nrows = 1, ncols = 1)
        #
        #--------------------------------------
        #fig = plt.figure(figsize=plt.figaspect(0.5))
        #fig = plt.figure(figsize=figsize)
        TS = np.array(sorted(snapshots.keys()))
        #for laneidx,laneid in enumerate(lanes_ids):
        #for laneidx in range(lanes_number):
        #ax = axs[laneidx]
        #ax = fig.add_subplot(lanes_number, 1, laneidx, projection='3d')
        #
        #vids = snapshots[t0]['vehs_at_lanes'][laneid]#set(snapshots[t].keys())
        vids0 = []
        for t in TS:vids0.extend(snapshots[t]['vehs_at_lanes'][laneid])
        vids = set(vids0)
        #
        #
        for vid in vids:
            color = np.random.uniform(size = (3,))
            #
            xs0 = [snapshots[t][vid]['S'][0] for t in TS if vid in snapshots[t]]
            #
            vxs = [snapshots[t][vid]['S'][1] for t in TS if vid in snapshots[t]]
            vxs1 = list(np.array(vxs)/vmax)

            #SEE https://stackoverflow.com/questions/64267329/how-to-plot-a-gradient-color-line
            #cut the trajectories into multi segments, becaus ethe period condition. 
            
            ts_es,xs_es = TwoDimMicroModel.TransformPeriodic_ys_2MultiSegment(ys = xs0, length = length, ts = TS)
            for ts,xs in zip(ts_es,xs_es):
                #ax.plot(ts,xs, color = color)
                #ax.plot(ts,xs, cmap=plt.get_cmap('jet'))
                points = np.array([ts, xs]).T.reshape(-1, 1, 2)
                segments = np.concatenate([points[:-1], points[1:]], axis=1)
                #
                lc = LineCollection(segments, cmap='viridis')
                lc.set_array(vxs1)
                ax.add_collection(lc)
            """
            #cut the trajectories into multi segments, becaus ethe period condition. 
            ts_es,xs_es = TwoDimMicroModel.TransformPeriodic_ys_2MultiSegment(ys = xs0, length = length, ts = TS)
            for ts,xs in zip(ts_es,xs_es):
                #ax.plot(ts,xs, color = color)
                ax.plot(ts,xs, cmap=plt.get_cmap('jet'))
            """
            #ax.plot(TS, xs0)
        #fig.colorbar(ax=ax)
        ax.set_xlabel('Time');ax.set_ylabel('x (m)');#ax.set_zlabel('speed');
        
        return ax
    


    @classmethod
    def plot_speed_profile_2D_singlelane_scatter(self, snapshots, laneid = 0, ax = False, figsize = (5,3), alpha = .4,vmax = 200/3.6, timeintervalploted = (100, 200)):
        """
        plot the speed profile of 3D, i.e. (t, x, v)
        
        
        @input: 
        
                #SNAPSHOT
                self.snapshots[T]['vehs_at_lanes'] = copy.deepcopy(self.vehs_at_lanes)
                self.snapshots[T][vid] = {'S':copy.deepcopy(self.vehs_dict[vid]), \
                    #'feasibleincrement':copy.deepcopy(feasible_increment), \
                    'L':copy.deepcopy(L_dicts[vid]), \
                    'F':copy.deepcopy(F_dicts[vid]), \
                    'vehs_info_within_area_left':copy.deepcopy(vehs_info_within_area_left_dict[vid]), \
                    'vehs_info_within_area_right':copy.deepcopy(vehs_info_within_area_right_dict[vid]), \
                    'potentials':copy.deepcopy(potentials_dict[vid]), }
                #
        """
        
        #from mpl_toolkits.mplot3d.axes3d import get_test_data
        # This import registers the 3D projection, but is otherwise unused.
        #from mpl_toolkits.mplot3d import Axes3D  # noqa: F401 unused import
        
        t = sorted(snapshots.keys())[0]
        #lanes_ids = snapshots[t]['vehs_at_lanes'].keys()
        #lanes_number = len(snapshots[t]['vehs_at_lanes'])
        #==========================================
        if isinstance(ax, bool):
            #fig, ax = plt.subplots(figsize = figsize, ncols = 1, nrows = 1, projection='3d')
            fig, ax = plt.subplots(figsize = figsize)
            #ax = plt.figure(figsize = figsize).add_subplot(projection='3d')
            #ax.set_xlabel('t');ax.set_ylabel('x');ax.set_zlabel('speed'); 
            #ax.grid();
            #ax = host_subplot(111)
            #par = ax.twinx()
            #fig,ax = plt.subplots(figsize = figsize, nrows = 1, ncols = 1)
        #
        #--------------------------------------
        #fig = plt.figure(figsize=plt.figaspect(0.5))
        #fig = plt.figure(figsize=figsize)
        Ts = np.array(sorted(snapshots.keys()))
        #for laneidx,laneid in enumerate(lanes_ids):
        #for laneidx in range(lanes_number):
        #ax = axs[laneidx]
        #ax = fig.add_subplot(lanes_number, 1, laneidx, projection='3d')
        #
        for t in Ts:
            if t<min(timeintervalploted):continue
            if t>=max(timeintervalploted):break
            #SNAPSHOTS[t].keys are the vids
            vids = snapshots[t]['vehs_at_lanes'][laneid]#set(snapshots[t].keys())
            #print(laneidx, vids)
            xs = [snapshots[t][vid]['S'][0] for vid in vids]
            #make color
            vxs = [snapshots[t][vid]['S'][1] for vid in vids]
            vxs1 = list(np.array(vxs)/vmax)
            vxs2 = [np.array([v, v, 0]) for v in vxs1]
            #print(max(vxs1))
            #
            ts = np.array([t]*len(xs))
            
            ax.scatter(ts,xs,  c = np.tan(vxs1))
            #ax.scatter(ts, xs, vxs,  c = np.tan(vxs1))
            
        ax.set_xlabel('Time');ax.set_ylabel('x (m)');#ax.set_zlabel('speed');
        
        return ax
    
    
    @classmethod
    def plot_speed_profile_3D_singlelane(self, snapshots, laneid = 0, ax = False, figsize = (5,3), alpha = .4,vmax = 200/3.6, timeintervalploted = (100, 200)):
        """
        plot the speed profile of 3D, i.e. (t, x, v)
        
        
        @input: 
        
                #SNAPSHOT
                self.snapshots[T]['vehs_at_lanes'] = copy.deepcopy(self.vehs_at_lanes)
                self.snapshots[T][vid] = {'S':copy.deepcopy(self.vehs_dict[vid]), \
                    #'feasibleincrement':copy.deepcopy(feasible_increment), \
                    'L':copy.deepcopy(L_dicts[vid]), \
                    'F':copy.deepcopy(F_dicts[vid]), \
                    'vehs_info_within_area_left':copy.deepcopy(vehs_info_within_area_left_dict[vid]), \
                    'vehs_info_within_area_right':copy.deepcopy(vehs_info_within_area_right_dict[vid]), \
                    'potentials':copy.deepcopy(potentials_dict[vid]), }
                #
        """
        
        #from mpl_toolkits.mplot3d.axes3d import get_test_data
        # This import registers the 3D projection, but is otherwise unused.
        #from mpl_toolkits.mplot3d import Axes3D  # noqa: F401 unused import
        
        t = sorted(snapshots.keys())[0]
        #lanes_ids = snapshots[t]['vehs_at_lanes'].keys()
        #lanes_number = len(snapshots[t]['vehs_at_lanes'])
        #==========================================
        if isinstance(ax, bool):
            #fig, ax = plt.subplots(figsize = figsize, ncols = 1, nrows = 1, projection='3d')
            
            ax = plt.figure(figsize = figsize).add_subplot(projection='3d')
            #ax.set_xlabel('t');ax.set_ylabel('x');ax.set_zlabel('speed'); 
            #ax.grid();
            #ax = host_subplot(111)
            #par = ax.twinx()
            #fig,ax = plt.subplots(figsize = figsize, nrows = 1, ncols = 1)
        #
        #--------------------------------------
        #fig = plt.figure(figsize=plt.figaspect(0.5))
        #fig = plt.figure(figsize=figsize)
        Ts = np.array(sorted(snapshots.keys()))
        #for laneidx,laneid in enumerate(lanes_ids):
        #for laneidx in range(lanes_number):
        #ax = axs[laneidx]
        #ax = fig.add_subplot(lanes_number, 1, laneidx, projection='3d')
        #
        for t in Ts:
            if t<min(timeintervalploted):continue
            if t>=max(timeintervalploted):break
            #SNAPSHOTS[t].keys are the vids
            vids = snapshots[t]['vehs_at_lanes'][laneid]#set(snapshots[t].keys())
            #print(laneidx, vids)
            xs = [snapshots[t][vid]['S'][0] for vid in vids]
            #make color
            vxs = [snapshots[t][vid]['S'][1] for vid in vids]
            vxs1 = list(np.array(vxs)/vmax)
            vxs2 = [np.array([v, v, 0]) for v in vxs1]
            #print(max(vxs1))
            #
            ts = np.array([t]*len(xs))
            
            
            ax.scatter(ts, xs, vxs,  c = np.tan(vxs1))
            
        ax.set_xlabel('Time');ax.set_ylabel('x (m)');ax.set_zlabel('speed');
    
    
    
    @classmethod
    def plot_speed_profile_3D(self, snapshots, ax = False, figsize = (5,3), alpha = .4,):
        """
        plot the speed profile of 3D, i.e. (t, x, v)
        
        
        @input: 
        
                #SNAPSHOT
                self.snapshots[T]['vehs_at_lanes'] = copy.deepcopy(self.vehs_at_lanes)
                self.snapshots[T][vid] = {'S':copy.deepcopy(self.vehs_dict[vid]), \
                    #'feasibleincrement':copy.deepcopy(feasible_increment), \
                    'L':copy.deepcopy(L_dicts[vid]), \
                    'F':copy.deepcopy(F_dicts[vid]), \
                    'vehs_info_within_area_left':copy.deepcopy(vehs_info_within_area_left_dict[vid]), \
                    'vehs_info_within_area_right':copy.deepcopy(vehs_info_within_area_right_dict[vid]), \
                    'potentials':copy.deepcopy(potentials_dict[vid]), }
                #
        """
        
        #from mpl_toolkits.mplot3d.axes3d import get_test_data
        # This import registers the 3D projection, but is otherwise unused.
        #from mpl_toolkits.mplot3d import Axes3D  # noqa: F401 unused import
        
        t = sorted(snapshots.keys())[0]
        lanes_ids = snapshots[t]['vehs_at_lanes'].keys()
        lanes_number = len(snapshots[t]['vehs_at_lanes'])
        #==========================================
        if isinstance(ax, bool):
            fig, axs = plt.subplots(figsize = figsize, ncols = 1, nrows = lanes_number)
            
            #ax = plt.figure().add_subplot(projection='3d')
            #ax.set_xlabel('t');ax.set_ylabel('x');ax.set_zlabel('speed'); 
            #ax.grid();
            #ax = host_subplot(111)
            #par = ax.twinx()
            #fig,ax = plt.subplots(figsize = figsize, nrows = 1, ncols = 1)
        #
        #--------------------------------------
        #fig = plt.figure(figsize=plt.figaspect(0.5))
        #fig = plt.figure(figsize=figsize)
        Ts = np.array(sorted(snapshots.keys()))
        for laneidx,laneid in enumerate(lanes_ids):
        #for laneidx in range(lanes_number):
            ax = axs[laneidx]
            #ax = fig.add_subplot(lanes_number, 1, laneidx, projection='3d')
            #
            for t in Ts:
                #SNAPSHOTS[t].keys are the vids
                vids = snapshots[t]['vehs_at_lanes'][laneid]#set(snapshots[t].keys())
                #print(laneidx, vids)
                xs = [snapshots[t][vid]['S'][0] for vid in vids]
                #make color
                vxs = [snapshots[t][vid]['S'][1] for vid in vids]
                #vxs1 = list(np.array(vxs)/vmax)
                #vxs2 = [np.array([v, v, 0]) for v in vxs1]
                #print(max(vxs1))
                #
                ts = np.array([t]*len(xs))
                
                
                ax.plot(ts, xs, vxs,  marker = '.')

    
    def plot_lanemarks_boundary(self, ax = False, figsize = (5,3), alpha = .4, markcolor = 'y', boundarycolor = 'k'):
        """
        
        """
        #==========================================
        if isinstance(ax, bool):
            fig,ax = plt.subplots(figsize = figsize)
            ax.set_xlabel('x');ax.set_ylabel('y'); 
            #ax.grid();
            #ax = host_subplot(111)
            #par = ax.twinx()
            #fig,ax = plt.subplots(figsize = figsize, nrows = 1, ncols = 1)
        

        
        #========================================
        for laneid in self.lanes_marks_coors.keys():
            a,b = self.lanes_marks_coors[laneid]
            ax.plot([0, self.length], [a,a], '-', color = markcolor, linewidth = 4 )
            ax.plot([0, self.length], [b, b],'-', color = markcolor,  linewidth = 4 )
        #==========================================
        #
        ax.plot([0, self.length], (self.road_bounds[0],  self.road_bounds[0]), 'k.-', linewidth = 4 )
        ax.plot([0, self.length], (self.road_bounds[1],  self.road_bounds[1]), 'k.-', linewidth = 4 )
        
        return ax
    
    
    @classmethod
    def search_leader(self, ego_state, ):
        """
        
        """
        
        
        
        pass


    
    @classmethod
    def search_vehs_within_ellise(self, ego_state, ellipse_x, ellipse_y_left, ellipse_y_right, left_lanes_vids, right_lanes_vids, vehs_info_dict, road_length):
        """
        Find the vehicle ids sushc that they are within the area. 
        
        Using the attribute of 
        
            vehs_info_within_area_left,vehs_info_within_area_right = 
            
        -----------------------------------------------
        @input: vehs_at_lanes
        
            a dict. 
            
            vehs_at_lanes[laneid] = [vid1, vid2, vid3...]
        
        @Input: left_lanes_vids and right_lanes_vids
            
            two lists containing the vehicle ids.
            
            NOTE that these vehicles are all downstream of the ego vehicle. 
            
        @input: vehs_info_dict
        
            vehs_info_dict[vid] is an array, np.array([x, vx, y, vy, zlon, zlat])
        
        ----------------------------------------------
        @OUTPUT: vehs_info_within_area_left,vehs_info_within_area_right
        
            both are dict. 
            
            vehs_info_within_area[vid] = np.array([x, vx, y, vy, zlon, zlat])
            
        """
        #the keys are vids. 
        #   vehs_ids_within_area[vid] = np.array([x, vx, y, vy, zlon, zlat])
        vehs_info_within_area_left = {}
        vehs_info_within_area_right = {}
        
        #################################################################LEFT lane
        #===============Reorder the left_lanes_vids and right_lanes_vids such that the periodic condition is considered. 
        #find the idx that is just downstream of ego_vehicle (i.e. idx_start_reordered). 
        if len(left_lanes_vids)>0:
            #Find the vehicle with idx that is downstreapm the ego vehicle. 
            #if idx_start_reordered means false, then it means all vehicles at left lane locate upstream of ego vehice
            idx_start_reordered = False
            for idx,vid in enumerate(left_lanes_vids):
                #if upstream then continue
                if vehs_info_dict[vid][0]>=ego_state[0]:
                    idx_start_reordered = idx
                    break
            #-----------------------IF idx_start_reordered is bool, it means that ego vehicle is the most downsteam vehicle at the lane. 
            if isinstance(idx_start_reordered, bool):
                for vid in left_lanes_vids:
                    deltax = road_length + vehs_info_dict[vid][0] - ego_state[0]
                    deltay = vehs_info_dict[vid][2] - ego_state[2]
                    #if deltax==0:continue
                    #
                    if deltax**2/ellipse_x/ellipse_x + deltay**2/ellipse_y_left/ellipse_y_left <=1:
                        vehs_info_within_area_left[vid] = copy.deepcopy(vehs_info_dict[vid])
                        vehs_info_within_area_left[vid][0] = vehs_info_within_area_left[vid][0] + road_length
                    else:
                        #break
                        continue
            else:
                #
                for vid in left_lanes_vids[idx_start_reordered:]:
                    deltax = vehs_info_dict[vid][0] - ego_state[0]
                    deltay = vehs_info_dict[vid][2] - ego_state[2]
                    #if deltax==0:continue
                    #
                    if deltax**2/ellipse_x/ellipse_x + deltay**2/ellipse_y_left/ellipse_y_left <=1:
                        vehs_info_within_area_left[vid] = copy.deepcopy(vehs_info_dict[vid])
                    else:
                        continue
                #
                for vid in left_lanes_vids[:idx_start_reordered]:
                    deltax = road_length + vehs_info_dict[vid][0] - ego_state[0]
                    deltay = vehs_info_dict[vid][2] - ego_state[2]
                    #if deltax==0:continue
                    #
                    if deltax**2/ellipse_x/ellipse_x + deltay**2/ellipse_y_left/ellipse_y_left <=1:
                        vehs_info_within_area_left[vid] = copy.deepcopy(vehs_info_dict[vid])
                        vehs_info_within_area_left[vid][0] = vehs_info_within_area_left[vid][0] + road_length
                    else:
                        #break
                        continue
        
        #################################################################right lane
        if len(right_lanes_vids)>0:
            #if idx_start_reordered means false, then it means all vehicles at left lane locate upstream of ego vehice
            idx_start_reordered = False
            for idx,vid in enumerate(right_lanes_vids):
                #if upstream then continue
                #print(vehs_info_dict[vid][0], ego_state[0])
                if vehs_info_dict[vid][0]>=ego_state[0]:
                    #print(vehs_info_dict[vid][0], ego_state[0], '----')
                    idx_start_reordered = idx
                    break
            if isinstance(idx_start_reordered, bool):
                #-------------------------------------right
                for vid in right_lanes_vids:
                    deltax = road_length + vehs_info_dict[vid][0] - ego_state[0]
                    deltay = vehs_info_dict[vid][2] - ego_state[2]
                    if deltax==0:continue
                    #
                    #print(ellipse_x)
                    if deltax**2/ellipse_x/ellipse_x + deltay**2/ellipse_y_right/ellipse_y_right <=1:
                        vehs_info_within_area_right[vid] = copy.deepcopy(vehs_info_dict[vid])
                        vehs_info_within_area_right[vid][0] = vehs_info_within_area_right[vid][0] + road_length
                    else:
                        continue#break
            else:
                for vid in right_lanes_vids[idx_start_reordered:]:
                    deltax = vehs_info_dict[vid][0] - ego_state[0]
                    deltay = vehs_info_dict[vid][2] - ego_state[2]
                    if deltax==0:continue
                    #
                    #print(ellipse_x)
                    if deltax**2/ellipse_x/ellipse_x + deltay**2/ellipse_y_right/ellipse_y_right <=1:
                        vehs_info_within_area_right[vid] = copy.deepcopy(vehs_info_dict[vid])
                    else:
                        continue#break
                for vid in right_lanes_vids[:idx_start_reordered]:
                    deltax = road_length + vehs_info_dict[vid][0] - ego_state[0]
                    deltay = vehs_info_dict[vid][2] - ego_state[2]
                    if deltax==0:continue
                    #
                    #print(ellipse_x)
                    if deltax**2/ellipse_x/ellipse_x + deltay**2/ellipse_y_right/ellipse_y_right <=1:
                        vehs_info_within_area_right[vid] = copy.deepcopy(vehs_info_dict[vid])
                        vehs_info_within_area_right[vid][0] = vehs_info_within_area_right[vid][0] + road_length
                    else:
                        continue#break
        #
        return vehs_info_within_area_left,vehs_info_within_area_right

    @classmethod
    def search_vehs_within_ellise_BKP2(self, ego_state, ellipse_x, ellipse_y_left, ellipse_y_right, left_lanes_vids, right_lanes_vids, vehs_info_dict):
        """
        Find the vehicle ids sushc that they are within the area. 
        
        Using the attribute of 
        
        
        -----------------------------------------------
        @input: vehs_at_lanes
        
            a dict. 
            
            vehs_at_lanes[laneid] = [vid1, vid2, vid3...]
        
        @Input: left_lanes_vids and right_lanes_vids
            
            two lists containing the vehicle ids.
            
            NOTE that these vehicles are all downstream of the ego vehicle. 
            
        @input: vehs_info_dict
        
            vehs_info_dict[vid] is an array, np.array([x, vx, y, vy, zlon, zlat])
        
        ----------------------------------------------
        @OUTPUT: vehs_info_within_area
        
            a dict. 
            
            vehs_info_within_area[vid] = np.array([x, vx, y, vy, zlon, zlat])
            
        """
        #the keys are vids. 
        #   vehs_ids_within_area[vid] = np.array([x, vx, y, vy, zlon, zlat])
        vehs_info_within_area = {}
        
        #===============Reorder the left_lanes_vids and right_lanes_vids such that the periodic condition is considered. 
        #find the idx that is just downstream of ego_vehicle (i.e. idx_start_reordered). 
        for idx,vid in enumerate(left_lanes_vids):
            #if upstream then continue
            if vehs_info_dict[vid][0]>=ego_state[0]:
                idx_start_reordered = idx
                break
        left_lanes_vids_reordered = left_lanes_vids[idx_start_reordered:] + left_lanes_vids[:idx_start_reordered]
        #find the idx that is just downstream of ego_vehicle. 
        #   find the idx_start_reordered
        for idx,vid in enumerate(right_lanes_vids):
            #if upstream then continue
            if vehs_info_dict[vid][0]>=ego_state[0]:
                idx_start_reordered = idx
                break
        right_lanes_vids_reordered = right_lanes_vids[idx_start_reordered:] + right_lanes_vids[:idx_start_reordered]
        
        
        #-------------------------------------Left
        for vid in left_lanes_vids_reordered:
            #if upstream then continue
            if vehs_info_dict[vid][0]<=ego_state[0]:continue
            #
            dletax = vehs_info_dict[vid][0] - ego_state[0]
            deltay = vehs_info_dict[vid][2] - ego_state[2]
            #
            if deltax**2/ellipse_x/ellipse_x + deltay**2/ellipse_y/ellipse_y <=1:
                vehs_info_within_area[vid] = copy.deepcopy(vehs_info_dict[vid])
            else:
                break
        
        #-------------------------------------right
        for vid in right_lanes_vids_reordered:
            #if upstream then continue
            if vehs_info_dict[vid][0]<=ego_state[0]:continue
            #
            dletax = vehs_info_dict[vid][0] - ego_state[0]
            deltay = vehs_info_dict[vid][2] - ego_state[2]
            #
            if deltax**2/ellipse_x/ellipse_x + deltay**2/ellipse_y/ellipse_y <=1:
                vehs_info_within_area[vid] = copy.deepcopy(vehs_info_dict[vid])
            else:
                break
        #
        return vehs_info_within_area
    
    @classmethod
    def search_vehs_within_ellise_BKP(self, ego_state, ellipse_x, ellipse_y_left, ellipse_y_right, left_lanes_vids, right_lanes_vids, vehs_info_dict):
        """
        Find the vehicle ids sushc that they are within the area. 
        
        Using the attribute of 
        
        
        -----------------------------------------------
        @input: vehs_at_lanes
        
            a dict. 
            
            vehs_at_lanes[laneid] = [vid1, vid2, vid3...]
        
        @Input: left_lanes_vids_downstream and right_lanes_vids_downstream
            
            two lists containing the vehicle ids.
            
            NOTE that these vehicles are all downstream of the ego vehicle. 
            
        @input: vehs_info_dict
        
            vehs_info_dict[vid] is an array, np.array([x, vx, y, vy, zlon, zlat])
        
        ----------------------------------------------
        @OUTPUT: vehs_info_within_area
        
            a dict. 
            
            vehs_info_within_area[vid] = np.array([x, vx, y, vy, zlon, zlat])
            
        """
        #the keys are vids. 
        #   vehs_ids_within_area[vid] = np.array([x, vx, y, vy, zlon, zlat])
        vehs_info_within_area = {}
        
        #-------------------------------------Left
        for vid in left_lanes_vids:
            #if upstream then continue
            if vehs_info_dict[vid][0]<=ego_state[0]:continue
            #
            dletax = vehs_info_dict[vid][0] - ego_state[0]
            deltay = vehs_info_dict[vid][2] - ego_state[2]
            #
            if deltax**2/ellipse_x/ellipse_x + deltay**2/ellipse_y/ellipse_y <=1:
                vehs_info_within_area[vid] = copy.deepcopy(vehs_info_dict[vid])
            else:
                break
        
        #-------------------------------------right
        for vid in right_lanes_vids:
            #if upstream then continue
            if vehs_info_dict[vid][0]<=ego_state[0]:continue
            #
            dletax = vehs_info_dict[vid][0] - ego_state[0]
            deltay = vehs_info_dict[vid][2] - ego_state[2]
            #
            if deltax**2/ellipse_x/ellipse_x + deltay**2/ellipse_y/ellipse_y <=1:
                vehs_info_within_area[vid] = copy.deepcopy(vehs_info_dict[vid])
            else:
                break
        #
        return vehs_info_within_area
    
    def __init__(self, lanes_ids = [0, 1, 2, 3], lw = 3.5, ):
        """
        
        """
        
        
        
        pass
        
    
    pass


class EmpericalObservation():
    """
    analyze the emperical observation of the lateral influences. 
    
    
    
    
    """
    lanrmarks_highd = {'6-7':23.87, '7-8':27.425, }
    
    
    @classmethod
    def extract_singlescenario2lateraldynamics_scenario8(self, data, lanrmarks_coor   = 27.425):
        """
        
        lateraldynamicsdata = 
        
        
        Types:

            ego
            ego + FL
            ego + FR
            ego + FL + FR
            ego + FL + F
            ego + FR + F
            ego + FL + FR + F
            ego + FR + F (NO left lane)
            ego + FL + F (NO right lane)

        
        ------------------------------------
        
        @input: data
            
            a pandas frame. columns are:
        
                Index(['frame', 'type', 'ego_id', 'fl_id', 'fr_id', 'f_id', 'ego_x', 'ego_y',
                       'ego_xVelocity', 'ego_yVelocity', 'ego_xAcceleration',
                       'ego_yAcceleration', 'ego_laneId', 'fl_x', 'fl_y', 'fl_xVelocity',
                       'fl_yVelocity', 'fl_xAcceleration', 'fl_yAcceleration', 'fl_laneId',
                       'fr_x', 'fr_y', 'fr_xVelocity', 'fr_yVelocity', 'fr_xAcceleration',
                       'fr_yAcceleration', 'fr_laneId', 'f_x', 'f_y', 'f_xVelocity',
                       'f_yVelocity', 'f_xAcceleration', 'f_yAcceleration', 'f_laneId'],
                      dtype='object')
        
        
        @OUTPUT: lateraldydata
        
            lateraldydata[scenario_idx] is a dict. 
        
            a dict. keys include 'ego_dis2mark', 'rightneighbor_dis2mark', 'deltax_ego_leader', 'speed_leader'
            
            ego_dis2mark is the distance to 
        
        @input: 
        
        """
        lateraldynamicsdata = {}
        
        #
        ego_ids = set(data['ego_id'])
        #
        #
        for ego_id in ego_ids:
            #vehdata is a daaframe. 
            vehdata = data[data.ego_id == ego_id].sort_values(by  = 'frame')
            
            #=============================first data
            scenariodata = vehdata.iloc[0, :]
            vehs_set_of_scenario = str(scenariodata.f_id) + '_' + str(scenariodata.fr_id)
            #
            ego_dis2mark = scenariodata.ego_y - lanrmarks_coor
            if np.isnan(scenariodata.f_id):
                deltax_ego_leader = None
                speed_leader = None
            else:
                deltax_ego_leader = scenariodata.f_x - scenariodata.ego_x
                speed_leader = scenariodata.fl_xVelocity
            if np.isnan(scenariodata.fr_id):
                rightneighbor_dis2mark = None
            else:
                rightneighbor_dis2mark =  lanrmarks_coor - scenariodata.fr_y
            #
            extracted_moments= [{'rightneighbor_dis2mark':rightneighbor_dis2mark, 'ego_dis2mark':ego_dis2mark, 'speed_leader':speed_leader, 'deltax_ego_leader':deltax_ego_leader}]
            #
            ####################split the data to each scenarios. 
            for rowidx in range(1, vehdata.shape[0]):
                #tmp_row data
                tmp_row_data = vehdata.iloc[rowidx, :]
                vehs_set_of_scenario_tmp = str(tmp_row_data.f_id) + '_' + str(tmp_row_data.fr_id)
                #
                if vehs_set_of_scenario_tmp==vehs_set_of_scenario:
                    #extract data. 
                    ego_dis2mark = tmp_row_data.ego_y - lanrmarks_coor
                    if np.isnan(tmp_row_data.fr_id):
                        rightneighbor_dis2mark = None
                    else:
                        rightneighbor_dis2mark =  lanrmarks_coor - tmp_row_data.fr_y
                    if np.isnan(tmp_row_data.f_id):
                        deltax_ego_leader = None
                        speed_leader = None
                    else:
                        deltax_ego_leader = tmp_row_data.f_x - tmp_row_data.ego_x
                        speed_leader = tmp_row_data.fl_xVelocity

                    extracted_moments.append({'rightneighbor_dis2mark':rightneighbor_dis2mark, 'ego_dis2mark':ego_dis2mark, 'speed_leader':speed_leader, 'deltax_ego_leader':deltax_ego_leader})
                    
                else:
                    #===========save data
                    if not np.isnan(tmp_row_data.fr_id):
                        lateraldynamicsdata[len(lateraldynamicsdata)] = copy.deepcopy(pd.DataFrame(extracted_moments))
                    #===========restart from the row
                    scenariodata = vehdata.iloc[rowidx, :]
                    vehs_set_of_scenario = str(scenariodata.f_id) + '_' + str(scenariodata.fr_id)
                    #init the data. 
                    ego_dis2mark = scenariodata.ego_y - lanrmarks_coor
                    if np.isnan(scenariodata.f_id):
                        deltax_ego_leader = None
                        speed_leader = None
                    else:
                        deltax_ego_leader = scenariodata.f_x - scenariodata.ego_x
                        speed_leader = scenariodata.fl_xVelocity
                    if np.isnan(scenariodata.fr_id):
                        rightneighbor_dis2mark = None
                    else:
                        rightneighbor_dis2mark =  lanrmarks_coor - scenariodata.fr_y
                    #
                    extracted_moments= [{'rightneighbor_dis2mark':rightneighbor_dis2mark, 'ego_dis2mark':ego_dis2mark, 'speed_leader':speed_leader, 'deltax_ego_leader':deltax_ego_leader}]
        #
        #lateraldynamicsdata
        #
        return lateraldynamicsdata


    @classmethod
    def plot_lateraldynamicsdata_2d(self, lateraldynamicsdata, ax = False, figsize = (5,3), alpha = .4,vmax = 200/3.6, timeintervalploted = (100, 200)):
        """
        
        @input: lateraldynamicsdata
        
            lateraldynamicsdata[scenario_idx]
            lateraldynamicsdata[0].columns

            Index(['rightneighbor_dis2mark', 'ego_dis2mark', 'speed_leader',
                   'deltax_ego_leader'],
                  dtype='object')
            
        """
        #from mpl_toolkits.mplot3d.axes3d import get_test_data
        # This import registers the 3D projection, but is otherwise unused.
        #from mpl_toolkits.mplot3d import Axes3D  # noqa: F401 unused import
        
        #==========================================
        if isinstance(ax, bool):
            fig,ax = plt.subplots(figsize = figsize)#.add_subplot(projection='3d')
            
            #ax = plt.figure().add_subplot(projection='3d')
            #ax.set_xlabel('t');ax.set_ylabel('x');ax.set_zlabel('speed'); 
            #ax.grid();
            #ax = host_subplot(111)

        for idx in lateraldynamicsdata.keys():
            scenario = lateraldynamicsdata[idx]
            #
            #print(scenario['speed_leader'].iloc[0], type(scenario['speed_leader'].iloc[0]))
            if not isinstance(scenario['speed_leader'].iloc[0], float):continue
            if not isinstance(scenario['rightneighbor_dis2mark'].iloc[0], float):continue
            #print(scenario['speed_leader'].iloc[0], type(scenario['speed_leader'].iloc[0]))
            #if (scenario['speed_leader'].iloc[0] is None) or np.isnan(scenario['speed_leader'].iloc[0]):continue
            #
            speed_leader = scenario['speed_leader']
            rightneighbor_dis2mark = scenario['rightneighbor_dis2mark']
            #ego_dis2mark = abs(scenario['ego_dis2mark'])
            ego_dis2mark = scenario['ego_dis2mark']
            #
            #ax.plot(ego_dis2mark, rightneighbor_dis2mark, speed_leader)
            ax.plot(ego_dis2mark, rightneighbor_dis2mark, alpha = alpha)
        
        ax.set_xlabel('ego distance to mark');
        #ax.set_zlabel('leader speed');
        ax.set_ylabel('neighbores distance to mark');
        
        return ax


    @classmethod
    def plot_lateraldynamicsdata_3d(self, lateraldynamicsdata, ax = False, figsize = (5,3), alpha = .4,vmax = 200/3.6, timeintervalploted = (100, 200)):
        """
        
        @input: lateraldynamicsdata
        
            lateraldynamicsdata[scenario_idx]
            lateraldynamicsdata[0].columns

            Index(['rightneighbor_dis2mark', 'ego_dis2mark', 'speed_leader',
                   'deltax_ego_leader'],
                  dtype='object')
            
        """
        #from mpl_toolkits.mplot3d.axes3d import get_test_data
        # This import registers the 3D projection, but is otherwise unused.
        #from mpl_toolkits.mplot3d import Axes3D  # noqa: F401 unused import
        
        #==========================================
        if isinstance(ax, bool):
            ax = plt.figure(figsize = figsize).add_subplot(projection='3d')
            
            #ax = plt.figure().add_subplot(projection='3d')
            #ax.set_xlabel('t');ax.set_ylabel('x');ax.set_zlabel('speed'); 
            #ax.grid();
            #ax = host_subplot(111)

        for idx in lateraldynamicsdata.keys():
            scenario = lateraldynamicsdata[idx]
            #
            #print(scenario['speed_leader'].iloc[0], type(scenario['speed_leader'].iloc[0]))
            if not isinstance(scenario['speed_leader'].iloc[0], float):continue
            if not isinstance(scenario['rightneighbor_dis2mark'].iloc[0], float):continue
            #print(scenario['speed_leader'].iloc[0], type(scenario['speed_leader'].iloc[0]))
            #if (scenario['speed_leader'].iloc[0] is None) or np.isnan(scenario['speed_leader'].iloc[0]):continue
            #
            speed_leader = scenario['speed_leader']
            rightneighbor_dis2mark = scenario['rightneighbor_dis2mark']
            ego_dis2mark = abs(scenario['ego_dis2mark'])
            #
            ax.plot(ego_dis2mark, rightneighbor_dis2mark, speed_leader)
            ax.plot(ego_dis2mark, rightneighbor_dis2mark, 0*np.array(speed_leader))
        
        ax.set_xlabel('ego distance to mark');
        ax.set_zlabel('leader speed');
        ax.set_ylabel('neighbores distance to mark');
        
        return ax

        
        

class MultiLaneHomogeneousPeriodSim(MultiLaneHomogeneousSim):
    """
    Simulation of the homogeneous lane with periodic condition. . 
    
    The longitudinal coordinate increases downstream and the vehicles are always inserted at the location of x=0. 
    
    The lateral origin coordinate locates at the rightmost lane boundary. 
    
    
    """
    
    def __init__(self, lanes_ids = [0, 1, 2, 3], lws = [3.5, 3.5, 3.5, 3.5], length = 1000):
        """
        
        ---------------------------------------------------------------
        @input: lws
        
            a lists containing the lane withs of each lane. 
            
        @input: lanes_ids = [0, 1, 2, 3]
        
            from leftmost to the right most lane. 
            Leftmost lane is labeled 0
            
            
        """
        
        
        
        #========================================self.lanes_ids, self.lws, self.length
        #   lane id
        self.lanes_ids = lanes_ids
        self.lws = lws
        self.length = length
        
        #========================================self.lws_dict
        self.lws_dict = {laneid:lw for laneid,lw in zip(lanes_ids, lws)}
        #========================================self.left_lane_id and self.right_lane_id
        #   calculate the left-lane and right_lane. 
        self.left_lane_id = {}
        self.right_lane_id = {}
        #Assign right lane
        for idx in range(len(lanes_ids)-1):
            laneid = self.lanes_ids[idx]
            self.right_lane_id[laneid] = self.lanes_ids[idx + 1] 
        #Assign left lane
        for idx in range(1, len(lanes_ids)):
            laneid = self.lanes_ids[idx]
            self.left_lane_id[laneid] = self.lanes_ids[idx - 1] 
        #========================================self.ellipse_y_left and self.ellipse_y_right
        #calcualte the ellipse_y， keys are the lane ids. 
        self.ellipse_y_left = {}
        self.ellipse_y_right = {}
        for idx in range( len(lanes_ids)):
            laneid = self.lanes_ids[idx]
            #idx=0 means it is the leftmost lane, self.ellipse_y_left
            if idx==0:
                #
                self.ellipse_y_left[laneid] = 0
                #
                self.ellipse_y_right[laneid] = self.lws_dict[laneid]/2.0 + self.lws_dict[self.right_lane_id[laneid]]/2.0
                continue
            #self.ellipse_y_left
            elif idx==len(lanes_ids)-1:
                #
                self.ellipse_y_left[laneid] = self.lws_dict[laneid]/2.0 + self.lws_dict[self.left_lane_id[laneid]]/2.0
                #
                self.ellipse_y_right[laneid] = 0
                
            else:
                #-----------
                self.ellipse_y_left[laneid] = self.lws_dict[laneid]/2.0 + self.lws_dict[self.left_lane_id[laneid]]/2.0
                self.ellipse_y_right[laneid] = self.lws_dict[laneid]/2.0 + self.lws_dict[self.right_lane_id[laneid]]/2.0
        
        #========================================self.length
        self.length = length
        #
        #========================================self.lanes_middle_line
        #calculate the lanes middle line coordinate. 
        #self.lanes_middle_line[land_id] = the lateral coordinate of the lane middle line. 
        #   NOTE that the origin locates at the rightmost lane boundary. 
        self.lanes_middle_line = {}
        for idx in range(len(lanes_ids)):
            #
            laneid = self.lanes_ids[idx]
            #
            self.lanes_middle_line[laneid]  = self.lws_dict[laneid]/2.0 + sum(lws[idx+1:])
            #
        #========================================self.lanes_marks_coors
        #self.lanes_marks_coors[laneid] = (left_mark_coor, right_mark_coor), both are floats. 
        self.lanes_marks_coors = {}
        for idx in range(len(lanes_ids)):
            #
            laneid = self.lanes_ids[idx]
            #
            self.lanes_marks_coors[laneid]  = (self.lanes_middle_line[laneid] - self.lws_dict[laneid]/2.0, self.lanes_middle_line[laneid] + self.lws_dict[laneid]/2.0)
        #======================================self.road_bounds
        self.road_bounds = (0, sum(lws))
        #lw_boundary_lanes
        self.lw_boundary_lanes = (self.lws[0], self.lws[-1])
        
        #========================================Dynmaic properties. 
        #   ----------------self.vehs_at_lanes, self.vehs_dict,self.vehs_target_lane
        #self.vehs_at_lanes[lane_id] = [vid1, vid2,....]. NOTE THAT THEY ARE SPORTED FROM 1st vehicle to last vehicle. 
        self.vehs_at_lanes  =  {lane_ids:[] for lane_ids in lanes_ids}
        #self.vehs_dict[vehicle_id] = [x, vx, y, vy, zlon, zlat]
        self.vehs_dict = {}
        #self.vehs_two_dim_paras[vid] = two_dim_paras
        self.vehs_two_dim_paras = {}
        self.vehs_idm_paras = {}
        #self.vehs_target_lane = {vid:lane_id}, the target lane id of each vehicle. 
        #   then the target lateral location is determined via: self.lanes_middle_line[self.vehs_target_lane[vid]]
        self.vehs_target_lane = {}
        #   self.snapshots[moment] is a dict. 
        #   self.snapshots[moment][vid] is a dict. 
        #   self.snapshots[moment][vid] keys include 'leader','neighbores','potentials.'
        self.snapshots = {}
        #-------------------------------
        
    
    def get_lanes_densities(self, ):
        """
        Get the density of all lanes.
        
        -------------------------------
        @output: lanesdensities
        
            lanesdensities[lane_id] = float.
        
        """
        
        return {lane_id:len(self.vehs_at_lanes[lane_id])/(self.length/1000.0) for lane_id in self.lanes_ids}
    
    def savesnapshot(self, ):
        """
        save the snapshots. 
        
        """
        
        
        
        pass


    @classmethod
    def TrimUpdate(self, old_state, deltat_sec, F, L, brownian, lanemarkscoor = (0, 0), idm_paras = idm_paras, lateral_marginal_tolerance = .0001):
        """
        The update of the state is calculated as:
        
            new_state = old_state + F*deltat_sec + np.matmul(L, brownian)
            
        Or equilivalently:
        
            new_state = old_state + (F + np.matmul(L, brownian/deltat_sec))*deltat_sec
        
        The above is for the sysmtem dynamics dS = F(S)dt + L(S) dW. 
        
        
        However, the acceleration may exceed the maximum acceleration. 
        
        -----------------------------------
        @input: deltat_sec
        
            a float. 
        
        @input: F L
        
            both are array. 
            
            F.shape is (6,)
            
            L.shape is (6, 2)
            
            brownian shape is (2,)
            
            
        
        """
        
        #increment shape is (6,)
        increment = F + np.matmul(L, brownian/deltat_sec)
        new_state_candidate  = old_state + increment*deltat_sec
        #
        #absolutely cannot move backward. 
        new_state_candidate[0] = max(new_state_candidate[0], old_state[0])
        new_state_candidate[1] = min(idm_paras['idm_vf'], max(0, new_state_candidate[1]))
        
        #absolutely cannot move backward. 
        #increment[0] = min(idm_paras['idm_vf'], max(0, increment[0]))
        #the acceleration
        #increment[1] = min(idm_paras['a_MAX'], max(-idm_paras['a_MAX'], increment[1]))
        
        #the lateral movement
        #tmp0 = (old_state[2]-max(lanemarkscoor) + lateral_marginal_tolerance)/deltat_sec
        #tmp1 = (old_state[2]-min(lanemarkscoor)- lateral_marginal_tolerance)/deltat_sec
        #print(increment[2], min(tmp0 , max(increment[2] , tmp1)))
        #increment[2] = min(tmp0 , max(increment[2] , tmp1))
        
        feasible_increment = increment*deltat_sec
        
        return new_state_candidate,feasible_increment
    
    @classmethod
    def TrimUpdate_BKP(self, old_state, deltat_sec, F, L, brownian, lanemarkscoor = (0, 0), idm_paras = idm_paras, lateral_marginal_tolerance = .0001):
        """
        The update of the state is calculated as:
        
            new_state = old_state + F*deltat_sec + np.matmul(L, brownian)
            
        Or equilivalently:
        
            new_state = old_state + (F + np.matmul(L, brownian/deltat_sec))*deltat_sec
        
        The above is for the sysmtem dynamics dS = F(S)dt + L(S) dW. 
        
        
        However, the acceleration may exceed the maximum acceleration. 
        
        -----------------------------------
        @input: deltat_sec
        
            a float. 
        
        @input: F L
        
            both are array. 
            
            F.shape is (6,)
            
            L.shape is (6, 2)
            
            brownian shape is (2,)
            
            
        
        """
        
        #increment shape is (6,)
        increment = F + np.matmul(L, brownian/deltat_sec)
        
        #absolutely cannot move backward. 
        increment[0] = min(idm_paras['idm_vf'], max(0, increment[0]))
        #the acceleration
        increment[1] = min(idm_paras['a_MAX'], max(-idm_paras['a_MAX'], increment[1]))
        
        #the lateral movement
        #tmp0 = (old_state[2]-max(lanemarkscoor) + lateral_marginal_tolerance)/deltat_sec
        #tmp1 = (old_state[2]-min(lanemarkscoor)- lateral_marginal_tolerance)/deltat_sec
        #print(increment[2], min(tmp0 , max(increment[2] , tmp1)))
        #increment[2] = min(tmp0 , max(increment[2] , tmp1))
        
        feasible_increment = increment*deltat_sec
        
        return old_state + increment*deltat_sec,feasible_increment


    def sim(self, deltat_sec =.5, T_horizon_sec = 3600.0, desired_density = 100, inserted_initial_state = np.array([.0, .0, .0, 0, .0, .0]), safety_gap2downstream_when_insert = 10, safety_gap2upstream_when_insert = 10,  idm_paras = idm_paras, stochastic_proecess_name = 'converted', two_dim_paras = two_dim_paras, leader_state_infinity = np.array([1e10, .0, .0, 0, .0, .0]), ellipse_x_min = 20, ellipse_x_max = 100, intert_tolerance = 1e-1):
        """
        
        @input: desired_density
            
            the desired density. unit is veh/km.
        
        @input: deltat_sec
        
            the time step, unit is sec. 
        
        @input: inserted_initial_state
        
            inserted_initial_state = [x, vx, y ,vy, zlon, zlat]
        
        @input: safety_gap2downstream_when_insert and safety_gap2upstream_when_insert
            
            both are float. WHen the inser. 
        
        @input: leader_state_infinity
        
            if there is only one vehicle and then the leader locates at infunity. 
        
        @OUTPUTS: STATES
        
            STATES[moment][vid] = state
        
        --------------------------
        @STEPS:
        
            - 
            
            
            
        """
        STATES = {}
        self.snapshots = {}
        #
        T = 0
        while T<T_horizon_sec:
            self.snapshots[T] = {}
            ####################################Insert vehices 
            #obtain the densityed. lanesdensities[vid] = float, the density at the road. 
            lanesdensities = self.get_lanes_densities()
            #
            #for laneid in lanesdensities.keys():
            for idx_lane,laneid in self.lanes_ids:
                #
                #---------------------------------------------------
                #---------------------------------------------------
                if lanesdensities[laneid]>=desired_density:continue
                #
                if lanesdensities[laneid]>0:
                    #----------------insert vehicles. change self.vehs_at_lanes and self.vehs_dict
                    vid_downstream =  self.vehs_at_lanes[laneid][0]
                    vid_upstream = self.vehs_at_lanes[laneid][-1]
                    #
                    #Check the safety_gap2downstream_when_insert and safety_gap2upstream_when_insert.
                    #print(self.vehs_dict[vid_downstream][0], self.vehs_dict[vid_upstream][0])
                    if not (self.vehs_dict[vid_downstream][0]<=safety_gap2downstream_when_insert or self.length-self.vehs_dict[vid_upstream][0]<safety_gap2upstream_when_insert):
                        
                        #print('Insert at lane id----->', laneid)
                        #INSERT VEHICLE.
                        vid_new = len(self.vehs_dict)#uuid.uuid1()
                        inserted_initial_state0 =  inserted_initial_state
                        inserted_initial_state0[0] = np.random.uniform(0, safety_gap2downstream_when_insert)
                        inserted_initial_state0[2] = self.lanes_middle_line[laneid]
                        #
                        self.vehs_dict[vid_new] = copy.deepcopy(inserted_initial_state0)
                        self.vehs_at_lanes[laneid].insert(0, vid_new)
                        self.vehs_target_lane[vid_new] = laneid
                else:
                    #else means that there is no vehicle at the road. 
                    #print('Insert at lane id----->', laneid)
                    #INSERT VEHICLE.
                    vid_new = len(self.vehs_dict)#uuid.uuid1()
                    inserted_initial_state0 =  inserted_initial_state
                    inserted_initial_state0[0] = np.random.uniform(0, safety_gap2downstream_when_insert)
                    inserted_initial_state0[2] = self.lanes_middle_line[laneid]
                    #
                    self.vehs_dict[vid_new] = copy.deepcopy(inserted_initial_state0)
                    self.vehs_at_lanes[laneid].insert(0, vid_new)
                    self.vehs_target_lane[vid_new] = laneid
                    
                    
            #################################Microscopic traffic flow model
            #calcualte F and L. keys are the vehicle ids. 
            #   F_dicts[vid] is a 1d array. 
            #   L_dicts[vid] is a N*2 array. 2 means lon and lat noise. 
            F_dicts = {}
            L_dicts = {}
            vehs_info_within_area_left_dict = {}
            vehs_info_within_area_right_dict = {}
            leader_state_dict = {}
            potentials_dict = {}
            #for laneid in lanesdensities.keys():
            for idx_lane,laneid in self.lanes_ids:
                #------------------------------------------------------
                #------------------------------------------------------
                #idx_lane = 0 means leftmost lane, rightbound not exit and left mark force not exist. 
                if idx_lane==0:
                    left_mark_force = False
                    right_bound_force = False
                    #
                    right_mark_force = True
                    left_bound_force = True
                #idx_lane==len(road_attrs['lanes_ids'])-1 means RIGHTMOST lane. 
                if idx_lane==len(road_attrs['lanes_ids'])-1:
                    right_mark_force = False
                    left_bound_force = False
                    #
                    left_mark_force = True
                    right_bound_force = True
                #------------------------------------------
                #----------------find the vehs_info_within_area. 
                for i,vid in enumerate(self.vehs_at_lanes[laneid]):
                    # ----------------------------
                    ego_state = self.vehs_dict[vid]
                    #
                    #=========================================FInd the leader
                    #find the leader and the lateral vehicles. 
                    if len(self.vehs_at_lanes[laneid])==1:
                        leader_state = copy.deepcopy(ego_state)
                        leader_state[0] = ego_state[0]+1e10
                    else:
                        if i==len(self.vehs_at_lanes[laneid])-1:
                            #
                            leader_id = self.vehs_at_lanes[laneid][0]
                            leader_state = copy.deepcopy(self.vehs_dict[leader_id])
                            leader_state[0] = leader_state[0]+ self.length
                            
                        else:
                            leader_id = self.vehs_at_lanes[laneid][i+1]
                            leader_state = self.vehs_dict[leader_id]
                        #------------------search leader at ego lane. 
                    leader_state_dict[vid] = copy.deepcopy(leader_state)
                    #
                    #==============================================FInd the lateral vehicles.
                    #============================================They will be stored in vehs_info_within_area_left and vehs_info_within_area_right
                    #find the lateral vehicles within influence areas, which is store
                    #ellipse_x = self.ellipse_x(ego_state  = ego_state)
                    ellipse_x = self.ellipse_x(ego_state  = ego_state, a_x_MAX = idm_paras['idm_a'], ellipse_x_min = ellipse_x_min, ellipse_x_max = ellipse_x_max)
                    #
                    if laneid==self.lanes_ids[0]:
                        left_lanes_vids = []
                    else:
                        left_lanes_vids = self.vehs_at_lanes[self.left_lane_id[laneid]]
                    if laneid==self.lanes_ids[-1]:
                        right_lanes_vids = []
                    else:
                        right_lanes_vids = self.vehs_at_lanes[self.right_lane_id[laneid]]
                    #vehs_info_within_area_left is a dict. 
                    #print(right_lanes_vids, '---')
                    vehs_info_within_area_left,vehs_info_within_area_right = self.search_vehs_within_ellise(ego_state = ego_state, \
                        ellipse_x = ellipse_x, \
                        ellipse_y_left = self.ellipse_y_left[laneid],  \
                        ellipse_y_right = self.ellipse_y_right[laneid] ,  \
                        left_lanes_vids = left_lanes_vids, \
                        right_lanes_vids = right_lanes_vids, \
                        vehs_info_dict = self.vehs_dict, road_length  = self.length)
                    #print(vehs_info_within_area_right.keys(), '---')
                    #
                    vehs_info_within_area_left_dict[vid] = vehs_info_within_area_left
                    vehs_info_within_area_right_dict[vid] = vehs_info_within_area_right
                    #
                    #============================================Calculate F and L
                    #--------------calculate the F and L
                    #   F_dicts[vid] is a 1d array. 
                    F_dicts[vid],potentials_dict[vid] = TwoDimMicroModel.F(ego_state  = ego_state, \
                        ego_lane_lw = self.lws_dict[laneid], \
                        ego_lane_middle_line_coor = self.lanes_middle_line[laneid], \
                        ego_lane_marks_coor = self.lanes_marks_coors[laneid], \
                        road_bounds = self.road_bounds, \
                        lw_boundary_lanes = self.lw_boundary_lanes, \
                        leader_state = leader_state, \
                        ellipse_x = ellipse_x, \
                        ellipse_y_left = self.ellipse_y_left[laneid],  \
                        ellipse_y_right = self.ellipse_y_right[laneid] ,  \
                        vehs_info_within_area_left = vehs_info_within_area_left, \
                        vehs_info_within_area_right = vehs_info_within_area_left, \
                        two_dim_paras = two_dim_paras, \
                        stochastic_proecess_name = stochastic_proecess_name, \
                        right_mark_force = right_mark_force,  \
                        left_bound_force = left_bound_force, \
                        left_mark_force = left_mark_force, 
                        right_bound_force = right_bound_force, )
                    #
                    L_dicts[vid] = TwoDimMicroModel.L(state  = ego_state, two_dim_paras = two_dim_paras, stochastic_proecess_name = stochastic_proecess_name, \
                        right_mark_force = right_mark_force,  \
                        left_bound_force = left_bound_force, \
                        left_mark_force = left_mark_force, 
                        right_bound_force = right_bound_force, )
                    
            ################################UPDATE
            #
            for vid in self.vehs_dict.keys():
                brownian = np.random.normal(loc = np.zeros((2,)), scale = deltat_sec)
                
                #
                #print(self.vehs_dict[vid], vid in F_dicts, vid in L_dicts)
                
                
                new_state,feasible_increment = self.TrimUpdate(old_state = self.vehs_dict[vid], deltat_sec = deltat_sec, F = F_dicts[vid], L = L_dicts[vid], brownian = brownian, idm_paras = idm_paras)
                #new_state = F_dicts[vid] + np.matmul(L_dicts[vid], brownian/deltat_sec)
                
                #
                #print(F_dicts[vid].shape, np.matmul(L_dicts[vid], brownian).shape)
                #new_state = self.vehs_dict[vid] + F_dicts[vid]*deltat_sec + np.matmul(L_dicts[vid], brownian)
                #---------------------UPDATE systen variables. 
                #SNAPSHOT
                self.snapshots[T]['vehs_at_lanes'] = copy.deepcopy(self.vehs_at_lanes)
                self.snapshots[T][vid] = {'S':copy.deepcopy(self.vehs_dict[vid]), \
                    #'feasibleincrement':copy.deepcopy(feasible_increment), \
                    'L':copy.deepcopy(L_dicts[vid]), \
                    'F':copy.deepcopy(F_dicts[vid]), \
                    'vehs_info_within_area_left':copy.deepcopy(vehs_info_within_area_left_dict[vid]), \
                    'vehs_info_within_area_right':copy.deepcopy(vehs_info_within_area_right_dict[vid]), \
                    'potentials':copy.deepcopy(potentials_dict[vid]), }
                #
                
                if new_state[0]>self.length:
                    new_state[0] = new_state[0] - self.length
                    #print(new_state.shape)
                    self.vehs_dict[vid] = new_state
                    #
                    tmp = copy.deepcopy([self.vehs_at_lanes[laneid][-1]] + self.vehs_at_lanes[laneid][:-1])
                    self.vehs_at_lanes[laneid] = tmp
                else:
                    #print(new_state.shape)
                    self.vehs_dict[vid] = new_state
            #
            #############################RECORD the state
            STATES[T] = copy.deepcopy(self.vehs_dict)
            
            #
            T = T + deltat_sec
            builtins.tmp = STATES
        
        return STATES


    
    @classmethod
    def plot_marginal_distribution(self, snapshots, roadlength, lanes_marks_coors,ax = False, figsize = (5,3), alpha = .4, n_xs_marginal = 10, tolerance_x_find_y = 1.0, bins = 20):
        """
        plot the xy and the p(y | x), i.e. the marginal distribution. 
        
        
        @input: STATES
        
                #SNAPSHOT
                self.snapshots[T]['vehs_at_lanes'] = copy.deepcopy(self.vehs_at_lanes)
                self.snapshots[T][vid] = {'S':copy.deepcopy(self.vehs_dict[vid]), \
                    #'feasibleincrement':copy.deepcopy(feasible_increment), \
                    'L':copy.deepcopy(L_dicts[vid]), \
                    'F':copy.deepcopy(F_dicts[vid]), \
                    'vehs_info_within_area_left':copy.deepcopy(vehs_info_within_area_left_dict[vid]), \
                    'vehs_info_within_area_right':copy.deepcopy(vehs_info_within_area_right_dict[vid]), \
                    'potentials':copy.deepcopy(potentials_dict[vid]), }
        
        @input: lanes_marks_coors
        
            {0: (10.2, 13.7),
             1: (6.699999999999999, 10.2),
             2: (3.4999999999999996, 6.699999999999999),
             3: (0.0, 3.5)}
        
        @input: tolerance_x_find_y
        
            given x0, when finding y, the method is that:
            
                - find the idx that with x sasitf abs(x-x0)<tolerance_x_find_y
                - get the y. 
        
        @input: n_xs_marginal
        
            the number of the marginals to be calculated and plotted. 
        
        """
        #
        xs_marginals  = np.linspace(1, roadlength-1, n_xs_marginal)
        t = sorted(snapshots.keys())[0]
        lanes_ids = snapshots[t]['vehs_at_lanes'].keys()
        lanes_number = len(snapshots[t]['vehs_at_lanes'])
        #---------------------------------------------------
        if isinstance(ax, bool):
            fig,ax = plt.subplots(figsize = figsize, ncols = 1, nrows = 1)
            #ax.set_xlabel('x');ax.set_ylabel('y'); 
            #ax.grid();
            #ax = host_subplot(111)
            #par = ax.twinx()
            #fig,ax = plt.subplots(figsize = figsize, nrows = 1, ncols = 1)
        ##############################First plot
        #############################second plot
        
            
            #
        for idx,laneid in enumerate(lanes_ids):
            color = np.random.uniform(size = (3,))
            for x in xs_marginals:
                ys = []
                for t in sorted(snapshots.keys()):
                    
                    for vid in snapshots[t]['vehs_at_lanes'][laneid]:
                        #print()
                        if abs(snapshots[t][vid]['S'][0] - x)<=tolerance_x_find_y:
                            ys.append(snapshots[t][vid]['S'][2])
                #normalize the ys
                ys = np.array(ys) - (min(lanes_marks_coors[laneid]) + max(lanes_marks_coors[laneid]))/2.0
                ys = ys/(- min(lanes_marks_coors[laneid]) + max(lanes_marks_coors[laneid]))
                
                #
                hist, edges = np.histogram(ys, bins = bins)
                ax.plot(edges[1:], hist/sum(hist)/(edges[-1] - edges[-2]), label = 'loc = ' + str(int(x*100)/100.0) + ' m', color  = color)
        
        #--------------------------------------
        #for idx,laneid in enumerate(lanes_ids):
        #ax.set_xlim([min(lanes_marks_coors[laneid]), max(lanes_marks_coors[laneid])])
        ax.set_xlim([-.5, .5])
        #ax.legend()
        ax.set_xlabel('lateral location y ( m )')
        ax.set_ylabel('probability')
        ax.grid()
        
        plt.tight_layout()
        
        return ax


    @classmethod
    def plot_marginal_distribution_EASL(self, snapshots, roadlength, lanes_marks_coors,ax = False, figsize = (5,3), alpha = .4, n_xs_marginal = 10, tolerance_x_find_y = 1.0, bins = 20, lw = 3.5, vehiclewidth = veh_paras['width']):
        """
        plot the xy and the p(y | x), i.e. the marginal distribution. 
        
        
        @input: STATES
        
                #SNAPSHOT
                self.snapshots[T]['vehs_at_lanes'] = copy.deepcopy(self.vehs_at_lanes)
                self.snapshots[T][vid] = {'S':copy.deepcopy(self.vehs_dict[vid]), \
                    #'feasibleincrement':copy.deepcopy(feasible_increment), \
                    'L':copy.deepcopy(L_dicts[vid]), \
                    'F':copy.deepcopy(F_dicts[vid]), \
                    'vehs_info_within_area_left':copy.deepcopy(vehs_info_within_area_left_dict[vid]), \
                    'vehs_info_within_area_right':copy.deepcopy(vehs_info_within_area_right_dict[vid]), \
                    'potentials':copy.deepcopy(potentials_dict[vid]), }
        
        @input: lanes_marks_coors
        
            {0: (10.2, 13.7),
             1: (6.699999999999999, 10.2),
             2: (3.4999999999999996, 6.699999999999999),
             3: (0.0, 3.5)}
        
        @input: tolerance_x_find_y
        
            given x0, when finding y, the method is that:
            
                - find the idx that with x sasitf abs(x-x0)<tolerance_x_find_y
                - get the y. 
        
        @input: n_xs_marginal
        
            the number of the marginals to be calculated and plotted. 
        
        """
        #
        xs_marginals  = np.linspace(1, roadlength-1, n_xs_marginal)
        t = sorted(snapshots.keys())[0]
        lanes_ids = snapshots[t]['vehs_at_lanes'].keys()
        lanes_number = len(snapshots[t]['vehs_at_lanes'])
        #---------------------------------------------------
        if isinstance(ax, bool):
            fig,ax = plt.subplots(figsize = figsize, ncols = 1, nrows = 1)
            #ax.set_xlabel('x');ax.set_ylabel('y'); 
            #ax.grid();
            #ax = host_subplot(111)
            #par = ax.twinx()
            #fig,ax = plt.subplots(figsize = figsize, nrows = 1, ncols = 1)
        ##############################First plot
        #############################second plot
        
            
            #
        for idx,laneid in enumerate(lanes_ids):
            color = np.random.uniform(size = (3,))
            for x in xs_marginals:
                ys = []
                for t in sorted(snapshots.keys()):
                    
                    for vid in snapshots[t]['vehs_at_lanes'][laneid]:
                        #print()
                        if abs(snapshots[t][vid]['S'][0] - x)<=tolerance_x_find_y:
                            ys.append(snapshots[t][vid]['S'][2])
                #normalize the ys
                ys = np.array(ys) - (min(lanes_marks_coors[laneid]) + max(lanes_marks_coors[laneid]))/2.0
                ys = ys/(- min(lanes_marks_coors[laneid]) + max(lanes_marks_coors[laneid]))
                
                #
                hist, edges = np.histogram(ys, bins = bins)
                #
                new_edges,new_hists = TwoDimMicroModel.ConvertLateralDistribution2ESAL(edges[1:],hist, vehiclewidth =vehiclewidth/lw)
                #
                ax.plot(new_edges, new_hists, label = 'loc = ' + str(int(x*100)/100.0) + ' m', color  = color)
                #ax.plot(edges[1:], hist/sum(hist)/(edges[-1] - edges[-2]), label = 'loc = ' + str(int(x*100)/100.0) + ' m', color  = color)
        
        #--------------------------------------
        #for idx,laneid in enumerate(lanes_ids):
        #ax.set_xlim([min(lanes_marks_coors[laneid]), max(lanes_marks_coors[laneid])])
        ax.set_xlim([-.5, .5])
        #ax.legend()
        ax.set_xlabel('lateral location y ( m )')
        ax.set_ylabel('probability')
        ax.grid()
        
        plt.tight_layout()
        
        return ax
    

    """
            #for t in sorted(snapshots.keys()):
                #print(enumerate(snapshots[t]['vehs_at_lanes'].keys()))
                #for idx,laneid in enumerate(snapshots[t]['vehs_at_lanes'].keys()):
    
    
    """


    
    @classmethod
    def plot_sim_marginal_distribution(self, snapshots, roadlength, lanes_marks_coors,ax = False, figsize = (5,3), alpha = .4, n_xs_marginal = 10, tolerance_x_find_y = 1.0, bins = 20):
        """
        plot the xy and the p(y | x), i.e. the marginal distribution. 
        
        
        @input: STATES
        
                #SNAPSHOT
                self.snapshots[T]['vehs_at_lanes'] = copy.deepcopy(self.vehs_at_lanes)
                self.snapshots[T][vid] = {'S':copy.deepcopy(self.vehs_dict[vid]), \
                    #'feasibleincrement':copy.deepcopy(feasible_increment), \
                    'L':copy.deepcopy(L_dicts[vid]), \
                    'F':copy.deepcopy(F_dicts[vid]), \
                    'vehs_info_within_area_left':copy.deepcopy(vehs_info_within_area_left_dict[vid]), \
                    'vehs_info_within_area_right':copy.deepcopy(vehs_info_within_area_right_dict[vid]), \
                    'potentials':copy.deepcopy(potentials_dict[vid]), }
        
        @input: lanes_marks_coors
        
            {0: (10.2, 13.7),
             1: (6.699999999999999, 10.2),
             2: (3.4999999999999996, 6.699999999999999),
             3: (0.0, 3.5)}
        
        @input: tolerance_x_find_y
        
            given x0, when finding y, the method is that:
            
                - find the idx that with x sasitf abs(x-x0)<tolerance_x_find_y
                - get the y. 
        
        @input: n_xs_marginal
        
            the number of the marginals to be calculated and plotted. 
        
        """
        #
        xs_marginals  = np.linspace(1, roadlength-1, n_xs_marginal)
        t = sorted(snapshots.keys())[0]
        lanes_ids = snapshots[t]['vehs_at_lanes'].keys()
        lanes_number = len(snapshots[t]['vehs_at_lanes'])
        #---------------------------------------------------
        if isinstance(ax, bool):
            fig,axs = plt.subplots(figsize = figsize, ncols = 1, nrows = lanes_number)
            #ax.set_xlabel('x');ax.set_ylabel('y'); 
            #ax.grid();
            #ax = host_subplot(111)
            #par = ax.twinx()
            #fig,ax = plt.subplots(figsize = figsize, nrows = 1, ncols = 1)
        ##############################First plot
        #############################second plot
        ax = axs[1]
        for x in xs_marginals:
            
            #
            for idx,laneid in enumerate(lanes_ids):
                ys = []
                for t in sorted(snapshots.keys()):
                    
                    for vid in snapshots[t]['vehs_at_lanes'][laneid]:
                        #print()
                        if abs(snapshots[t][vid]['S'][0] - x)<=tolerance_x_find_y:
                            ys.append(snapshots[t][vid]['S'][2])
                #
                hist, edges = np.histogram(ys, bins = bins)
                axs[idx].plot(edges[1:], hist/sum(hist)/(edges[-1] - edges[-2]), label = 'loc = ' + str(int(x*100)/100.0) + ' m')
        
        #--------------------------------------
        for idx,laneid in enumerate(lanes_ids):
            axs[idx].set_xlim([min(lanes_marks_coors[laneid]), max(lanes_marks_coors[laneid])])
            axs[idx].legend()
            axs[idx].set_xlabel('lateral location y ( m )')
            axs[idx].set_ylabel('probability')
            axs[idx].grid()
        
        plt.tight_layout()
        
        return axs
    

    """
            #for t in sorted(snapshots.keys()):
                #print(enumerate(snapshots[t]['vehs_at_lanes'].keys()))
                #for idx,laneid in enumerate(snapshots[t]['vehs_at_lanes'].keys()):
    
    
    """

    def sim_insert_vehs_at_once_MIXED_AVS(self, deltat_sec =.5, T_horizon_sec = 3600.0, \
        desired_density = 100, \
        inserted_initial_state = np.array([.0, .0, .0, 0, .0, .0]), \
        safety_gap2downstream_when_insert = 10, \
        safety_gap2upstream_when_insert = 10,  \
        idm_paras = idm_paras, \
        stochastic_proecess_name = 'converted', \
        two_dim_paras_HDV = two_dim_paras, \
        two_dim_paras_AV = two_dim_paras_AV,
        idm_paras_AV = idm_paras_AV,\
        idm_paras_HDV = idm_paras, \
        leader_state_infinity = np.array([1e10, .0, .0, 0, .0, .0]), \
        ellipse_x_min = 10, \
        ellipse_x_max = 60, \
        intert_tolerance = 1e-1, \
        with_neighboring_influence = True, \
        MPRs_list = [.1, .3, .4, .5], \
        lanemark_force_type = 'exponential' ):
        """
        Inseert all vehicles at the initial moment. 
        
        ------------------------------------
        
        @input: lanemark_force_type
        
            either 'parabolic' or 'exponential'
        
        
        @input: MPRs_list
            
            the MPR of the AVs. 
            
            The length of MPR_list MUST BE the same as self.lanes_ids：
            
                len(MPRs_list)=len(self.lane_ids)
            
        
        @input: desired_density
            
            the desired density. unit is veh/km.
        
        @input: deltat_sec
        
            the time step, unit is sec. 
        
        @input: inserted_initial_state
        
            inserted_initial_state = [x, vx, y ,vy, zlon, zlat]
        
        @input: safety_gap2downstream_when_insert and safety_gap2upstream_when_insert
            
            both are float. WHen the inser. 
        
        @input: leader_state_infinity
        
            if there is only one vehicle and then the leader locates at infunity. 
        
        @OUTPUTS: STATES
        
            STATES[moment][vid] = state
        
        --------------------------
        @STEPS:
        
            
        """
        #
        if len(MPRs_list)!=len(self.lanes_ids):
            print(len(MPRs_list), '-----------', len(self.lanes_ids))
            raise ValueError('sffsdfsadfsadf')
        #
        #
        STATES = {}
        self.snapshots = {}
        #
        ######################################Insert vehicles.
        #kjam unit is veh/km
        kjam =  1000.0/(idm_paras['idm_s0'] + idm_paras['veh_len'])
        vehs_number = int(max(1, min(desired_density/1000.0*(self.length-1), (self.length-1)/1000.0*kjam)))
        space = (self.length-10.0)/vehs_number
        #
        locs_inserted = [15]
        for i in range(vehs_number):
            tmp = locs_inserted[-1] + space
            if tmp<self.length:
                locs_inserted.append(tmp)
            else:
                break
        #print(locs_inserted)
        equilibrium_v = TwoDimMicroModel.IDM_equilibrium_v_from_deltax(deltax = space)
        #----------------------------
        for idx_lane,lane_id in enumerate(self.lanes_ids):
            for i,loc in enumerate(locs_inserted):
                #
                vid_new = len(self.vehs_dict)#uuid.uuid1()
                #
                inserted_initial_state0 =  inserted_initial_state
                inserted_initial_state0[0] = loc
                inserted_initial_state0[1] = equilibrium_v
                inserted_initial_state0[2] = self.lanes_middle_line[lane_id]
                #
                if np.random.uniform()<MPRs_list[idx_lane]:
                    self.vehs_two_dim_paras[vid_new] = copy.deepcopy(two_dim_paras_AV)
                    self.vehs_idm_paras[vid_new] = copy.deepcopy(idm_paras_AV)
                else:
                    self.vehs_two_dim_paras[vid_new] = copy.deepcopy(two_dim_paras_HDV)
                    self.vehs_idm_paras[vid_new] = copy.deepcopy(idm_paras_HDV)
                
                #
                self.vehs_dict[vid_new] = copy.deepcopy(inserted_initial_state0)
                self.vehs_at_lanes[lane_id].append(vid_new)
                #self.vehs_at_lanes[lane_id].insert(0, vid_new)
                self.vehs_target_lane[vid_new] = lane_id
        #
        ##################################RUN
        T = 0
        while T<T_horizon_sec:
            self.snapshots[T] = {}
            #################################Microscopic traffic flow model
            #calcualte F and L. keys are the vehicle ids. 
            #   F_dicts[vid] is a 1d array. 
            #   L_dicts[vid] is a N*2 array. 2 means lon and lat noise. 
            F_dicts = {}
            L_dicts = {}
            vehs_info_within_area_left_dict = {}
            vehs_info_within_area_right_dict = {}
            leader_state_dict = {}
            potentials_dict = {}
            #for laneid in self.lanes_ids:
            for idx_lane,laneid in enumerate(self.lanes_ids):
                #------------------------------------------------------
                #------------------------------------------------------
                #idx_lane = 0 means leftmost lane, rightbound not exit and left mark force not exist. 
                if idx_lane==0:
                    left_mark_force = False
                    right_bound_force = False
                    #
                    right_mark_force = True
                    left_bound_force = True
                #idx_lane==len(road_attrs['lanes_ids'])-1 means RIGHTMOST lane. 
                elif idx_lane==len(self.lanes_ids)-1:
                    right_mark_force = False
                    left_bound_force = False
                    #
                    left_mark_force = True
                    right_bound_force = True
                else:
                    right_mark_force = True
                    left_mark_force = True
                    #
                    left_bound_force = False
                    right_bound_force = False

                #----------------find the vehs_info_within_area. 
                for i,vid in enumerate(self.vehs_at_lanes[laneid]):
                    # ----------------------------
                    ego_state = self.vehs_dict[vid]
                    #
                    #=========================================FInd the leader
                    #find the leader and the lateral vehicles. 
                    #   if there is only one vehicle
                    if len(self.vehs_at_lanes[laneid])==1:
                        leader_state = copy.deepcopy(ego_state)
                        leader_state[0] = ego_state[0]+1e10
                    else:
                        #if the vehicle is the most downstream vehicle in the road. 
                        if i==len(self.vehs_at_lanes[laneid])-1:
                            #
                            leader_id = self.vehs_at_lanes[laneid][0]
                            leader_state = copy.deepcopy(self.vehs_dict[leader_id])
                            leader_state[0] = leader_state[0] + self.length
                            #
                        else:
                            leader_id = self.vehs_at_lanes[laneid][i+1]
                            leader_state = copy.deepcopy(self.vehs_dict[leader_id])
                        #------------------search leader at ego lane. 
                    leader_state_dict[vid] = copy.deepcopy(leader_state)
                    #
                    #==============================================Find the lateral vehicles.
                    #============================================They will be stored in vehs_info_within_area_left and vehs_info_within_area_right
                    #find the lateral vehicles within influence areas, which is store
                    #ellipse_x = self.ellipse_x(ego_state  = ego_state)
                    ellipse_x = self.ellipse_x(ego_state  = ego_state, a_x_MAX = idm_paras['idm_a'], ellipse_x_min = ellipse_x_min, ellipse_x_max = ellipse_x_max)
                    #
                    if laneid==self.lanes_ids[0]:
                        left_lanes_vids = []
                    else:
                        left_lanes_vids = self.vehs_at_lanes[self.left_lane_id[laneid]]
                    if laneid==self.lanes_ids[-1]:
                        right_lanes_vids = []
                    else:
                        right_lanes_vids = self.vehs_at_lanes[self.right_lane_id[laneid]]
                    #vehs_info_within_area_left is a dict. 
                    #print(right_lanes_vids, '---')
                    vehs_info_within_area_left,vehs_info_within_area_right = self.search_vehs_within_ellise(ego_state = ego_state, \
                        ellipse_x = ellipse_x, \
                        ellipse_y_left = self.ellipse_y_left[laneid],  \
                        ellipse_y_right = self.ellipse_y_right[laneid] ,  \
                        left_lanes_vids = left_lanes_vids, \
                        right_lanes_vids = right_lanes_vids, \
                        vehs_info_dict = self.vehs_dict, road_length  = self.length)
                    #print(vehs_info_within_area_right.keys(), '---')
                    #
                    vehs_info_within_area_left_dict[vid] = vehs_info_within_area_left
                    vehs_info_within_area_right_dict[vid] = vehs_info_within_area_right
                    #
                    #============================================Calculate F and L
                    #--------------calculate the F and L
                    #   F_dicts[vid] is a 1d array. 
                    F_dicts[vid],potentials_dict[vid] = TwoDimMicroModel.F(ego_state  = ego_state, \
                        ego_lane_lw = self.lws_dict[laneid], \
                        ego_lane_middle_line_coor = self.lanes_middle_line[laneid], \
                        ego_lane_marks_coor = self.lanes_marks_coors[laneid], \
                        road_bounds = self.road_bounds, \
                        lw_boundary_lanes = self.lw_boundary_lanes, \
                        leader_state = leader_state, \
                        ellipse_x = ellipse_x, \
                        ellipse_y_left = self.ellipse_y_left[laneid],  \
                        ellipse_y_right = self.ellipse_y_right[laneid] ,  \
                        vehs_info_within_area_left = copy.deepcopy(vehs_info_within_area_left), \
                        vehs_info_within_area_right = copy.deepcopy(vehs_info_within_area_right), \
                        two_dim_paras = self.vehs_two_dim_paras[vid], \
                        idm_paras = self.vehs_idm_paras[vid], \
                        stochastic_proecess_name = stochastic_proecess_name, \
                        right_mark_force = right_mark_force,  \
                        left_bound_force = left_bound_force, \
                        left_mark_force = left_mark_force, 
                        right_bound_force = right_bound_force, \
                        with_neighboring_influence = with_neighboring_influence, \
                        lanemark_force_type  = lanemark_force_type)
                    #
                    L_dicts[vid] = TwoDimMicroModel.L(state  = ego_state, \
                        two_dim_paras = self.vehs_two_dim_paras[vid], \
                        idm_paras = self.vehs_idm_paras[vid], \
                        stochastic_proecess_name = stochastic_proecess_name)
                    
            ################################UPDATE
            #for vid in self.vehs_dict.keys():
            for idx_lane,laneid in enumerate(self.lanes_ids):
                for i,vid in enumerate(self.vehs_at_lanes[laneid]):
                    #
                    brownian = np.random.normal(loc = np.zeros((2,)), scale = deltat_sec)
                    #
                    #
                    #print(self.vehs_dict[vid], vid in F_dicts, vid in L_dicts)
                    new_state,feasible_increment = self.TrimUpdate(old_state = self.vehs_dict[vid], deltat_sec = deltat_sec, F = F_dicts[vid], L = L_dicts[vid], brownian = brownian, idm_paras = idm_paras)
                    #new_state = F_dicts[vid] + np.matmul(L_dicts[vid], brownian/deltat_sec)
                    
                    #
                    #print(F_dicts[vid].shape, np.matmul(L_dicts[vid], brownian).shape)
                    #new_state = self.vehs_dict[vid] + F_dicts[vid]*deltat_sec + np.matmul(L_dicts[vid], brownian)
                    #---------------------UPDATE systen variables. 
                    #SNAPSHOT
                    self.snapshots[T]['vehs_at_lanes'] = copy.deepcopy(self.vehs_at_lanes)
                    self.snapshots[T][vid] = {'S':copy.deepcopy(self.vehs_dict[vid]), \
                        #'feasibleincrement':copy.deepcopy(feasible_increment), \
                        'L':copy.deepcopy(L_dicts[vid]), \
                        'F':copy.deepcopy(F_dicts[vid]), \
                        'vehs_info_within_area_left':copy.deepcopy(vehs_info_within_area_left_dict[vid]), \
                        'vehs_info_within_area_right':copy.deepcopy(vehs_info_within_area_right_dict[vid]), \
                        'potentials':copy.deepcopy(potentials_dict[vid]), }
                    #
                    #==================================================
                    if new_state[0]>=self.length:
                        #-----------Change state
                        new_state[0] = new_state[0] - self.length
                        #print(new_state.shape)
                        self.vehs_dict[vid] = copy.deepcopy(new_state)
                        #-----------Change the vehicle order. 
                        tmp = copy.deepcopy([self.vehs_at_lanes[laneid][-1]] + self.vehs_at_lanes[laneid][:-1])
                        self.vehs_at_lanes[laneid] = tmp
                    else:
                        #print(new_state.shape)
                        self.vehs_dict[vid] = new_state
                #
            #############################RECORD the state
            STATES[T] = copy.deepcopy(self.vehs_dict)
            
            #
            T = T + deltat_sec
            #builtins.tmp = STATES
        
        return STATES



    def sim_insert_vehs_at_once_MIXED_AVS_lw_base(self, deltat_sec =.5, T_horizon_sec = 3600.0, \
        desired_density = 100, \
        inserted_initial_state = np.array([.0, .0, .0, 0, .0, .0]), \
        safety_gap2downstream_when_insert = 10, \
        safety_gap2upstream_when_insert = 10,  \
        idm_paras = idm_paras, \
        stochastic_proecess_name = 'converted', \
        two_dim_paras_HDV = two_dim_paras, \
        two_dim_paras_AV = two_dim_paras_AV,
        idm_paras_AV = idm_paras_AV,\
        idm_paras_HDV = idm_paras, \
        leader_state_infinity = np.array([1e10, .0, .0, 0, .0, .0]), \
        ellipse_x_min = 10, \
        ellipse_x_max = 60, \
        intert_tolerance = 1e-1, \
        with_neighboring_influence = True, \
        MPRs_list = [.1, .3, .4, .5], \
        lanemark_force_type = 'exponential' , lw_base = 3.5):
        """
        Inseert all vehicles at the initial moment. 
        
        ------------------------------------
        @input: lw_base
        
            a float. 
            
            THis parameter is used is because:
            
                - the conventional algirithm cannot describe the lane width influence. 
        
            It only influences the potential.  
        
        
        @input: lanemark_force_type
        
            either 'parabolic' or 'exponential'
        
        
        @input: MPRs_list
            
            the MPR of the AVs. 
            
            The length of MPR_list MUST BE the same as self.lanes_ids：
            
                len(MPRs_list)=len(self.lane_ids)
            
        
        @input: desired_density
            
            the desired density. unit is veh/km.
        
        @input: deltat_sec
        
            the time step, unit is sec. 
        
        @input: inserted_initial_state
        
            inserted_initial_state = [x, vx, y ,vy, zlon, zlat]
        
        @input: safety_gap2downstream_when_insert and safety_gap2upstream_when_insert
            
            both are float. WHen the inser. 
        
        @input: leader_state_infinity
        
            if there is only one vehicle and then the leader locates at infunity. 
        
        @OUTPUTS: STATES
        
            STATES[moment][vid] = state
        
        --------------------------
        @STEPS:
        
            
        """
        #
        if len(MPRs_list)!=len(self.lanes_ids):
            print(len(MPRs_list), '-----------', len(self.lanes_ids))
            raise ValueError('sffsdfsadfsadf')
        #
        #
        STATES = {}
        self.snapshots = {}
        #
        ######################################Insert vehicles.
        #kjam unit is veh/km
        kjam =  1000.0/(idm_paras['idm_s0'] + idm_paras['veh_len'])
        vehs_number = int(max(1, min(desired_density/1000.0*(self.length-1), (self.length-1)/1000.0*kjam)))
        space = (self.length-10.0)/vehs_number
        #
        locs_inserted = [15]
        for i in range(vehs_number):
            tmp = locs_inserted[-1] + space
            if tmp<self.length:
                locs_inserted.append(tmp)
            else:
                break
        #print(locs_inserted)
        equilibrium_v = TwoDimMicroModel.IDM_equilibrium_v_from_deltax(deltax = space)
        #----------------------------
        for idx_lane,lane_id in enumerate(self.lanes_ids):
            for i,loc in enumerate(locs_inserted):
                #
                vid_new = len(self.vehs_dict)#uuid.uuid1()
                #
                inserted_initial_state0 =  inserted_initial_state
                inserted_initial_state0[0] = loc
                inserted_initial_state0[1] = equilibrium_v
                inserted_initial_state0[2] = self.lanes_middle_line[lane_id]
                #
                if np.random.uniform()<MPRs_list[idx_lane]:
                    self.vehs_two_dim_paras[vid_new] = copy.deepcopy(two_dim_paras_AV)
                    self.vehs_idm_paras[vid_new] = copy.deepcopy(idm_paras_AV)
                else:
                    self.vehs_two_dim_paras[vid_new] = copy.deepcopy(two_dim_paras_HDV)
                    self.vehs_idm_paras[vid_new] = copy.deepcopy(idm_paras_HDV)
                
                #
                self.vehs_dict[vid_new] = copy.deepcopy(inserted_initial_state0)
                self.vehs_at_lanes[lane_id].append(vid_new)
                #self.vehs_at_lanes[lane_id].insert(0, vid_new)
                self.vehs_target_lane[vid_new] = lane_id
        #
        ##################################RUN
        T = 0
        while T<T_horizon_sec:
            self.snapshots[T] = {}
            #################################Microscopic traffic flow model
            #calcualte F and L. keys are the vehicle ids. 
            #   F_dicts[vid] is a 1d array. 
            #   L_dicts[vid] is a N*2 array. 2 means lon and lat noise. 
            F_dicts = {}
            L_dicts = {}
            vehs_info_within_area_left_dict = {}
            vehs_info_within_area_right_dict = {}
            leader_state_dict = {}
            potentials_dict = {}
            #for laneid in self.lanes_ids:
            for idx_lane,laneid in enumerate(self.lanes_ids):
                #------------------------------------------------------
                #------------------------------------------------------
                #idx_lane = 0 means leftmost lane, rightbound not exit and left mark force not exist. 
                if idx_lane==0:
                    left_mark_force = False
                    right_bound_force = False
                    #
                    right_mark_force = True
                    left_bound_force = True
                #idx_lane==len(road_attrs['lanes_ids'])-1 means RIGHTMOST lane. 
                elif idx_lane==len(self.lanes_ids)-1:
                    right_mark_force = False
                    left_bound_force = False
                    #
                    left_mark_force = True
                    right_bound_force = True
                else:
                    right_mark_force = True
                    left_mark_force = True
                    #
                    left_bound_force = False
                    right_bound_force = False

                #----------------find the vehs_info_within_area. 
                for i,vid in enumerate(self.vehs_at_lanes[laneid]):
                    # ----------------------------
                    ego_state = self.vehs_dict[vid]
                    #
                    #=========================================FInd the leader
                    #find the leader and the lateral vehicles. 
                    #   if there is only one vehicle
                    if len(self.vehs_at_lanes[laneid])==1:
                        leader_state = copy.deepcopy(ego_state)
                        leader_state[0] = ego_state[0]+1e10
                    else:
                        #if the vehicle is the most downstream vehicle in the road. 
                        if i==len(self.vehs_at_lanes[laneid])-1:
                            #
                            leader_id = self.vehs_at_lanes[laneid][0]
                            leader_state = copy.deepcopy(self.vehs_dict[leader_id])
                            leader_state[0] = leader_state[0] + self.length
                            #
                        else:
                            leader_id = self.vehs_at_lanes[laneid][i+1]
                            leader_state = copy.deepcopy(self.vehs_dict[leader_id])
                        #------------------search leader at ego lane. 
                    leader_state_dict[vid] = copy.deepcopy(leader_state)
                    #
                    #==============================================Find the lateral vehicles.
                    #============================================They will be stored in vehs_info_within_area_left and vehs_info_within_area_right
                    #find the lateral vehicles within influence areas, which is store
                    #ellipse_x = self.ellipse_x(ego_state  = ego_state)
                    ellipse_x = self.ellipse_x(ego_state  = ego_state, a_x_MAX = idm_paras['idm_a'], ellipse_x_min = ellipse_x_min, ellipse_x_max = ellipse_x_max)
                    #
                    if laneid==self.lanes_ids[0]:
                        left_lanes_vids = []
                    else:
                        left_lanes_vids = self.vehs_at_lanes[self.left_lane_id[laneid]]
                    if laneid==self.lanes_ids[-1]:
                        right_lanes_vids = []
                    else:
                        right_lanes_vids = self.vehs_at_lanes[self.right_lane_id[laneid]]
                    #vehs_info_within_area_left is a dict. 
                    #print(right_lanes_vids, '---')
                    vehs_info_within_area_left,vehs_info_within_area_right = self.search_vehs_within_ellise(ego_state = ego_state, \
                        ellipse_x = ellipse_x, \
                        ellipse_y_left = self.ellipse_y_left[laneid],  \
                        ellipse_y_right = self.ellipse_y_right[laneid] ,  \
                        left_lanes_vids = left_lanes_vids, \
                        right_lanes_vids = right_lanes_vids, \
                        vehs_info_dict = self.vehs_dict, road_length  = self.length)
                    #print(vehs_info_within_area_right.keys(), '---')
                    #
                    vehs_info_within_area_left_dict[vid] = vehs_info_within_area_left
                    vehs_info_within_area_right_dict[vid] = vehs_info_within_area_right
                    #
                    #============================================Calculate F and L
                    #--------------calculate the F and L
                    #   F_dicts[vid] is a 1d array. 
                    F_dicts[vid],potentials_dict[vid] = TwoDimMicroModel.F_lw_base(ego_state  = ego_state, \
                        ego_lane_lw = self.lws_dict[laneid], \
                        ego_lane_middle_line_coor = self.lanes_middle_line[laneid], \
                        ego_lane_marks_coor = self.lanes_marks_coors[laneid], \
                        road_bounds = self.road_bounds, \
                        lw_boundary_lanes = self.lw_boundary_lanes, \
                        leader_state = leader_state, \
                        ellipse_x = ellipse_x, \
                        ellipse_y_left = self.ellipse_y_left[laneid],  \
                        ellipse_y_right = self.ellipse_y_right[laneid] ,  \
                        vehs_info_within_area_left = copy.deepcopy(vehs_info_within_area_left), \
                        vehs_info_within_area_right = copy.deepcopy(vehs_info_within_area_right), \
                        two_dim_paras = self.vehs_two_dim_paras[vid], \
                        idm_paras = self.vehs_idm_paras[vid], \
                        stochastic_proecess_name = stochastic_proecess_name, \
                        right_mark_force = right_mark_force,  \
                        left_bound_force = left_bound_force, \
                        left_mark_force = left_mark_force, 
                        right_bound_force = right_bound_force, \
                        with_neighboring_influence = with_neighboring_influence, \
                        lanemark_force_type  = lanemark_force_type, lw_base = lw_base)
                    #
                    L_dicts[vid] = TwoDimMicroModel.L(state  = ego_state, \
                        two_dim_paras = self.vehs_two_dim_paras[vid], \
                        idm_paras = self.vehs_idm_paras[vid], \
                        stochastic_proecess_name = stochastic_proecess_name)
                    
            ################################UPDATE
            #for vid in self.vehs_dict.keys():
            for idx_lane,laneid in enumerate(self.lanes_ids):
                for i,vid in enumerate(self.vehs_at_lanes[laneid]):
                    #
                    brownian = np.random.normal(loc = np.zeros((2,)), scale = deltat_sec)
                    #
                    #
                    #print(self.vehs_dict[vid], vid in F_dicts, vid in L_dicts)
                    new_state,feasible_increment = self.TrimUpdate(old_state = self.vehs_dict[vid], deltat_sec = deltat_sec, F = F_dicts[vid], L = L_dicts[vid], brownian = brownian, idm_paras = idm_paras)
                    #new_state = F_dicts[vid] + np.matmul(L_dicts[vid], brownian/deltat_sec)
                    
                    #
                    #print(F_dicts[vid].shape, np.matmul(L_dicts[vid], brownian).shape)
                    #new_state = self.vehs_dict[vid] + F_dicts[vid]*deltat_sec + np.matmul(L_dicts[vid], brownian)
                    #---------------------UPDATE systen variables. 
                    #SNAPSHOT
                    self.snapshots[T]['vehs_at_lanes'] = copy.deepcopy(self.vehs_at_lanes)
                    self.snapshots[T][vid] = {'S':copy.deepcopy(self.vehs_dict[vid]), \
                        #'feasibleincrement':copy.deepcopy(feasible_increment), \
                        'L':copy.deepcopy(L_dicts[vid]), \
                        'F':copy.deepcopy(F_dicts[vid]), \
                        'vehs_info_within_area_left':copy.deepcopy(vehs_info_within_area_left_dict[vid]), \
                        'vehs_info_within_area_right':copy.deepcopy(vehs_info_within_area_right_dict[vid]), \
                        'potentials':copy.deepcopy(potentials_dict[vid]), }
                    #
                    #==================================================
                    if new_state[0]>=self.length:
                        #-----------Change state
                        new_state[0] = new_state[0] - self.length
                        #print(new_state.shape)
                        self.vehs_dict[vid] = copy.deepcopy(new_state)
                        #-----------Change the vehicle order. 
                        tmp = copy.deepcopy([self.vehs_at_lanes[laneid][-1]] + self.vehs_at_lanes[laneid][:-1])
                        self.vehs_at_lanes[laneid] = tmp
                    else:
                        #print(new_state.shape)
                        self.vehs_dict[vid] = new_state
                #
            #############################RECORD the state
            STATES[T] = copy.deepcopy(self.vehs_dict)
            
            #
            T = T + deltat_sec
            #builtins.tmp = STATES
        
        return STATES






    def sim_insert_vehs_at_once_MIXED_AVS_lanewise_desiredensiy(self, deltat_sec =.5, T_horizon_sec = 3600.0, \
        inserted_initial_state = np.array([.0, .0, .0, 0, .0, .0]), \
        safety_gap2downstream_when_insert = 10, \
        safety_gap2upstream_when_insert = 10,  \
        stochastic_proecess_name = 'converted', \
        two_dim_paras_HDV = two_dim_paras, \
        two_dim_paras_AV = two_dim_paras_AV,
        idm_paras_AV = idm_paras_AV,\
        idm_paras_HDV = idm_paras, \
        leader_state_infinity = np.array([1e10, .0, .0, 0, .0, .0]), \
        ellipse_x_min = 10, \
        ellipse_x_max = 60, \
        intert_tolerance = 1e-1, \
        with_neighboring_influence = True, \
        MPRs_list = [.1, .3, .4, .5], \
        desireddensities = [20, 30, 30, 30], \
        lanemark_force_type = 'exponential' ):
        """
        Inseert all vehicles at the initial moment. 
        
        Difference: 
            - self.sim_insert_vehs_at_once_MIXED_AVS_lanewise_desiredensiy()
            - self.sim_insert_vehs_at_once_MIXED_AVS()
        
        The former one allows different desird density for different lanes. 
        
        
        ------------------------------------
        
        @input: lanemark_force_type
        
            either 'parabolic' or 'exponential'
        
        
        @input: MPRs_list
            
            the MPR of the AVs. 
            
            The length of MPR_list MUST BE the same as self.lanes_ids：
            
                len(MPRs_list)=len(self.lane_ids)
            
        
        @input: desired_density
            
            the desired density. unit is veh/km.
        
        @input: deltat_sec
        
            the time step, unit is sec. 
        
        @input: inserted_initial_state
        
            inserted_initial_state = [x, vx, y ,vy, zlon, zlat]
        
        @input: safety_gap2downstream_when_insert and safety_gap2upstream_when_insert
            
            both are float. WHen the inser. 
        
        @input: leader_state_infinity
        
            if there is only one vehicle and then the leader locates at infunity. 
        
        @OUTPUTS: STATES
        
            STATES[moment][vid] = state
        
        --------------------------
        @STEPS:
        
            
        """
        #
        if len(MPRs_list)!=len(self.lanes_ids):
            print(len(MPRs_list), '-----------', len(self.lanes_ids))
            raise ValueError('sffsdfsadfsadf')
        if len(desireddensities)!=len(self.lanes_ids):
            print(len(MPRs_list), '-----------', len(self.lanes_ids))
            raise ValueError('sffsdfsadfsadf')
        #
        #
        STATES = {}
        self.snapshots = {}
        #
        ######################################INSERT VEHICLES
        #kjam unit is veh/km
        kjam =  1000.0/(idm_paras['idm_s0'] + idm_paras['veh_len'])
        
        #----------------------------
        for idx_lane,(lane_id,desired_density) in enumerate(zip(self.lanes_ids,desireddensities)):
            #------------Calculate the equilibrium_v and the locs_inserted
            vehs_number = int(max(1, min(desired_density/1000.0*(self.length-1), (self.length-1)/1000.0*kjam)))
            space = (self.length-10.0)/vehs_number
            #
            locs_inserted = [10]
            for i in range(vehs_number):
                tmp = locs_inserted[-1] + space
                if tmp<self.length:
                    locs_inserted.append(tmp)
                else:
                    break
            #print(locs_inserted)
            equilibrium_v = TwoDimMicroModel.IDM_equilibrium_v_from_deltax(deltax = space)
            #-------------inset the vehicles. 
            for i,loc in enumerate(locs_inserted):
                #
                vid_new = len(self.vehs_dict)#uuid.uuid1()
                #
                inserted_initial_state0 =  inserted_initial_state
                inserted_initial_state0[0] = loc
                inserted_initial_state0[1] = equilibrium_v
                inserted_initial_state0[2] = self.lanes_middle_line[lane_id]
                #
                if np.random.uniform()<MPRs_list[idx_lane]:
                    self.vehs_two_dim_paras[vid_new] = copy.deepcopy(two_dim_paras_AV)
                    self.vehs_idm_paras[vid_new] = copy.deepcopy(idm_paras_AV)
                else:
                    self.vehs_two_dim_paras[vid_new] = copy.deepcopy(two_dim_paras_HDV)
                    self.vehs_idm_paras[vid_new] = copy.deepcopy(idm_paras_HDV)
                
                #
                self.vehs_dict[vid_new] = copy.deepcopy(inserted_initial_state0)
                self.vehs_at_lanes[lane_id].append(vid_new)
                #self.vehs_at_lanes[lane_id].insert(0, vid_new)
                self.vehs_target_lane[vid_new] = lane_id
        ##############################INSERT VEHICLES END
        
        
        #
        ##################################RUN
        T = 0
        while T<T_horizon_sec:
            self.snapshots[T] = {}
            #################################Microscopic traffic flow model
            #calcualte F and L. keys are the vehicle ids. 
            #   F_dicts[vid] is a 1d array. 
            #   L_dicts[vid] is a N*2 array. 2 means lon and lat noise. 
            F_dicts = {}
            L_dicts = {}
            vehs_info_within_area_left_dict = {}
            vehs_info_within_area_right_dict = {}
            leader_state_dict = {}
            potentials_dict = {}
            #for laneid in self.lanes_ids:
            for idx_lane,laneid in enumerate(self.lanes_ids):
                #------------------------------------------------------
                #------------------------------------------------------
                #idx_lane = 0 means leftmost lane, rightbound not exit and left mark force not exist. 
                if idx_lane==0:
                    left_mark_force = False
                    right_bound_force = False
                    #
                    right_mark_force = True
                    left_bound_force = True
                #idx_lane==len(road_attrs['lanes_ids'])-1 means RIGHTMOST lane. 
                elif idx_lane==len(self.lanes_ids)-1:
                    right_mark_force = False
                    left_bound_force = False
                    #
                    left_mark_force = True
                    right_bound_force = True
                else:
                    right_mark_force = True
                    left_mark_force = True
                    #
                    left_bound_force = False
                    right_bound_force = False

                #----------------find the vehs_info_within_area. 
                for i,vid in enumerate(self.vehs_at_lanes[laneid]):
                    # ----------------------------
                    ego_state = self.vehs_dict[vid]
                    #
                    #=========================================FInd the leader
                    #find the leader and the lateral vehicles. 
                    #   if there is only one vehicle
                    if len(self.vehs_at_lanes[laneid])==1:
                        leader_state = copy.deepcopy(ego_state)
                        leader_state[0] = ego_state[0]+1e10
                    else:
                        #if the vehicle is the most downstream vehicle in the road. 
                        if i==len(self.vehs_at_lanes[laneid])-1:
                            #
                            leader_id = self.vehs_at_lanes[laneid][0]
                            leader_state = copy.deepcopy(self.vehs_dict[leader_id])
                            leader_state[0] = leader_state[0] + self.length
                            #
                        else:
                            leader_id = self.vehs_at_lanes[laneid][i+1]
                            leader_state = copy.deepcopy(self.vehs_dict[leader_id])
                        #------------------search leader at ego lane. 
                    leader_state_dict[vid] = copy.deepcopy(leader_state)
                    #
                    #==============================================Find the lateral vehicles.
                    #============================================They will be stored in vehs_info_within_area_left and vehs_info_within_area_right
                    #find the lateral vehicles within influence areas, which is store
                    #ellipse_x = self.ellipse_x(ego_state  = ego_state)
                    ellipse_x = self.ellipse_x(ego_state  = ego_state, a_x_MAX = idm_paras['idm_a'], ellipse_x_min = ellipse_x_min, ellipse_x_max = ellipse_x_max)
                    #
                    if laneid==self.lanes_ids[0]:
                        left_lanes_vids = []
                    else:
                        left_lanes_vids = self.vehs_at_lanes[self.left_lane_id[laneid]]
                    if laneid==self.lanes_ids[-1]:
                        right_lanes_vids = []
                    else:
                        right_lanes_vids = self.vehs_at_lanes[self.right_lane_id[laneid]]
                    #vehs_info_within_area_left is a dict. 
                    #print(right_lanes_vids, '---')
                    vehs_info_within_area_left,vehs_info_within_area_right = self.search_vehs_within_ellise(ego_state = ego_state, \
                        ellipse_x = ellipse_x, \
                        ellipse_y_left = self.ellipse_y_left[laneid],  \
                        ellipse_y_right = self.ellipse_y_right[laneid] ,  \
                        left_lanes_vids = left_lanes_vids, \
                        right_lanes_vids = right_lanes_vids, \
                        vehs_info_dict = self.vehs_dict, road_length  = self.length)
                    #print(vehs_info_within_area_right.keys(), '---')
                    #
                    vehs_info_within_area_left_dict[vid] = vehs_info_within_area_left
                    vehs_info_within_area_right_dict[vid] = vehs_info_within_area_right
                    #
                    #============================================Calculate F and L
                    #--------------calculate the F and L
                    #   F_dicts[vid] is a 1d array. 
                    F_dicts[vid],potentials_dict[vid] = TwoDimMicroModel.F(ego_state  = ego_state, \
                        ego_lane_lw = self.lws_dict[laneid], \
                        ego_lane_middle_line_coor = self.lanes_middle_line[laneid], \
                        ego_lane_marks_coor = self.lanes_marks_coors[laneid], \
                        road_bounds = self.road_bounds, \
                        lw_boundary_lanes = self.lw_boundary_lanes, \
                        leader_state = leader_state, \
                        ellipse_x = ellipse_x, \
                        ellipse_y_left = self.ellipse_y_left[laneid],  \
                        ellipse_y_right = self.ellipse_y_right[laneid] ,  \
                        vehs_info_within_area_left = copy.deepcopy(vehs_info_within_area_left), \
                        vehs_info_within_area_right = copy.deepcopy(vehs_info_within_area_right), \
                        two_dim_paras = self.vehs_two_dim_paras[vid], \
                        idm_paras = self.vehs_idm_paras[vid], \
                        stochastic_proecess_name = stochastic_proecess_name, \
                        right_mark_force = right_mark_force,  \
                        left_bound_force = left_bound_force, \
                        left_mark_force = left_mark_force, 
                        right_bound_force = right_bound_force, \
                        with_neighboring_influence = with_neighboring_influence, \
                        lanemark_force_type  = lanemark_force_type)
                    #
                    L_dicts[vid] = TwoDimMicroModel.L(state  = ego_state, \
                        two_dim_paras = self.vehs_two_dim_paras[vid], \
                        idm_paras = self.vehs_idm_paras[vid], \
                        stochastic_proecess_name = stochastic_proecess_name)
                    
            ################################UPDATE
            #for vid in self.vehs_dict.keys():
            for idx_lane,laneid in enumerate(self.lanes_ids):
                for i,vid in enumerate(self.vehs_at_lanes[laneid]):
                    #
                    brownian = np.random.normal(loc = np.zeros((2,)), scale = deltat_sec)
                    #
                    #
                    #print(self.vehs_dict[vid], vid in F_dicts, vid in L_dicts)
                    new_state,feasible_increment = self.TrimUpdate(old_state = self.vehs_dict[vid], deltat_sec = deltat_sec, F = F_dicts[vid], L = L_dicts[vid], brownian = brownian, idm_paras = idm_paras)
                    #new_state = F_dicts[vid] + np.matmul(L_dicts[vid], brownian/deltat_sec)
                    
                    #
                    #print(F_dicts[vid].shape, np.matmul(L_dicts[vid], brownian).shape)
                    #new_state = self.vehs_dict[vid] + F_dicts[vid]*deltat_sec + np.matmul(L_dicts[vid], brownian)
                    #---------------------UPDATE systen variables. 
                    #SNAPSHOT
                    self.snapshots[T]['vehs_at_lanes'] = copy.deepcopy(self.vehs_at_lanes)
                    self.snapshots[T][vid] = {'S':copy.deepcopy(self.vehs_dict[vid]), \
                        #'feasibleincrement':copy.deepcopy(feasible_increment), \
                        'L':copy.deepcopy(L_dicts[vid]), \
                        'F':copy.deepcopy(F_dicts[vid]), \
                        'vehs_info_within_area_left':copy.deepcopy(vehs_info_within_area_left_dict[vid]), \
                        'vehs_info_within_area_right':copy.deepcopy(vehs_info_within_area_right_dict[vid]), \
                        'potentials':copy.deepcopy(potentials_dict[vid]), }
                    #
                    #==================================================
                    if new_state[0]>=self.length:
                        #-----------Change state
                        new_state[0] = new_state[0] - self.length
                        #print(new_state.shape)
                        self.vehs_dict[vid] = copy.deepcopy(new_state)
                        #-----------Change the vehicle order. 
                        tmp = copy.deepcopy([self.vehs_at_lanes[laneid][-1]] + self.vehs_at_lanes[laneid][:-1])
                        self.vehs_at_lanes[laneid] = tmp
                    else:
                        #print(new_state.shape)
                        self.vehs_dict[vid] = new_state
                #
            #############################RECORD the state
            STATES[T] = copy.deepcopy(self.vehs_dict)
            
            #
            T = T + deltat_sec
            #builtins.tmp = STATES
        
        return STATES



    
    def sim_insert_vehs_at_once_MIXED_AVS_BKP(self, deltat_sec =.5, T_horizon_sec = 3600.0, \
        desired_density = 100, \
        inserted_initial_state = np.array([.0, .0, .0, 0, .0, .0]), \
        safety_gap2downstream_when_insert = 10, \
        safety_gap2upstream_when_insert = 10,  \
        idm_paras = idm_paras, \
        stochastic_proecess_name = 'converted', \
        two_dim_paras_HDV = two_dim_paras, \
        two_dim_paras_AV = two_dim_paras_AV,
        idm_paras_AV = idm_paras_AV,\
        idm_paras_HDV = idm_paras, \
        leader_state_infinity = np.array([1e10, .0, .0, 0, .0, .0]), \
        ellipse_x_min = 10, \
        ellipse_x_max = 60, \
        intert_tolerance = 1e-1, \
        with_neighboring_influence = True, \
        MPRs_list = [.1, .3, .4, .5], \
        lanemark_force_type = 'exponential' ):
        """
        Inseert all vehicles at the initial moment. 
        
        ------------------------------------
        
        @input: lanemark_force_type
        
            either 'parabolic' or 'exponential'
        
        
        @input: MPRs_list
            
            the MPR of the AVs. 
            
            The length of MPR_list MUST BE the same as self.lanes_ids：
            
                len(MPRs_list)=len(self.lane_ids)
            
        
        @input: desired_density
            
            the desired density. unit is veh/km.
        
        @input: deltat_sec
        
            the time step, unit is sec. 
        
        @input: inserted_initial_state
        
            inserted_initial_state = [x, vx, y ,vy, zlon, zlat]
        
        @input: safety_gap2downstream_when_insert and safety_gap2upstream_when_insert
            
            both are float. WHen the inser. 
        
        @input: leader_state_infinity
        
            if there is only one vehicle and then the leader locates at infunity. 
        
        @OUTPUTS: STATES
        
            STATES[moment][vid] = state
        
        --------------------------
        @STEPS:
        
            
        """
        #
        if len(MPRs_list)!=len(self.lanes_ids):
            print(len(MPRs_list), '-----------', len(self.lanes_ids))
            raise ValueError('sffsdfsadfsadf')
        #
        #
        STATES = {}
        self.snapshots = {}
        #
        ######################################Insert vehicles.
        #--------------------Find the equilibrium v
        #kjam unit is veh/km
        kjam =  1000.0/(idm_paras['idm_s0'] + idm_paras['veh_len'])
        vehs_number = int(max(1, min(desired_density/1000.0*(self.length-1), (self.length-1)/1000.0*kjam)))
        space = (self.length-10.0)/vehs_number
        #
        locs_inserted = [10]
        for i in range(vehs_number):
            tmp = locs_inserted[-1] + space
            if tmp<self.length:
                locs_inserted.append(tmp)
            else:
                break
        #print(locs_inserted)
        equilibrium_v = TwoDimMicroModel.IDM_equilibrium_v_from_deltax(deltax = space)
        #----------------------------In sert vehicles. 
        for idx_lane,lane_id in enumerate(self.lanes_ids):
            for i,loc in enumerate(locs_inserted):
                #
                vid_new = len(self.vehs_dict)#uuid.uuid1()
                if np.random.uniform()<MPRs_list[idx_lane]:
                    self.vehs_two_dim_paras[vid_new] = copy.deepcopy(two_dim_paras_AV)
                    self.vehs_idm_paras[vid_new] = copy.deepcopy(idm_paras_AV)
                else:
                    self.vehs_two_dim_paras[vid_new] = copy.deepcopy(two_dim_paras_HDV)
                    self.vehs_idm_paras[vid_new] = copy.deepcopy(idm_paras_HDV)
                #
                #
                inserted_initial_state0 =  inserted_initial_state
                inserted_initial_state0[0] = loc
                inserted_initial_state0[1] = equilibrium_v
                inserted_initial_state0[2] = self.lanes_middle_line[lane_id]
                #
                self.vehs_dict[vid_new] = copy.deepcopy(inserted_initial_state0)
                self.vehs_at_lanes[lane_id].append(vid_new)
                #self.vehs_at_lanes[lane_id].insert(0, vid_new)
                self.vehs_target_lane[vid_new] = lane_id
        #
        ##################################RUN
        T = 0
        while T<T_horizon_sec:
            self.snapshots[T] = {}
            #################################Microscopic traffic flow model
            #calcualte F and L. keys are the vehicle ids. 
            #   F_dicts[vid] is a 1d array. 
            #   L_dicts[vid] is a N*2 array. 2 means lon and lat noise. 
            F_dicts = {}
            L_dicts = {}
            vehs_info_within_area_left_dict = {}
            vehs_info_within_area_right_dict = {}
            leader_state_dict = {}
            potentials_dict = {}
            #for laneid in self.lanes_ids:
            for idx_lane,laneid in enumerate(self.lanes_ids):
                #------------------------------------------------------
                #------------------------------------------------------
                #idx_lane = 0 means leftmost lane, rightbound not exit and left mark force not exist. 
                if idx_lane==0:
                    left_mark_force = False
                    right_bound_force = False
                    #
                    right_mark_force = True
                    left_bound_force = True
                #idx_lane==len(road_attrs['lanes_ids'])-1 means RIGHTMOST lane. 
                elif idx_lane==len(self.lanes_ids)-1:
                    right_mark_force = False
                    left_bound_force = False
                    #
                    left_mark_force = True
                    right_bound_force = True
                else:
                    right_mark_force = True
                    left_mark_force = True
                    #
                    left_bound_force = False
                    right_bound_force = False

                #----------------find the vehs_info_within_area. 
                for i,vid in enumerate(self.vehs_at_lanes[laneid]):
                    # ----------------------------
                    ego_state = self.vehs_dict[vid]
                    #
                    #=========================================FInd the leader
                    #find the leader and the lateral vehicles. 
                    if len(self.vehs_at_lanes[laneid])==1:
                        leader_state = copy.deepcopy(ego_state)
                        leader_state[0] = ego_state[0]+1e10
                    else:
                        if i==len(self.vehs_at_lanes[laneid])-1:
                            #
                            leader_id = self.vehs_at_lanes[laneid][0]
                            leader_state = copy.deepcopy(self.vehs_dict[leader_id])
                            leader_state[0] = leader_state[0] + self.length
                            #
                        else:
                            leader_id = self.vehs_at_lanes[laneid][i+1]
                            leader_state = copy.deepcopy(self.vehs_dict[leader_id])
                        #------------------search leader at ego lane. 
                    leader_state_dict[vid] = copy.deepcopy(leader_state)
                    #
                    #==============================================Find the lateral vehicles.
                    #============================================They will be stored in vehs_info_within_area_left and vehs_info_within_area_right
                    #find the lateral vehicles within influence areas, which is store
                    #ellipse_x = self.ellipse_x(ego_state  = ego_state)
                    ellipse_x = self.ellipse_x(ego_state  = ego_state, a_x_MAX = idm_paras['idm_a'], ellipse_x_min = ellipse_x_min, ellipse_x_max = ellipse_x_max)
                    #the leftmost lane have no left lane. 
                    if laneid==self.lanes_ids[0]:
                        left_lanes_vids = []
                    else:
                        left_lanes_vids = self.vehs_at_lanes[self.left_lane_id[laneid]]
                    #rightmost lane have no right lane. 
                    if laneid==self.lanes_ids[-1]:
                        right_lanes_vids = []
                    else:
                        right_lanes_vids = self.vehs_at_lanes[self.right_lane_id[laneid]]
                    #vehs_info_within_area_left is a dict. 
                    #print(right_lanes_vids, '---')
                    vehs_info_within_area_left,vehs_info_within_area_right = self.search_vehs_within_ellise(ego_state = ego_state, \
                        ellipse_x = ellipse_x, \
                        ellipse_y_left = self.ellipse_y_left[laneid],  \
                        ellipse_y_right = self.ellipse_y_right[laneid] ,  \
                        left_lanes_vids = left_lanes_vids, \
                        right_lanes_vids = right_lanes_vids, \
                        vehs_info_dict = self.vehs_dict, road_length  = self.length)
                    #print(vehs_info_within_area_right.keys(), '---')
                    #
                    vehs_info_within_area_left_dict[vid] = vehs_info_within_area_left
                    vehs_info_within_area_right_dict[vid] = vehs_info_within_area_right
                    #
                    #============================================Calculate F and L
                    #--------------calculate the F and L
                    #   F_dicts[vid] is a 1d array. 
                    F_dicts[vid],potentials_dict[vid] = TwoDimMicroModel.F(ego_state  = ego_state, \
                        ego_lane_lw = self.lws_dict[laneid], \
                        ego_lane_middle_line_coor = self.lanes_middle_line[laneid], \
                        ego_lane_marks_coor = self.lanes_marks_coors[laneid], \
                        road_bounds = self.road_bounds, \
                        lw_boundary_lanes = self.lw_boundary_lanes, \
                        leader_state = leader_state, \
                        ellipse_x = ellipse_x, \
                        ellipse_y_left = self.ellipse_y_left[laneid],  \
                        ellipse_y_right = self.ellipse_y_right[laneid] ,  \
                        vehs_info_within_area_left = vehs_info_within_area_left, \
                        vehs_info_within_area_right = vehs_info_within_area_right, \
                        two_dim_paras = self.vehs_two_dim_paras[vid], \
                        idm_paras = self.vehs_idm_paras[vid], \
                        stochastic_proecess_name = stochastic_proecess_name, \
                        right_mark_force = right_mark_force,  \
                        left_bound_force = left_bound_force, \
                        left_mark_force = left_mark_force, 
                        right_bound_force = right_bound_force, \
                        with_neighboring_influence = with_neighboring_influence, \
                        lanemark_force_type = lanemark_force_type)
                    #
                    L_dicts[vid] = TwoDimMicroModel.L(state  = ego_state, \
                        two_dim_paras = self.vehs_two_dim_paras[vid], \
                        idm_paras = self.vehs_idm_paras[vid], \
                        stochastic_proecess_name = stochastic_proecess_name)
                    
            ################################UPDATE
            #for vid in self.vehs_dict.keys():
            for idx_lane,laneid in enumerate(self.lanes_ids):
                for i,vid in enumerate(self.vehs_at_lanes[laneid]):
                    #
                    brownian = np.random.normal(loc = np.zeros((2,)), scale = deltat_sec)
                    #
                    #
                    #print(self.vehs_dict[vid], vid in F_dicts, vid in L_dicts)
                    new_state,feasible_increment = self.TrimUpdate(old_state = self.vehs_dict[vid], \
                        deltat_sec = deltat_sec, \
                        F = F_dicts[vid], \
                        L = L_dicts[vid], \
                        brownian = brownian, \
                        idm_paras = self.vehs_idm_paras[vid])
                    #new_state = F_dicts[vid] + np.matmul(L_dicts[vid], brownian/deltat_sec)
                    
                    #
                    #print(F_dicts[vid].shape, np.matmul(L_dicts[vid], brownian).shape)
                    #new_state = self.vehs_dict[vid] + F_dicts[vid]*deltat_sec + np.matmul(L_dicts[vid], brownian)
                    #---------------------UPDATE systen variables. 
                    #SNAPSHOT
                    self.snapshots[T]['vehs_at_lanes'] = copy.deepcopy(self.vehs_at_lanes)
                    self.snapshots[T][vid] = {'S':copy.deepcopy(self.vehs_dict[vid]), \
                        #'feasibleincrement':copy.deepcopy(feasible_increment), \
                        'L':copy.deepcopy(L_dicts[vid]), \
                        'F':copy.deepcopy(F_dicts[vid]), \
                        'vehs_info_within_area_left':copy.deepcopy(vehs_info_within_area_left_dict[vid]), \
                        'vehs_info_within_area_right':copy.deepcopy(vehs_info_within_area_right_dict[vid]), \
                        'potentials':copy.deepcopy(potentials_dict[vid]), }
                    #
                    #==================================================
                    if new_state[0]>=self.length:
                        #-----------Change state
                        new_state[0] = new_state[0] - self.length
                        #print(new_state.shape)
                        self.vehs_dict[vid] = copy.deepcopy(new_state)
                        #-----------Change the vehicle order. 
                        tmp = copy.deepcopy([self.vehs_at_lanes[laneid][-1]] + self.vehs_at_lanes[laneid][:-1])
                        self.vehs_at_lanes[laneid] = tmp
                    else:
                        #print(new_state.shape)
                        self.vehs_dict[vid] = new_state
                #
            #############################RECORD the state
            STATES[T] = copy.deepcopy(self.vehs_dict)
            
            #
            T = T + deltat_sec
            #builtins.tmp = STATES
        
        return STATES




    def sim_insert_vehs_at_once(self, deltat_sec =.5, T_horizon_sec = 3600.0, \
        desired_density = 100, \
        inserted_initial_state = np.array([.0, .0, .0, 0, .0, .0]), \
        safety_gap2downstream_when_insert = 10, \
        safety_gap2upstream_when_insert = 10,  \
        idm_paras = idm_paras, \
        stochastic_proecess_name = 'converted', \
        two_dim_paras = two_dim_paras, \
        leader_state_infinity = np.array([1e10, .0, .0, 0, .0, .0]), \
        ellipse_x_min = 10, \
        ellipse_x_max = 60, \
        intert_tolerance = 1e-1, \
        with_neighboring_influence = True, \
        lanemark_force_type = 'exponential' ):
        """
        Inseert all vehicles at the initial moment. 
        
        ------------------------------------
        
        @input: lanemark_force_type
        
            either 'parabolic' or 'exponential'
        
        
        @input: desired_density
            
            the desired density. unit is veh/km.
        
        @input: deltat_sec
        
            the time step, unit is sec. 
        
        @input: inserted_initial_state
        
            inserted_initial_state = [x, vx, y ,vy, zlon, zlat]
        
        @input: safety_gap2downstream_when_insert and safety_gap2upstream_when_insert
            
            both are float. WHen the inser. 
        
        @input: leader_state_infinity
        
            if there is only one vehicle and then the leader locates at infunity. 
        
        @OUTPUTS: STATES
        
            STATES[moment][vid] = state
        
        --------------------------
        @STEPS:
        
            
        """
        STATES = {}
        self.snapshots = {}
        #
        ######################################Insert vehicles.
        #kjam unit is veh/km
        kjam =  1000.0/(idm_paras['idm_s0'] + idm_paras['veh_len'])
        vehs_number = int(max(1, min(desired_density/1000.0*(self.length-1), (self.length-1)/1000.0*kjam)))
        space = (self.length-10.0)/vehs_number
        #
        locs_inserted = [10]
        for i in range(vehs_number):
            tmp = locs_inserted[-1] + space
            if tmp<self.length:
                locs_inserted.append(tmp)
            else:
                break
        #print(locs_inserted)
        equilibrium_v = TwoDimMicroModel.IDM_equilibrium_v_from_deltax(deltax = space)
        #----------------------------
        for lane_id in self.lanes_ids:
            for i,loc in enumerate(locs_inserted):
                #
                vid_new = len(self.vehs_dict)#uuid.uuid1()
                #
                inserted_initial_state0 =  inserted_initial_state
                inserted_initial_state0[0] = loc
                inserted_initial_state0[1] = equilibrium_v
                inserted_initial_state0[2] = self.lanes_middle_line[lane_id]
                #
                self.vehs_dict[vid_new] = copy.deepcopy(inserted_initial_state0)
                self.vehs_at_lanes[lane_id].append(vid_new)
                #self.vehs_at_lanes[lane_id].insert(0, vid_new)
                self.vehs_target_lane[vid_new] = lane_id
        #
        ##################################RUN
        T = 0
        while T<T_horizon_sec:
            self.snapshots[T] = {}
            #################################Microscopic traffic flow model
            #calcualte F and L. keys are the vehicle ids. 
            #   F_dicts[vid] is a 1d array. 
            #   L_dicts[vid] is a N*2 array. 2 means lon and lat noise. 
            F_dicts = {}
            L_dicts = {}
            vehs_info_within_area_left_dict = {}
            vehs_info_within_area_right_dict = {}
            leader_state_dict = {}
            potentials_dict = {}
            #for laneid in self.lanes_ids:
            for idx_lane,laneid in enumerate(self.lanes_ids):
                #------------------------------------------------------
                #------------------------------------------------------
                #idx_lane = 0 means leftmost lane, rightbound not exit and left mark force not exist. 
                if idx_lane==0:
                    left_mark_force = False
                    right_bound_force = False
                    #
                    right_mark_force = True
                    left_bound_force = True
                #idx_lane==len(road_attrs['lanes_ids'])-1 means RIGHTMOST lane. 
                elif idx_lane==len(self.lanes_ids)-1:
                    right_mark_force = False
                    left_bound_force = False
                    #
                    left_mark_force = True
                    right_bound_force = True
                else:
                    right_mark_force = True
                    left_mark_force = True
                    #
                    left_bound_force = False
                    right_bound_force = False

                #----------------find the vehs_info_within_area. 
                for i,vid in enumerate(self.vehs_at_lanes[laneid]):
                    # ----------------------------
                    ego_state = self.vehs_dict[vid]
                    #
                    #=========================================FInd the leader
                    #find the leader and the lateral vehicles. 
                    #   if there is only one vehicle
                    if len(self.vehs_at_lanes[laneid])==1:
                        leader_state = copy.deepcopy(ego_state)
                        leader_state[0] = ego_state[0]+1e10
                    else:
                        #if the vehicle is the most downstream vehicle in the road. 
                        if i==len(self.vehs_at_lanes[laneid])-1:
                            #
                            leader_id = self.vehs_at_lanes[laneid][0]
                            leader_state = copy.deepcopy(self.vehs_dict[leader_id])
                            leader_state[0] = leader_state[0] + self.length
                            #
                        else:
                            leader_id = self.vehs_at_lanes[laneid][i+1]
                            leader_state = copy.deepcopy(self.vehs_dict[leader_id])
                        #------------------search leader at ego lane. 
                    leader_state_dict[vid] = copy.deepcopy(leader_state)
                    #
                    #==============================================Find the lateral vehicles.
                    #============================================They will be stored in vehs_info_within_area_left and vehs_info_within_area_right
                    #find the lateral vehicles within influence areas, which is store
                    #ellipse_x = self.ellipse_x(ego_state  = ego_state)
                    ellipse_x = self.ellipse_x(ego_state  = ego_state, a_x_MAX = idm_paras['idm_a'], ellipse_x_min = ellipse_x_min, ellipse_x_max = ellipse_x_max)
                    #
                    if laneid==self.lanes_ids[0]:
                        left_lanes_vids = []
                    else:
                        left_lanes_vids = self.vehs_at_lanes[self.left_lane_id[laneid]]
                    if laneid==self.lanes_ids[-1]:
                        right_lanes_vids = []
                    else:
                        right_lanes_vids = self.vehs_at_lanes[self.right_lane_id[laneid]]
                    #vehs_info_within_area_left is a dict. 
                    #print(right_lanes_vids, '---')
                    vehs_info_within_area_left,vehs_info_within_area_right = self.search_vehs_within_ellise(ego_state = ego_state, \
                        ellipse_x = ellipse_x, \
                        ellipse_y_left = self.ellipse_y_left[laneid],  \
                        ellipse_y_right = self.ellipse_y_right[laneid] ,  \
                        left_lanes_vids = left_lanes_vids, \
                        right_lanes_vids = right_lanes_vids, \
                        vehs_info_dict = self.vehs_dict, road_length  = self.length)
                    #print(vehs_info_within_area_right.keys(), '---')
                    #
                    vehs_info_within_area_left_dict[vid] = vehs_info_within_area_left
                    vehs_info_within_area_right_dict[vid] = vehs_info_within_area_right
                    #
                    #============================================Calculate F and L
                    #--------------calculate the F and L
                    #   F_dicts[vid] is a 1d array. 
                    F_dicts[vid],potentials_dict[vid] = TwoDimMicroModel.F(ego_state  = ego_state, \
                        ego_lane_lw = self.lws_dict[laneid], \
                        ego_lane_middle_line_coor = self.lanes_middle_line[laneid], \
                        ego_lane_marks_coor = self.lanes_marks_coors[laneid], \
                        road_bounds = self.road_bounds, \
                        lw_boundary_lanes = self.lw_boundary_lanes, \
                        leader_state = leader_state, \
                        ellipse_x = ellipse_x, \
                        ellipse_y_left = self.ellipse_y_left[laneid],  \
                        ellipse_y_right = self.ellipse_y_right[laneid] ,  \
                        vehs_info_within_area_left = copy.deepcopy(vehs_info_within_area_left), \
                        vehs_info_within_area_right = copy.deepcopy(vehs_info_within_area_right), \
                        two_dim_paras = two_dim_paras, \
                        stochastic_proecess_name = stochastic_proecess_name, \
                        right_mark_force = right_mark_force,  \
                        left_bound_force = left_bound_force, \
                        left_mark_force = left_mark_force, 
                        right_bound_force = right_bound_force, \
                        with_neighboring_influence = with_neighboring_influence, \
                        lanemark_force_type  = lanemark_force_type)
                    #
                    L_dicts[vid] = TwoDimMicroModel.L(state  = ego_state, two_dim_paras = two_dim_paras, stochastic_proecess_name = stochastic_proecess_name)
                    
            ################################UPDATE
            #for vid in self.vehs_dict.keys():
            for idx_lane,laneid in enumerate(self.lanes_ids):
                for i,vid in enumerate(self.vehs_at_lanes[laneid]):
                    #
                    brownian = np.random.normal(loc = np.zeros((2,)), scale = deltat_sec)
                    #
                    #
                    #print(self.vehs_dict[vid], vid in F_dicts, vid in L_dicts)
                    new_state,feasible_increment = self.TrimUpdate(old_state = self.vehs_dict[vid], deltat_sec = deltat_sec, F = F_dicts[vid], L = L_dicts[vid], brownian = brownian, idm_paras = idm_paras)
                    #new_state = F_dicts[vid] + np.matmul(L_dicts[vid], brownian/deltat_sec)
                    
                    #
                    #print(F_dicts[vid].shape, np.matmul(L_dicts[vid], brownian).shape)
                    #new_state = self.vehs_dict[vid] + F_dicts[vid]*deltat_sec + np.matmul(L_dicts[vid], brownian)
                    #---------------------UPDATE systen variables. 
                    #SNAPSHOT
                    self.snapshots[T]['vehs_at_lanes'] = copy.deepcopy(self.vehs_at_lanes)
                    self.snapshots[T][vid] = {'S':copy.deepcopy(self.vehs_dict[vid]), \
                        #'feasibleincrement':copy.deepcopy(feasible_increment), \
                        'L':copy.deepcopy(L_dicts[vid]), \
                        'F':copy.deepcopy(F_dicts[vid]), \
                        'vehs_info_within_area_left':copy.deepcopy(vehs_info_within_area_left_dict[vid]), \
                        'vehs_info_within_area_right':copy.deepcopy(vehs_info_within_area_right_dict[vid]), \
                        'potentials':copy.deepcopy(potentials_dict[vid]), }
                    #
                    #==================================================
                    if new_state[0]>=self.length:
                        #-----------Change state
                        new_state[0] = new_state[0] - self.length
                        #print(new_state.shape)
                        self.vehs_dict[vid] = copy.deepcopy(new_state)
                        #-----------Change the vehicle order. 
                        tmp = copy.deepcopy([self.vehs_at_lanes[laneid][-1]] + self.vehs_at_lanes[laneid][:-1])
                        self.vehs_at_lanes[laneid] = tmp
                    else:
                        #print(new_state.shape)
                        self.vehs_dict[vid] = new_state
                #
            #############################RECORD the state
            STATES[T] = copy.deepcopy(self.vehs_dict)
            
            #
            T = T + deltat_sec
            #builtins.tmp = STATES
        
        return STATES







class LateralPID():
    """
    
    """
    args_vehmodel = {'m':1412.0, 'lf':1.01, 'lr':1.895, 'Caf':52000.0, 'Car':34500.0, 'Vx':1.2, 'Iz':1536.7}

    @classmethod
    def F(self, S, decisionvariables = np.array([-1.0, -1.0, -1.0, -1.0, ]), args_vehmodel = args_vehmodel, min_control = -70*np.pi/180.0, max_control = 70*np.pi/180.0, stochastic_proecess_name = 'OU', two_dim_paras = two_dim_paras):
        """
        The matrixs of the  vehicle model
        
            dS = F(S)dt+ L(S)dW
        
        S is the system state. Its dimension is 6.
        
        S = (lateral_deviation, lateral_deviation_differential, heading_angle_deviation, heading_angle_deviation_differential, noise)
        
        A is 4*4, and B is 4*1. 
        
        delta is the steering angle. 
        
        Callback:
        
            A,B = self.VehicleErrorModelMatrixes(S, args_vehmodel)
        
        --------------------------------------------
        @input: S
            
            the state variable. Its dimension is 5. 
            
            It is :
            
                S = (lateral_deviation, lateral_deviation_differential, heading_angle_deviation, heading_angle_deviation_differential, Z_lat)
            
        @input: decisionvariables
            
            a 1d array with length of 8. 
            
            include the 
                
                = ks (the coeccicient of Z_bnd will be always zero then there would be 5).
                = sigma_bnd
                = alpha_bnd and alpha_con
        
        """
        #decisionvariables = [k0,k1,k2,k3,k5,sigma_con,]
        ks = decisionvariables[:]
        #sigma_con = decisionvariables[5]
        #alpha_con = decisionvariables[7]
        
        #control
        control0 =  np.dot(ks, np.array([S[0], S[1], S[2], S[3]]))
        #clamp
        control = min(max_control, max(control0, min_control))
        
        #####################################THe system is dS/dt  = A S + B*delta, delta is the control input 
        #############################Matrix A
        #------------------------------------------------------0th row
        a0=  S[1]
        #------------------------------------1th row
        tmp1 = -(2.0*args_vehmodel['Caf']+2.0*args_vehmodel['Car'])/(args_vehmodel['m']*args_vehmodel['Vx'])
        tmp2 = -(2.0*args_vehmodel['Caf']+2.0*args_vehmodel['Car'])/(args_vehmodel['m'])
        tmp3 = (-2.0*args_vehmodel['Caf']*args_vehmodel['lf']+2.0*args_vehmodel['Car']*args_vehmodel['lr'])/(args_vehmodel['m']*args_vehmodel['Vx'])
        tmp4 = 2.0*args_vehmodel['Caf']/args_vehmodel['m']
        #the gain of S[4] will be always zero. becuase S[4] is Z_bnd, which is not smooth. 
        #print(control, tmp1, tmp2, tmp3, tmp4)
        a1 = tmp1*S[1]+tmp2*S[2]+tmp3*S[3] + tmp4*control  + S[4]
        #---------------------------------------2nd row
        a2 = S[3]
        #---------------------------------------3rd row
        tmp1 = -1.0*(2.0*args_vehmodel['Caf']*args_vehmodel['lf']-2.0*args_vehmodel['Car']*args_vehmodel['lr'])/(args_vehmodel['Iz']*args_vehmodel['Vx'])
        tmp2 = 1.0*(2.0*args_vehmodel['Caf']*args_vehmodel['lf']-2.0*args_vehmodel['Car']*args_vehmodel['lr'])/(args_vehmodel['Iz'])
        tmp3 = -1.0*(2.0*args_vehmodel['Caf']*args_vehmodel['lf']*args_vehmodel['lf'] + 2.0*args_vehmodel['Car']*args_vehmodel['lr']*args_vehmodel['lr'])/(args_vehmodel['Iz']*args_vehmodel['Vx'])
        tmp4 = 2.0*args_vehmodel['Caf']*args_vehmodel['lf']/args_vehmodel['Iz']
        print(S)
        a3 = tmp1*S[1]+tmp2*S[2]+tmp3*S[3] + tmp4*control
        #
        #------------------------------------------4rd row
        #a4 = -(sigma_con**2)*S[4]*(1 - S[4]**2)
        #------------------------------------------5th row
        #a5 = -alpha_con*S[5] - alpha_bnd*S[4]


        #
        Z_lat = S[4]
        #==============================diff_Z_long, diff_Z_lat
        if stochastic_proecess_name=='OU':
            #diff_Z_long = -(sigma_long**1.0)*(Z_long**3)
            #diff_Z_lat = -(sigma_lat**1.0)*(Z_lat)
            #print(Z_long, sigma_long_drift)
            #diff_Z_long = -two_dim_paras['sigma_long_drift']*Z_long
            diff_Z_lat = -two_dim_paras['sigma_lat_drift']*Z_lat
        elif stochastic_proecess_name=='simple':
            #diff_Z_long = -(sigma_long**1.0)*(Z_long**3)
            #diff_Z_lat = -(sigma_lat**1.0)*(Z_lat)
            #print(Z_long, sigma_long_drift)
            #diff_Z_long = 0
            diff_Z_lat = 0
        elif stochastic_proecess_name=='converted':
            #the converted. 
            #diff_Z_long = -(two_dim_paras['sigma_long']**2)*(1-Z_long**2)*Z_long
            diff_Z_lat = -(two_dim_paras['sigma_lat']**2)*(1-Z_lat**2)*Z_lat
        elif stochastic_proecess_name=='geometric':
            #
            #diff_Z_long =  -two_dim_paras['sigma_long_drift']*(Z_long)
            diff_Z_lat = -two_dim_paras['sigma_lat_drift']*(Z_lat)
            #
        elif stochastic_proecess_name=='jacobi':
            #
            #diff_Z_long = -two_dim_paras['sigma_long_drift']*(Z_long - .0)
            diff_Z_lat = -two_dim_paras['sigma_lat_drift']*(Z_lat - .0)
            #
        elif stochastic_proecess_name=='hyperparabolic':
            #
            #diff_Z_long = -sigma_long_drift*(Z_long - .0)
            #diff_Z_lat = -sigma_lat_drift*(Z_lat - .0)
            #diff_Z_long =  -Z_long-two_dim_paras['sigma_long_drift']*Z_long
            diff_Z_lat = -Z_lat-two_dim_paras['sigma_lat_drift']*Z_lat
            #print(diff_Z_long, diff_Z_lat)
        elif stochastic_proecess_name=='ROU':
            #ew_state = STATES[-1] + (theta/STATES[-1] -  STATES[-1] )*deltat + sigma*brownian
            #diff_Z_long = -two_dim_paras['sigma_long_drift']/Z_long +  Z_long#-sigma_long_drift*(Z_long - .0)
            diff_Z_lat = -two_dim_paras['sigma_lat_drift']/Z_lat +  Z_lat #-sigma_lat_drift*(Z_lat - .0)
    
        #
        F = np.array([a0, a1, a2, a3, diff_Z_lat])
        return F


    @classmethod
    def L(self, S, decisionvariables = np.array([-1.0, -1.0, -1.0, -1.0]), stochastic_proecess_name = 'OU', two_dim_paras  = two_dim_paras):
        """
        The matrixs of the  vehicle model
        
            dS/dt = A S + B delta
        
        S is the system state. Its dimension is 4.
        
        S = (lateral_deviation, lateral_deviation_differential, heading_angle_deviation, heading_angle_deviation_differential)
        
        A is 4*4, and B is 4*1. 
        
        delta is the steering angle. 
        
        Callback:
        
            A,B = self.VehicleErrorModelMatrixes(S, args_vehmodel)
        
        --------------------------------------------
        @input: S
            
            the state variable. Its dimension is 4. 
            
            It is :
            
                S = (lateral_deviation, lateral_deviation_differential, heading_angle_deviation, heading_angle_deviation_differential)
            
        
        
        """
        sigma_lat = two_dim_paras['sigma_lat']
        Z_lat = S[4]
        #------------------------------------------
        if stochastic_proecess_name=='OU':
            #tmp_long = sigma_long
            tmp_lat = sigma_lat
            #
        elif stochastic_proecess_name=='simple':
            #diff_Z_long = -(sigma_long**1.0)*(Z_long**3)
            #diff_Z_lat = -(sigma_lat**1.0)*(Z_lat)
            #print(Z_long, sigma_long_drift)
            #tmp_long =  sigma_long#*min(1.0, np.sqrt(vx**2 + vy**2)/idm_paras['idm_vf'])
            tmp_lat = sigma_lat#*min(1, np.sqrt(vx**2 + vy**2)/idm_paras['idm_vf'])
            
        elif stochastic_proecess_name=='converted':
            #the converted. 
            #tmp_long =  sigma_long*(1.0-Z_long**2)
            tmp_lat = sigma_lat*(1-Z_lat**2)
            #
        elif stochastic_proecess_name=='geometric':
            #
            #tmp_long =  sigma_long*(Z_long)
            tmp_lat = sigma_lat*(Z_lat)
            #
        elif stochastic_proecess_name=='hyperparabolic':
            #
            #tmp_long = sigma_long
            tmp_lat = sigma_lat
            
        elif stochastic_proecess_name=='jacobi':
            #new_state = STATES[-1] - theta*(STATES[-1])*deltat + sigma*np.sqrt((STATES[-1]+.5)*(.5-STATES[-1]))*brownian
            #Z_long = max(-.499999, min(Z_long, .4999999))
            #tmp_long =   np.sqrt(sigma_long*(Z_long+.5)*(.5-Z_long))
            #print(Z_lat, (.5-Z_lat), (Z_lat+.5))
            Z_lat = max(-.499999, min(Z_lat, .4999999))
            tmp_lat = np.sqrt(sigma_lat*(Z_lat+.5)*(.5-Z_lat))
        elif stochastic_proecess_name=='ROU':
            #
            #tmp_long =  sigma_long
            tmp_lat = sigma_lat
        
        return np.array([.0, .0, .0, .0, tmp_lat])


    @classmethod
    def mc_traditional_riccati(self, ts = np.linspace(0, 100, 30) , S0 = np.array([1.3, .01, .1, .001, 0]), args_vehmodel = args_vehmodel, Q = np.eye(4), R = np.eye(1),  stochastic_proecess_name = 'OU', two_dim_paras = two_dim_paras, N_paths = 100):
        """
        """
        sigma_lat = two_dim_paras['sigma_lat']
        sim_paths = []
        for i in range(N_paths):
            #
            path = [S0]
            S_old = S0
            gains = []
            for i,deltat in enumerate(np.diff(ts)):
                #
                A,B = self.A_and_B(args_vehmodel = args_vehmodel)
                
                #G is the gain. G.shape is [1,4]
                X, L, G = control.dare(A, B, Q, R) 
                
                #
                gains.append(G)
                #np.multiply(B, G).shape is (1,4)
                #np.matmul(A, S).shape is (4, )
                #np.dot(G, S) is scalar. 
                
                #+======================
                #
                Z_lat = path[-1][4]
                #==============================diff_Z_long, diff_Z_lat
                if stochastic_proecess_name=='OU':
                    #diff_Z_long = -(sigma_long**1.0)*(Z_long**3)
                    #diff_Z_lat = -(sigma_lat**1.0)*(Z_lat)
                    #print(Z_long, sigma_long_drift)
                    #diff_Z_long = -two_dim_paras['sigma_long_drift']*Z_long
                    diff_Z_lat = -two_dim_paras['sigma_lat_drift']*Z_lat
                    tmp_lat = sigma_lat
                elif stochastic_proecess_name=='simple':
                    #diff_Z_long = -(sigma_long**1.0)*(Z_long**3)
                    #diff_Z_lat = -(sigma_lat**1.0)*(Z_lat)
                    #print(Z_long, sigma_long_drift)
                    #diff_Z_long = 0
                    diff_Z_lat = 0
                elif stochastic_proecess_name=='converted':
                    #the converted. 
                    #diff_Z_long = -(two_dim_paras['sigma_long']**2)*(1-Z_long**2)*Z_long
                    diff_Z_lat = -(two_dim_paras['sigma_lat']**2)*(1-Z_lat**2)*Z_lat
                elif stochastic_proecess_name=='geometric':
                    #
                    #diff_Z_long =  -two_dim_paras['sigma_long_drift']*(Z_long)
                    diff_Z_lat = -two_dim_paras['sigma_lat_drift']*(Z_lat)
                    #
                elif stochastic_proecess_name=='jacobi':
                    #
                    #diff_Z_long = -two_dim_paras['sigma_long_drift']*(Z_long - .0)
                    diff_Z_lat = -two_dim_paras['sigma_lat_drift']*(Z_lat - .0)
                    #
                elif stochastic_proecess_name=='hyperparabolic':
                    #
                    #diff_Z_long = -sigma_long_drift*(Z_long - .0)
                    #diff_Z_lat = -sigma_lat_drift*(Z_lat - .0)
                    #diff_Z_long =  -Z_long-two_dim_paras['sigma_long_drift']*Z_long
                    diff_Z_lat = -Z_lat-two_dim_paras['sigma_lat_drift']*Z_lat
                    #print(diff_Z_long, diff_Z_lat)
                elif stochastic_proecess_name=='ROU':
                    #ew_state = STATES[-1] + (theta/STATES[-1] -  STATES[-1] )*deltat + sigma*brownian
                    #diff_Z_long = -two_dim_paras['sigma_long_drift']/Z_long +  Z_long#-sigma_long_drift*(Z_long - .0)
                    diff_Z_lat = -two_dim_paras['sigma_lat_drift']/Z_lat +  Z_lat #-sigma_lat_drift*(Z_lat - .0)
                brownian = np.random.normal(loc=0, scale = np.sqrt(deltat),)
                #
                Z_lat_new = Z_lat + diff_Z_lat*deltat + tmp_lat*brownian
                
                #print(A.shap)
                S_new = np.matmul(A, S_old[:-1]) + B[:,0]*np.dot(-1*G, S_old[:-1]) + np.array([.0, Z_lat_new, .0, .0])
                #
                S_new = np.array(list(S_new)+[Z_lat_new])
                #
                path.append(S_new)
                #
                S_old = S_new
            #
            #shape is (N, 4)
            path0 = np.array(path)
            sim_paths.append(path0)
        
        return sim_paths

    @classmethod
    def mc_traditional_riccati_BKP(self, ts = np.linspace(0, 100, 30) , S0 = np.array([1.3, .01, .1, .001, 0]), args_vehmodel = args_vehmodel, Q = np.eye(4), R = np.eye(1),  stochastic_proecess_name = 'OU', two_dim_paras = two_dim_paras,):
        """
        """
        sigma_lat = two_dim_paras['sigma_lat']
        
        
        path = [S0]
        S_old = S0
        gains = []
        for i,deltat in enumerate(np.diff(ts)):
            #
            A,B = self.A_and_B(args_vehmodel = args_vehmodel)
            
            #G is the gain. G.shape is [1,4]
            X, L, G = control.dare(A, B, Q, R) 
            
            #
            gains.append(G)
            #np.multiply(B, G).shape is (1,4)
            #np.matmul(A, S).shape is (4, )
            #np.dot(G, S) is scalar. 
            
            #+======================
            #
            Z_lat = path[-1][4]
            #==============================diff_Z_long, diff_Z_lat
            if stochastic_proecess_name=='OU':
                #diff_Z_long = -(sigma_long**1.0)*(Z_long**3)
                #diff_Z_lat = -(sigma_lat**1.0)*(Z_lat)
                #print(Z_long, sigma_long_drift)
                #diff_Z_long = -two_dim_paras['sigma_long_drift']*Z_long
                diff_Z_lat = -two_dim_paras['sigma_lat_drift']*Z_lat
                tmp_lat = sigma_lat
            elif stochastic_proecess_name=='simple':
                #diff_Z_long = -(sigma_long**1.0)*(Z_long**3)
                #diff_Z_lat = -(sigma_lat**1.0)*(Z_lat)
                #print(Z_long, sigma_long_drift)
                #diff_Z_long = 0
                diff_Z_lat = 0
            elif stochastic_proecess_name=='converted':
                #the converted. 
                #diff_Z_long = -(two_dim_paras['sigma_long']**2)*(1-Z_long**2)*Z_long
                diff_Z_lat = -(two_dim_paras['sigma_lat']**2)*(1-Z_lat**2)*Z_lat
            elif stochastic_proecess_name=='geometric':
                #
                #diff_Z_long =  -two_dim_paras['sigma_long_drift']*(Z_long)
                diff_Z_lat = -two_dim_paras['sigma_lat_drift']*(Z_lat)
                #
            elif stochastic_proecess_name=='jacobi':
                #
                #diff_Z_long = -two_dim_paras['sigma_long_drift']*(Z_long - .0)
                diff_Z_lat = -two_dim_paras['sigma_lat_drift']*(Z_lat - .0)
                #
            elif stochastic_proecess_name=='hyperparabolic':
                #
                #diff_Z_long = -sigma_long_drift*(Z_long - .0)
                #diff_Z_lat = -sigma_lat_drift*(Z_lat - .0)
                #diff_Z_long =  -Z_long-two_dim_paras['sigma_long_drift']*Z_long
                diff_Z_lat = -Z_lat-two_dim_paras['sigma_lat_drift']*Z_lat
                #print(diff_Z_long, diff_Z_lat)
            elif stochastic_proecess_name=='ROU':
                #ew_state = STATES[-1] + (theta/STATES[-1] -  STATES[-1] )*deltat + sigma*brownian
                #diff_Z_long = -two_dim_paras['sigma_long_drift']/Z_long +  Z_long#-sigma_long_drift*(Z_long - .0)
                diff_Z_lat = -two_dim_paras['sigma_lat_drift']/Z_lat +  Z_lat #-sigma_lat_drift*(Z_lat - .0)
            brownian = np.random.normal(loc=0, scale = np.sqrt(deltat),)
            Z_lat_new = Z_lat + diff_Z_lat*deltat + tmp_lat*brownian
            
            #print(A.shap)
            S_new = np.matmul(A, S_old[:-1]) + B[:,0]*np.dot(-1*G, S_old[:-1]) + np.array([.0, Z_lat_new, .0, .0])
            S_new = np.array(list(S_new)+[Z_lat_new])
            path.append(S_new)
            #
            S_old = S_new
        #
        #shape is (N, 4)
        path0 = np.array(path)
        
        return path0,gains
        

    @classmethod
    def A_and_B(self, args_vehmodel = args_vehmodel):
        """
        The matrixs of the  vehicle model
        
            dS = F(S)dt+ L(S)dW
        
        S is the system state. Its dimension is 6.
        
        S = (lateral_deviation, lateral_deviation_differential, heading_angle_deviation, heading_angle_deviation_differential, bounded_and_smooth_noise, meta_bounded_noise)
        
        A is 4*4, and B is 4*1. 
        
        delta is the steering angle. 
        
        Callback:
        
            A,B = self.VehicleErrorModelMatrixes(S, args_vehmodel)
        
        --------------------------------------------
        @input: S
            
            the state variable. Its dimension is 4. 
            
            It is :
            
                S = (lateral_deviation, lateral_deviation_differential, heading_angle_deviation, heading_angle_deviation_differential)
            
        @input: decisionvariables
            
            a 1d array with length of 8. 
            
            include the 
                
                = ks (the coeccicient of Z_bnd will be always zero then there would be 5).
                = sigma_con
                = alpha_bnd and alpha_con
        
        """
        #decisionvariables = [k0,k1,k2,k3,k5, sigma_con,alpha_bnd,alpha_con]
        #ks = decisionvariables[:5]
        #sigma_con = decisionvariables[5]
        #alpha_bnd = decisionvariables[6]
        #alpha_con = decisionvariables[7]
        
        #####################################THe system is dS/dt  = A S + B*delta, delta is the control input 
        #############################Matrix A
        a0 = np.array([0, 1, 0, 0])
        #---------------1th row
        tmp1 = -(2.0*args_vehmodel['Caf']+2.0*args_vehmodel['Car'])/(args_vehmodel['m']*args_vehmodel['Vx'])
        tmp2 = -(2.0*args_vehmodel['Caf']+2.0*args_vehmodel['Car'])/(args_vehmodel['m'])
        tmp3 = (-2.0*args_vehmodel['Caf']*args_vehmodel['lf']+2.0*args_vehmodel['Car']*args_vehmodel['lr'])/(args_vehmodel['m']*args_vehmodel['Vx'])
        
        #the gain of S[4] will be always zero. becuase S[4] is Z_bnd, which is not smooth. 
        #a1 = tmp1*S[1]+tmp2*S[2]+tmp3*S[3]+tmp4*np.dot(ks, np.array([S[0], S[1], S[2], S[3], S[5]]))
        a1 = np.array([0, tmp1, tmp2, tmp3,])
        
        #-----------------2nd row
        a2 = np.array([0, 0, 0, 1])
        
        #----------------3rd row
        tmp1 = -1.0*(2.0*args_vehmodel['Caf']*args_vehmodel['lf']-2.0*args_vehmodel['Car']*args_vehmodel['lr'])/(args_vehmodel['Iz']*args_vehmodel['Vx'])
        tmp2 = 1.0*(2.0*args_vehmodel['Caf']*args_vehmodel['lf']-2.0*args_vehmodel['Car']*args_vehmodel['lr'])/(args_vehmodel['Iz'])
        tmp3 = -1.0*(2.0*args_vehmodel['Caf']*args_vehmodel['lf']*args_vehmodel['lf'] + 2.0*args_vehmodel['Car']*args_vehmodel['lr']*args_vehmodel['lr'])/(args_vehmodel['Iz']*args_vehmodel['Vx'])
        #
        #a3 = tmp1*S[1]+tmp2*S[2]+tmp3*S[3]+tmp4*np.dot(ks, np.array([S[0], S[1], S[2], S[3], S[5]]))
        a3 = np.array([0, tmp1, tmp2, tmp3])
        
        A = np.array([a0, a1, a2, a3])
        
        
        
        tmp1 = 2.0*args_vehmodel['Caf']/args_vehmodel['m']
        tmp2 = 2.0*args_vehmodel['Caf']*args_vehmodel['lf']/args_vehmodel['Iz']
        #
        B = np.array([0, tmp1, 0, tmp2])
        
        #the returned A and B are both 2d and have the same rows number. 
        return A,np.array([B]).T
        
    
    @classmethod
    def mc_system(self, ts = np.linspace(0, 100, 100), S0 = [.0, .0, .0, .0, .0,], decisionvariables = np.array([ .0, 2.2831892, 1.61003517, -1.76331303, ]), args_vehmodel = args_vehmodel, Npaths = 100, default_G = False, stochastic_proecess_name ='OU', two_dim_paras = two_dim_paras):
        """
        The matrixs of the  vehicle model
        
            dS = F dt + L dW
        
        S is the system state. Its dimension is 4.
        
        S = (lateral_deviation, lateral_deviation_differential, heading_angle_deviation, heading_angle_deviation_differential)
        -------------------------------------------------------
        @input: S0
        
            the initial state. 
            
            dS = F(S)dt+ L(S)dW
            
            S is the system state. Its dimension is 6.
            
            S = (lateral_deviation, lateral_deviation_differential, heading_angle_deviation, heading_angle_deviation_differential, bounded_and_smooth_noise, meta_bounded_noise)

        @input: decisionvariables
        
            #decisionvariables = [k0,k1,k2,k3,k5, sigma_con,alpha_bnd,alpha_con]
            ks = decisionvariables[:5]
            sigma_con = decisionvariables[5]
            alpha_bnd = decisionvariables[6]
            alpha_con = decisionvariables[7]


        """
        #the following two are the same length. 
        paths = []
        controls = []
        
        #Brownian paths
        deltat = ts[-1]-ts[-2]
        #
        
        for i in range(Npaths):
            path = []
            S_old = copy.deepcopy(S0)
            
            #   brownians is a 1d array. 
            brownians = np.random.normal(loc=0, scale = np.sqrt(deltat), size = (len(ts), ))
            
            
            for idx,t in enumerate(ts):
                
                
                #SYSTEM MATRIX, dS = Fdt + LdW
                F =  self.F(S = S_old, decisionvariables = decisionvariables, args_vehmodel = args_vehmodel, stochastic_proecess_name = stochastic_proecess_name, two_dim_paras = two_dim_paras)
                L  = self.L(S = S_old, decisionvariables = decisionvariables, stochastic_proecess_name =stochastic_proecess_name, two_dim_paras = two_dim_paras)
                
                #new state
                #print(F.shape, L.shape, brownians[idx])
                S_new = S_old + np.array(F)*deltat+np.array(L)*brownians[idx]
                path.append(S_new)
                
                #calculate the controls
                #calculate the controls
                ks = decisionvariables[:5]
                control = np.dot(list(ks)[:-1]+[0]+list(ks)[-1], list(S_new)[:-2]+[S_new[-1]])
                controls.append(control)
                
                #
                S_old = S_new
            #
            paths.append(np.array(path))
            
        return paths,controls
    
    
    pass






class TwoDimMicroModel():
    """
    two dim microscopic traffic flow model. 
    
    The state of the vehicle is represented as:
    
        - x,y,vx,vy,zlon,zlat.  x is the longitudinal, y is the lateral, z is the noise. 
    
    """


    @classmethod
    def Get_QVK_from_snapshots_singlelane(self, snapshots, length, Deltat_FD_sec = 30, rolling_sec = 30,):
        """
        DIfference between:
        
            - self.Get_QVK_from_snapshots()
            - self.Get_QVK_from_snapshots_singlelane()
            
        The latter is for single lane simulation. The snapshot is defined via:
        
        
                self.snapshots[T][vid] = {'S':copy.deepcopy(self.vehs_dict[vid]), \
                    'feasibleincrement':copy.deepcopy(feasible_increment), \
                    'L':copy.deepcopy(L_dicts[vid]), \
                    'F':copy.deepcopy(F_dicts[vid]), \
                    'potentials':copy.deepcopy(potentials_dict[vid]), \
                    'vehs_at_lanes':copy.deepcopy(self.vehs_at_lanes),}
        
        
        calculate the Q and K
        
        ------------------------------------------------------------------
        
        @input: snapshots
        
                self.snapshots[T][vid] = {'S':copy.deepcopy(self.vehs_dict[vid]), \
                    'feasibleincrement':copy.deepcopy(feasible_increment), \
                    'L':copy.deepcopy(L_dicts[vid]), \
                    'F':copy.deepcopy(F_dicts[vid]), \
                    'potentials':copy.deepcopy(potentials_dict[vid]), \
                    'vehs_at_lanes':copy.deepcopy(self.vehs_at_lanes),}
        
        @input: Deltat_FD_sec
        
            the time step that calculate the FD parameters. 
        
        @OUTPUT: Q and K
        
            both are dicts. 
            
            Q = [q1, q2, q3, q4...]
            K = [k1, k2, k3, k4...]
            V = [v1,v2,....]
            Q unit is veh/h
            K unit is veh/km
        
        
        
        
        -----------------------------
        Q = dA/|A|, d is the distance travelled by all vehicles.
        K = t(A)/|A|, t is the total time travelled. 
        """
        #Q[laneid] = [q1, q2, q3, q4...]
        #K[laneid] = [k1, k2, k3, k4...]
        t = sorted(snapshots.keys())[0]
        Q = []
        K = []
        V = []
        
        #unit is km.h
        #area = (length/1000.0)*(Deltat_FD_sec/3600.0)
        #
        Ts = np.array(sorted(snapshots.keys()))
        #
        start = 0.0
        end = start + Deltat_FD_sec
        for t in Ts:
            #for lane_id in snapshots[t]['vehs_at_lanes'].keys():
            k = len(snapshots[t]['vehs_at_lanes'])/(length/1000.0)
            K.append(k)
            v =  3.6*np.mean([snapshots[t][vid]['S'][1] for vid in snapshots[t]['vehs_at_lanes']])
            V.append(v)
            Q.append(k*v)
            
        return Q,V,K
        
        
        
        
        
        
        
        while end<=max(Ts):
            #unit is sec and meter.
            totaltimetravelled_sec = 0
            totaldistancetravelled_meter = 0
            #
            interval_ts = sorted(Ts[(Ts>start) & (Ts<=end)])
            for t0,t1 in zip(interval_ts[:-1], interval_ts[1:]):
                #
                for lane_id in snapshots[t]['vehs_at_lanes'].keys():
                    #
                    for vid in snapshots[t]['vehs_at_lanes'][lane_id]:
                        #time travelled
                        totaltimetravelled_sec = totaltimetravelled_sec + t1 - t0
                        #distancetravelled
                        if snapshots[t1][vid]['S'][0]<=snapshots[t0][vid]['S'][0]:
                            distance_travelled_vid = snapshots[t1][vid]['S'][0] + length - snapshots[t0][vid]['S'][0]
                        else:
                            distance_travelled_vid = snapshots[t1][vid]['S'][0]  - snapshots[t0][vid]['S'][0]
                        #
                        totaldistancetravelled_meter = totaldistancetravelled_meter  + distance_travelled_vid
                #
                Q_interval = totaldistancetravelled_meter/1000.0/area
                K_interval = totaldistancetravelled_meter/3600.0/area
                V_interval = Q_interval/K_interval
                #
                Q[lane_id].append(Q_interval)
                K[lane_id].append(K_interval)
                V[lane_id].append(V_interval)
            start = start + rolling_sec
            end = start + Deltat_FD_sec
        
        return Q,V,K
        

    @classmethod
    def Get_QVK_from_snapshots(self, snapshots, length, Deltat_FD_sec = 30, rolling_sec = 30,):
        """
        calculate the Q and K
        
            = 
        
        @input: snapshots
        
            snapshots[moment].kesys() are:
            
                self.snapshots[T]['vehs_at_lanes'] = copy.deepcopy(self.vehs_at_lanes)
                self.snapshots[T][vid] = {'S':copy.deepcopy(self.vehs_dict[vid]), \
                    #'feasibleincrement':copy.deepcopy(feasible_increment), \
                    'L':copy.deepcopy(L_dicts[vid]), \
                    'F':copy.deepcopy(F_dicts[vid]), \
                    'vehs_info_within_area_left':copy.deepcopy(vehs_info_within_area_left_dict[vid]), \
                    'vehs_info_within_area_right':copy.deepcopy(vehs_info_within_area_right_dict[vid]), \
                    'potentials':copy.deepcopy(potentials_dict[vid]), }
        
        @input: Deltat_FD_sec
        
            the time step that calculate the FD parameters. 
        
        @OUTPUT: Q and K
        
            both are dicts. 
            
            Q[laneid] = [q1, q2, q3, q4...]
            K[laneid] = [k1, k2, k3, k4...]
            V[laneid] = [v1,v2,....]
            Q unit is veh/h
            K unit is veh/km
        
        
        
        
        -----------------------------
        Q = dA/|A|, d is the distance travelled by all vehicles.
        K = t(A)/|A|, t is the total time travelled. 
        """
        #Q[laneid] = [q1, q2, q3, q4...]
        #K[laneid] = [k1, k2, k3, k4...]
        t = sorted(snapshots.keys())[0]
        Q = {lane_id:[] for lane_id in snapshots[t]['vehs_at_lanes'].keys()}
        K = {lane_id:[] for lane_id in snapshots[t]['vehs_at_lanes'].keys()}
        V = {lane_id:[] for lane_id in snapshots[t]['vehs_at_lanes'].keys()} 
        
        #unit is km.h
        area = (length/1000.0)*(Deltat_FD_sec/3600.0)
        #
        Ts = np.array(sorted(snapshots.keys()))
        #
        start = 0.0
        end = start + Deltat_FD_sec
        for t in Ts:
            for lane_id in snapshots[t]['vehs_at_lanes'].keys():
                k = len(snapshots[t]['vehs_at_lanes'][lane_id])/(length/1000.0)
                K[lane_id].append(k)
                #[1] is because the state variable is [x, vx, y ,vy, zlon, zlat]
                v =  3.6*np.mean([snapshots[t][vid]['S'][1] for vid in snapshots[t]['vehs_at_lanes'][lane_id]])
                V[lane_id].append(v)
                Q[lane_id].append(k*v)
                
        return Q,V,K
        
        
        
        while end<=max(Ts):
            #unit is sec and meter.
            totaltimetravelled_sec = 0
            totaldistancetravelled_meter = 0
            #
            interval_ts = sorted(Ts[(Ts>start) & (Ts<=end)])
            for t0,t1 in zip(interval_ts[:-1], interval_ts[1:]):
                #
                for lane_id in snapshots[t]['vehs_at_lanes'].keys():
                    #
                    for vid in snapshots[t]['vehs_at_lanes'][lane_id]:
                        #time travelled
                        totaltimetravelled_sec = totaltimetravelled_sec + t1 - t0
                        #distancetravelled
                        if snapshots[t1][vid]['S'][0]<=snapshots[t0][vid]['S'][0]:
                            distance_travelled_vid = snapshots[t1][vid]['S'][0] + length - snapshots[t0][vid]['S'][0]
                        else:
                            distance_travelled_vid = snapshots[t1][vid]['S'][0]  - snapshots[t0][vid]['S'][0]
                        #
                        totaldistancetravelled_meter = totaldistancetravelled_meter  + distance_travelled_vid
                #
                Q_interval = totaldistancetravelled_meter/1000.0/area
                K_interval = totaldistancetravelled_meter/3600.0/area
                V_interval = Q_interval/K_interval
                #
                Q[lane_id].append(Q_interval)
                K[lane_id].append(K_interval)
                V[lane_id].append(V_interval)
            start = start + rolling_sec
            end = start + Deltat_FD_sec
        
        return Q,V,K
        

    @classmethod
    def Get_QVK_from_snapshots_edie(self, snapshots, length, Deltat_FD_sec = 30, rolling_sec = 30,):
        """
        calculate the Q and K
        
            = 
        
        @input: snapshots
        
            snapshots[moment].kesys() are:
            
                self.snapshots[T]['vehs_at_lanes'] = copy.deepcopy(self.vehs_at_lanes)
                self.snapshots[T][vid] = {'S':copy.deepcopy(self.vehs_dict[vid]), \
                    #'feasibleincrement':copy.deepcopy(feasible_increment), \
                    'L':copy.deepcopy(L_dicts[vid]), \
                    'F':copy.deepcopy(F_dicts[vid]), \
                    'vehs_info_within_area_left':copy.deepcopy(vehs_info_within_area_left_dict[vid]), \
                    'vehs_info_within_area_right':copy.deepcopy(vehs_info_within_area_right_dict[vid]), \
                    'potentials':copy.deepcopy(potentials_dict[vid]), }
        
        @input: Deltat_FD_sec
        
            the time step that calculate the FD parameters. 
        
        @OUTPUT: Q and K
        
            both are dicts. 
            
            Q[laneid] = [q1, q2, q3, q4...]
            K[laneid] = [k1, k2, k3, k4...]
            V[laneid] = [v1,v2,....]
            Q unit is veh/h
            K unit is veh/km
        
        
        
        
        -----------------------------
        Q = dA/|A|, d is the distance travelled by all vehicles.
        K = t(A)/|A|, t is the total time travelled. 
        """
        #Q[laneid] = [q1, q2, q3, q4...]
        #K[laneid] = [k1, k2, k3, k4...]
        t = sorted(snapshots.keys())[0]
        Q = {lane_id:[] for lane_id in snapshots[t]['vehs_at_lanes'].keys()}
        K = {lane_id:[] for lane_id in snapshots[t]['vehs_at_lanes'].keys()}
        V = {lane_id:[] for lane_id in snapshots[t]['vehs_at_lanes'].keys()} 
        
        #unit is km.h
        area = (length/1000.0)*(Deltat_FD_sec/3600.0)
        #
        Ts = np.array(sorted(snapshots.keys()))
        #
        start = 0.0
        end = start + Deltat_FD_sec
        while end<=max(Ts):
            #unit is sec and meter.
            totaltimetravelled_sec = 0
            totaldistancetravelled_meter = 0
            #
            interval_ts = sorted(Ts[(Ts>start) & (Ts<=end)])
            for t0,t1 in zip(interval_ts[:-1], interval_ts[1:]):
                #
                for lane_id in snapshots[t]['vehs_at_lanes'].keys():
                    #
                    for vid in snapshots[t]['vehs_at_lanes'][lane_id]:
                        #time travelled
                        totaltimetravelled_sec = totaltimetravelled_sec + t1 - t0
                        #distancetravelled
                        if snapshots[t1][vid]['S'][0]<=snapshots[t0][vid]['S'][0]:
                            distance_travelled_vid = snapshots[t1][vid]['S'][0] + length - snapshots[t0][vid]['S'][0]
                        else:
                            distance_travelled_vid = snapshots[t1][vid]['S'][0]  - snapshots[t0][vid]['S'][0]
                        #
                        totaldistancetravelled_meter = totaldistancetravelled_meter  + distance_travelled_vid
                #
                Q_interval = totaldistancetravelled_meter/1000.0/area
                K_interval = totaldistancetravelled_meter/3600.0/area
                V_interval = Q_interval/K_interval
                #
                Q[lane_id].append(Q_interval)
                K[lane_id].append(K_interval)
                V[lane_id].append(V_interval)
            start = start + rolling_sec
            end = start + Deltat_FD_sec
        
        return Q,V,K
        


    @classmethod
    def interpolate(self, es, hs, e, outofbound_returned = 0):
        """
        h = self.interpolate(es,hs,e)
        
        """
        if e<min(es) or e>max(es):
            return outofbound_returned
        
        #==============================
        
        #find the idx that es[idx]<=e<=es[idx+1]
        all_idxs = np.array(range(len(es)))
        idxs_equal = all_idxs[es==e]
        if len(idxs_equal)>0:
            return hs[idxs_equal[0]]
        #
        idx = all_idxs[es<e][-1]
        
        #interploate
        #print(idx+1, len(hs), e, max(es), es[-2], es[-1])
        return (hs[idx] + hs[idx+1])/2.0
        
    
    @classmethod
    def ConvertLateralDistribution2ESAL(self, edges, hists, vehiclewidth = 1.9):
        """
        edges_new,hists_new = self.ConvertLateralDistribution2ESAL(edges, hists, vehiclewidth)
        -------------------------------
        @input: vehiclewidth
        
            unit is m. 
            
        @input: edges, hists
        
            both are arrya. 
        @output:
        
            edgesnew,histnew
            
        """
        #=========================================================
        edges_left = np.array(edges) - vehiclewidth/2.0
        edges_right = np.array(edges) + vehiclewidth/2.0 
        #
        edges_new = sorted(list(edges_left) + list(edges_right) )
        hists_new = [(self.interpolate(edges_left,hists,e) + self.interpolate(edges_right,hists,e))/2.0 for e in edges_new]
        #
        return edges_new,hists_new
        
        
        pass
    
    
    @classmethod
    def TrimAcce(self, acce, STATE, idm_paras = idm_paras):
        """
        Change the acceleraiton to make sure that the resulting vehicle constraints would not be violated. 
        
        The following conditions are considered when trimming:
        
            - if the speed reaches the maximum or the minimum, the acceleration is zero
            - if the 
        
        -----------------------------
        @OUTPUT acce_trimmed
        
            the trimmed acceleration. 
            
            
            
        """
        
        #the system  state. 
        x0,vx0,y,vy,Z_long,Z_lat = STATE[0],STATE[1],STATE[2],STATE[3],STATE[4],STATE[5]
        #x0,y,phi,v0,delta,Z_long,Z_lat = STATE_init[0],STATE_init[1],STATE_init[2],STATE_init[3],STATE_init[4],STATE_init[5],STATE_init[6]
        
        #the system  state. 
        #x,y,phi,v,delta,Z_long,Z_lat = STATE[0],STATE[1],STATE[2],STATE[3],STATE[4],STATE[5],STATE[6]
        
        #
        #if v<0 or v>=1.3*idm_paras['idm_vf']:
        if vx0<.0:
            return 1.0
        if vx0>idm_paras['idm_vf']:
            return -1
            
        #-------------------------
        return min(idm_paras['idm_a'], max(-idm_paras['idm_b'], acce))

    
    @classmethod
    def TransformPeriodic_ys_2MultiSegment_return_idxs_segments(self, ys, length,):
        """
        idxs_segments = TransformPeriodic_ys_2MultiSegment_return_idxs_segments(ys, length)
        ---------------------------
        The trajectory is period means that the vehicle will return to 0 when they are to exit the 
        
        @input: ys
        
            a 1d array that describe the longitudinal coordinate. 
            
        @input: length
        
            the length of the road
        
        -----------------------------------------------
        @OUTPUT: idxs_segments
            
            list of list
        
        ---------------------------------------------
        @Steps:
        
            - Find the idx that is decreasing
            - Add the length.
        
        """
        idxs_segments = []
        #Step1: find the index that decreeasing, i.e. ys[idx]>ys[idx-1]
        idxs_decreasing = np.where(np.diff(ys)<0)[0]
        #print(idxs_decreasing)
        #
        if len(idxs_decreasing)==0:
            #print(ys)
            return [list(range(len(ys)))]
        ##########################################ys_es
        #Note the '+1'
        #ys_es = [ys[:idxs_decreasing[0]+1]]
        
        idxs_segments = [range(idxs_decreasing[0]+1)]
        
        for idx_in_decreasing,idx_y in enumerate(idxs_decreasing):
            if idx_in_decreasing==0:continue
            #
            idx_start_in_ys = idxs_decreasing[idx_in_decreasing-1] + 1
            idx_end_in_ys = idx_y + 1
            idxs_segments.append(range(idx_start_in_ys, idx_end_in_ys))
            #
            #ys_after_add_length = ys[idx_start_in_ys:idx_end_in_ys]# + length*(idx_in_decreasing + 1))
            #ys_after_add_length = list(np.array(ys[idx_start_in_ys:idx_end_in_ys]))# + length*(idx_in_decreasing + 1))
            #
            #ys_es.append(ys_after_add_length)
            #
        #THE LAST segment
        idx_start_in_ys = idxs_decreasing[-1] + 1
        #ys_after_add_length = ys[idx_start_in_ys:]
        idxs_segments.append(range(idx_start_in_ys, len(ys)))
        return idxs_segments
        
        """

        
        """
        
        
        
    @classmethod
    def random_accelerations(self, amplification = 3.0, ts = np.linspace(0, 300, 300), period_sec = 30):
        """
        
        
        acces  = VM.TwoDimStochasticIDM.random_accelerations(ts = ts)
        """
        return np.array([amplification*np.sin(t/period_sec) for t in ts[1:]])


    @classmethod
    def GenerateLeaderTrajectories(self, ts = np.linspace(0, 300, 300), STATE_init = np.array([.0, .0, .0, .0, .0, .0]), idm_paras  = idm_paras, ):
        """
        Generate the trajectories of the leader. 
        
        Each instance, the state of the vehicle is represented by STATES:
        
        dS = F(S) dt + L(S) dW
        
        @input:     
            
            The state of the vehicle is represented as:
        
            - x,y,vx,vy,zlon,zlat.  x is the longitudinal, y is the lateral, z is the noise. 
            
        Note that in the leading trajectory we only consider the longitudinal (x) dimeensnon. 
    
        
        NOTE the coordinate system: 
        
            that the x is the logitudinal axis and y is the lateral. 
        
            The poisitive axis it downstream. 
        
            The left direction is y-positive. 
            
            If the vehicle turn left the steeer angle is positive. 
        
        
        -----------------------------------------------------------------
        
        @input: STATE_init
        
            the initial state. 
        
        @input: ts
        
            the moments. 
        
        @OUTPUT: trajectories
        
            an np.array. 
            
            Shape is (7, moments_N), where 7 is the state number, and moments_N is the number of moments. 
        
            
        
        """
        
        #the system  state. 
        x0,vx0,y,vy,Z_long,Z_lat = STATE_init[0],STATE_init[1],STATE_init[2],STATE_init[3],STATE_init[4],STATE_init[5]
        #x0,y,phi,v0,delta,Z_long,Z_lat = STATE_init[0],STATE_init[1],STATE_init[2],STATE_init[3],STATE_init[4],STATE_init[5],STATE_init[6]
        
        #the length of accelerations is len(ts-1).
        accelerations = self.random_accelerations(ts = ts)
        
        #IDM paraser. 
        idm_vf = idm_paras['idm_vf']
        idm_T = idm_paras['idm_T']
        idm_delta = idm_paras['idm_delta']
        idm_s0 = idm_paras['idm_s0']
        idm_a = idm_paras['idm_a']
        idm_b = idm_paras['idm_b']
        
        #find the xs
        xs = [x0]
        vs = [vx0]
        for deltat,acc0 in zip(np.diff(ts), accelerations):
            STATES_tmp = np.array([xs[-1], vs[-1],  y, vy, Z_long,Z_lat])
            acc= self.TrimAcce(acc0, STATE = STATES_tmp, idm_paras = idm_paras)
            #
            #print(acc0, acc)
            new_v = min(max(0, vs[-1] + deltat*acc), idm_vf)
            #
            new_x = xs[-1] + deltat*vs[-1]
            
            #
            vs.append(new_v)
            xs.append(new_x)
            
        #
        
        return np.array([xs, vs, [y]*len(ts),[0]*len(ts),[Z_long]*len(ts),[Z_lat]*len(ts)])
        
    
    
    @classmethod
    def PotentialRoadBoundary(self,  ego_state, road_bounds, lw_boundary_lanes = [3.5, 3.5], two_dim_paras = two_dim_paras, right_force_exist = True, left_force_exist = True):
        """
        
        @input: ego_state
        
            ego_state
        
            a  state of the ego vehicle. 
            
            
            The state of the vehicle is represented as:
        
            - np.array([x, vx, y, vy, zlon, zlat])  x is the longitudinal, y is the lateral, z is the noise. 
        
        @input: lw_boundary_lanes
        
            leftmost lane width and rightmost lane width. 
            
            THey should corresponds to the arg road_bounds.
        
        @input: road_bounds
        
            road_bounds = (float0 ,float1)
        
        @OUTPUT: potential_road_boundary
        
            a float. 
        
        """
        #
        x,vx,y, vy,Z_long,Z_lat = ego_state[0],ego_state[1],ego_state[2],ego_state[3],ego_state[4],ego_state[5]
        #
        #   the parameter. 
        alpha_roadbounds =  two_dim_paras['alpha_roadbounds']
        #
        #potential0 must be negative. 
        deltay = y-road_bounds[0]
        deltay0 = max(1e-10, min(abs(deltay), lw_boundary_lanes[0]/2.0))
        #print(y, road_bounds[0])
        #deltay>0 means the right force
        if abs(deltay)<lw_boundary_lanes[0]/2.0:
            if deltay>0:
                if right_force_exist:
                    potential0 = 1.0/(np.power(deltay0*2.0/lw_boundary_lanes[0], alpha_roadbounds)) - 1
                else:
                    potential0 = .0
            else:
                if left_force_exist:
                    potential0 = -(1.0/(np.power(deltay0*2.0/lw_boundary_lanes[0], alpha_roadbounds)) - 1)
                else:
                    potential0 = .0
        else:
            potential0 = .0
        #
        deltay = y-road_bounds[1]
        deltay1 = max(1e-10, min(abs(deltay), lw_boundary_lanes[1]/2.0))
        #print(deltay1*2.0/lw_boundary_lanes[1], alpha_roadbounds)
        if abs(deltay)<lw_boundary_lanes[1]/2.0:
            if deltay>0:
                if right_force_exist:
                    potential1 = 1.0/(np.power(deltay1*2.0/lw_boundary_lanes[1], alpha_roadbounds)) - 1
                else:
                    potential1 = .0
            else:
                #print(deltay1)
                if left_force_exist:
                    potential1 = -(1.0/(np.power(deltay1*2.0/lw_boundary_lanes[1], alpha_roadbounds)) -1)
                else:
                    potential1 = .0
        else:
            potential1 = .0
        #
        #
        return potential0 + potential1
        
        ############################################################################################
        ############################################################################################
        ############################################################################################
        #
        #x,vx,y, vy,Z_long,Z_lat = ego_state[0],ego_state[1],ego_state[2],ego_state[3],ego_state[4],ego_state[5]
        #
        #   the parameter. 
        alpha_roadbounds =  two_dim_paras['alpha_roadbounds']
        #
        #========================================================the first bound
        #potential0 must be negative. 
        deltay = y-road_bounds[0]
        deltay0 = max(1e-10, abs(deltay))
        #print(y, road_bounds[0])
        if abs(deltay)<lw_boundary_lanes[0]/2.0:
            if deltay>0:
                #deltay>0 means the right force
                if right_force_exist:
                    #potential0 = 1.0/(np.power(deltay0*2.0/ego_lane_lw, alpha_roadbounds)) - 1
                    potential0 = 1.0/(np.power(deltay0*2.0/ego_lane_lw, alpha_roadbounds)) - 1
                else:
                    potential0 = 0.0
                    
            else:
                if left_force_exist:
                    #potential0 = -(1.0/(np.power(deltay0*2.0/ego_lane_lw, alpha_roadbounds)) - 1)
                    potential0 = -(1.0/(np.power(deltay0*2.0/ego_lane_lw, alpha_roadbounds)) - 1)
                else:
                    potential0 = 0
        else:
            potential0 = .0
        #========================================================the second bound
        deltay = y-road_bounds[1]
        deltay1 = max(1e-10, abs(deltay))
        if abs(deltay)<lw_boundary_lanes[1]/2.0:
            if deltay>0:
                #deltay>0 means the right force
                if right_force_exist:
                    #potential1 = 1.0/(np.power(deltay1*2.0/ego_lane_lw, alpha_roadbounds)) - 1
                    potential1 = 1.0/(np.power(deltay1*2.0/ego_lane_lw, alpha_roadbounds)) - 1
                else:
                    potential1 = 0.0
            else:
                if left_force_exist:
                    #print(deltay1)
                    #potential1 = -(1.0/(np.power(deltay1*2.0/ego_lane_lw, alpha_roadbounds)) -1)
                    potential1 = -(1.0/(np.power(deltay1*2.0/ego_lane_lw, alpha_roadbounds)) -1)
                else:
                    potential1 = 0.0
        else:
            potential1 = 0.0
        
        return potential0 + potential1
        
        
    
    @classmethod
    def PotentialNeighboringLongitudinalLateral_BKP(self, ego_state, ego_lane_lw, vehs_info_within_area_left, vehs_info_within_area_right, ellipse_x, ellipse_y_left, ellipse_y_right):
        """
        Callback
        
            longitudinalforce,lateralforce = self.PotentialNeighboringLongitudinalLateral(ego_state, ego_lane_lw, vehs_ids_within_area, ellipse_x, ellipse_y)
        
        ---------------------------------------------------------------
        @input: ego_state
        
            ego_state = np.array([x, vx, y, vy, zlon, zlat])
        
        @input: vehs_ids_within_area
            
            the keys are vids. 
            
            vehs_ids_within_area[vid] = np.array([x, vx, y, vy, zlon, zlat])
            
            vehs_ids_within_area = {}
        
        @OUTPUT: longitudinalforce,lateralforce
        
            two floats. 
            
            The sign indicate the direction of the force. 
            
            negative means that the force points to the negative direction of the y axis. 
        
        --------------------------------------------------------
        
        """
        longitudinalforce = 0
        lateralforce = 0
        #######################################LEFT
        for vid in vehs_info_within_area_left.keys():
            #
            #============================total force
            neighbor_state = vehs_info_within_area_left[vid]
            #
            deltax = ego_state[0] - neighbor_state[0]
            deltay = ego_state[2] - neighbor_state[2]
            #totalforce
            tmp0  = -(ego_state[0]**2)/2.0*abs(deltax)
            #   tmp1 must be positive, as abs(deltay) must be smaller than 
            tmp1 = 1.0/(abs(deltay) - ego_lane_lw/2.0)
            #   tmp2 MUST BE positive. 
            tmp2 = 1.0/(ellipse_y_left*np.sqrt(1.0 - (deltax**2)/(ellipse_x**2)) - ego_lane_lw/2.0)
            #
            #--------------------total force
            totalforce = abs(tmp0*(tmp1 - tmp2))
            #
            #====================================longitudinalforce, MUST BE NEGATIVE. 
            #print(deltax, deltay)
            longitudinalforce = longitudinalforce - totalforce*abs(deltax)/(np.sqrt(deltax**2 + deltay**2))
            #--------------------------------------
            lateralforce = lateralforce -totalforce*abs(deltay)/(np.sqrt(deltax**2 + deltay**2))
            """
            if ego_state[2] > neighbor_state[2]:
                lateralforce = lateralforce + totalforce*abs(deltay)/(np.sqrt(deltax**2 + deltay**2))
            else:
                lateralforce = lateralforce -totalforce*abs(deltay)/(np.sqrt(deltax**2 + deltay**2))
            """
        #######################################RIGHT
        for vid in vehs_info_within_area_right.keys():
            #
            #============================total force
            neighbor_state = vehs_info_within_area_right[vid]
            #
            deltax = ego_state[0] - neighbor_state[0]
            deltay = ego_state[2] - neighbor_state[2]
            #totalforce
            tmp0  = -(ego_state[0]**2)/2.0*abs(deltax)
            #   tmp1 must be positive, as abs(deltay) must be smaller than 
            tmp1 = 1.0/(abs(deltay) - ego_lane_lw/2.0)
            #   tmp2 MUST BE positive. 
            tmp2 = 1.0/(ellipse_y_right*np.sqrt(1.0 - (deltax**2)/(ellipse_x**2)) - ego_lane_lw/2.0)
            #
            #--------------------total force
            totalforce = abs(tmp0*(tmp1 - tmp2))
            #
            #====================================longitudinalforce, MUST BE NEGATIVE. 
            longitudinalforce = longitudinalforce - totalforce*abs(deltax)/(np.sqrt(deltax**2 + deltay**2))
            #
            lateralforce = lateralforce + totalforce*abs(deltay)/(np.sqrt(deltax**2 + deltay**2))
            #--------------------------------------
            """
            if ego_state[2] > neighbor_state[2]:
                lateralforce = lateralforce + totalforce*abs(deltay)/(np.sqrt(deltax**2 + deltay**2))
            else:
                lateralforce = lateralforce -totalforce*abs(deltay)/(np.sqrt(deltax**2 + deltay**2))
            """
        
        return longitudinalforce,lateralforce
    

    
    @classmethod
    def PotentialNeighboringLongitudinalLateral_lw_base(self, ego_state, ego_lane_lw, \
            vehs_info_within_area_left, \
            vehs_info_within_area_right, \
            ellipse_x, ellipse_y_left, ellipse_y_right, \
            force_scale_deletable = 1.0, \
            lw_base = 3.5):
        """
        Callback
        
            longitudinalforce,lateralforce = self.PotentialNeighboringLongitudinalLateral(ego_state, ego_lane_lw, vehs_ids_within_area, ellipse_x, ellipse_y)
        
        ---------------------------------------------------------------
        @input: ego_state
        
            ego_state = np.array([x, vx, y, vy, zlon, zlat])
        
        @input: vehs_ids_within_area
            
            the keys are vids. 
            
            vehs_ids_within_area[vid] = np.array([x, vx, y, vy, zlon, zlat])
            
            vehs_ids_within_area = {}
        
        @OUTPUT: longitudinalforce,lateralforce
        
            two floats. 
            
            The sign indicate the direction of the force. 
            
            negative means that the force points to the negative direction of the y axis. 
        
        --------------------------------------------------------
        
        """
        #
        ego_lane_lw  = lw_base
        
        #
        longitudinalforce = .0
        lateralforce = .0
        #######################################LEFT LANE
        for vid in vehs_info_within_area_left.keys():
            #
            #============================total force
            neighbor_state = vehs_info_within_area_left[vid]
            #
            deltax = ego_state[0] - neighbor_state[0]
            deltay = ego_state[2] - neighbor_state[2]
            #deltay = deltay_not_scaled*2
            #totalforce = force_scale_deletable*abs(tmp1 - tmp2)
            tmp0  = -(ego_state[1]**2)/2.0*abs(deltax)
            #   tmp1 must be positive, as abs(deltay) must be smaller than 
            tmp1 = 1.0/(abs(deltay) - ego_lane_lw/2.0)
            #   tmp2 MUST BE positive. 
            tmp2 = 1.0/(ellipse_y_left*np.sqrt(1.0 - (deltax**2)/(ellipse_x**2)) - ego_lane_lw/2.0)
            #
            #--------------------total force
            #totalforce = abs(tmp0*(tmp1 - tmp2))
            totalforce = force_scale_deletable*abs(tmp1 - tmp2)
            
            #
            #====================================longitudinalforce, MUST BE NEGATIVE. 
            #print(deltax, deltay)
            longitudinalforce = longitudinalforce - totalforce*abs(deltax)/(np.sqrt(deltax**2 + deltay**2))
            #--------------------------------------
            lateralforce = lateralforce - totalforce*abs(deltay)/(np.sqrt(deltax**2 + deltay**2))
            """
            if ego_state[2] > neighbor_state[2]:
                lateralforce = lateralforce + totalforce*abs(deltay)/(np.sqrt(deltax**2 + deltay**2))
            else:
                lateralforce = lateralforce -totalforce*abs(deltay)/(np.sqrt(deltax**2 + deltay**2))
            """
        #######################################RIGHT LANE
        for vid in vehs_info_within_area_right.keys():
            #
            #============================total force
            neighbor_state = vehs_info_within_area_right[vid]
            #
            deltax = ego_state[0] - neighbor_state[0]
            deltay = ego_state[2] - neighbor_state[2]
            #totalforce
            tmp0  = -(ego_state[1]**2)/2.0*abs(deltax)
            #   tmp1 must be positive, as abs(deltay) must be smaller than 
            tmp1 = 1.0/(abs(deltay) - ego_lane_lw/2.0)
            #   tmp2 MUST BE positive. 
            tmp2 = 1.0/(ellipse_y_right*np.sqrt(1.0 - (deltax**2)/(ellipse_x**2)) - ego_lane_lw/2.0)
            #
            #--------------------total force
            totalforce = abs(tmp0*(tmp1 - tmp2))
            #totalforce = force_scale_deletable*abs(tmp1 - tmp2)
            #
            #====================================longitudinalforce, MUST BE NEGATIVE. 
            longitudinalforce = longitudinalforce - totalforce*abs(deltax)/(np.sqrt(deltax**2 + deltay**2))
            #
            lateralforce = lateralforce + totalforce*abs(deltay)/(np.sqrt(deltax**2 + deltay**2))
            #--------------------------------------
            """
            if ego_state[2] > neighbor_state[2]:
                lateralforce = lateralforce + totalforce*abs(deltay)/(np.sqrt(deltax**2 + deltay**2))
            else:
                lateralforce = lateralforce -totalforce*abs(deltay)/(np.sqrt(deltax**2 + deltay**2))
            """
        
        return longitudinalforce,lateralforce



    @classmethod
    def PotentialNeighboringLongitudinalLateral(self, ego_state, ego_lane_lw, \
            vehs_info_within_area_left, \
            vehs_info_within_area_right, \
            ellipse_x, ellipse_y_left, ellipse_y_right, \
            force_scale_deletable = 1.0):
        """
        Callback
        
            longitudinalforce,lateralforce = self.PotentialNeighboringLongitudinalLateral(ego_state, ego_lane_lw, vehs_ids_within_area, ellipse_x, ellipse_y)
        
        ---------------------------------------------------------------
        @input: ego_state
        
            ego_state = np.array([x, vx, y, vy, zlon, zlat])
        
        @input: vehs_ids_within_area
            
            the keys are vids. 
            
            vehs_ids_within_area[vid] = np.array([x, vx, y, vy, zlon, zlat])
            
            vehs_ids_within_area = {}
        
        @OUTPUT: longitudinalforce,lateralforce
        
            two floats. 
            
            The sign indicate the direction of the force. 
            
            negative means that the force points to the negative direction of the y axis. 
        
        --------------------------------------------------------
        
        """
        longitudinalforce = .0
        lateralforce = .0
        #######################################LEFT LANE
        for vid in vehs_info_within_area_left.keys():
            #
            #============================total force
            neighbor_state = vehs_info_within_area_left[vid]
            #
            deltax = ego_state[0] - neighbor_state[0]
            deltay = ego_state[2] - neighbor_state[2]
            #deltay = deltay_not_scaled*2
            #totalforce = force_scale_deletable*abs(tmp1 - tmp2)
            tmp0  = -(ego_state[1]**2)/2.0*abs(deltax)
            #   tmp1 must be positive, as abs(deltay) must be smaller than 
            tmp1 = 1.0/(abs(deltay) - ego_lane_lw/2.0)
            #   tmp2 MUST BE positive. 
            tmp2 = 1.0/(ellipse_y_left*np.sqrt(1.0 - (deltax**2)/(ellipse_x**2)) - ego_lane_lw/2.0)
            #
            #--------------------total force
            #totalforce = abs(tmp0*(tmp1 - tmp2))
            totalforce = force_scale_deletable*abs(tmp1 - tmp2)
            
            #
            #====================================longitudinalforce, MUST BE NEGATIVE. 
            #print(deltax, deltay)
            longitudinalforce = longitudinalforce - totalforce*abs(deltax)/(np.sqrt(deltax**2 + deltay**2))
            #--------------------------------------
            lateralforce = lateralforce - totalforce*abs(deltay)/(np.sqrt(deltax**2 + deltay**2))
            """
            if ego_state[2] > neighbor_state[2]:
                lateralforce = lateralforce + totalforce*abs(deltay)/(np.sqrt(deltax**2 + deltay**2))
            else:
                lateralforce = lateralforce -totalforce*abs(deltay)/(np.sqrt(deltax**2 + deltay**2))
            """
        #######################################RIGHT LANE
        for vid in vehs_info_within_area_right.keys():
            #
            #============================total force
            neighbor_state = vehs_info_within_area_right[vid]
            #
            deltax = ego_state[0] - neighbor_state[0]
            deltay = ego_state[2] - neighbor_state[2]
            #totalforce
            tmp0  = -(ego_state[1]**2)/2.0*abs(deltax)
            #   tmp1 must be positive, as abs(deltay) must be smaller than 
            tmp1 = 1.0/(abs(deltay) - ego_lane_lw/2.0)
            #   tmp2 MUST BE positive. 
            tmp2 = 1.0/(ellipse_y_right*np.sqrt(1.0 - (deltax**2)/(ellipse_x**2)) - ego_lane_lw/2.0)
            #
            #--------------------total force
            totalforce = abs(tmp0*(tmp1 - tmp2))
            #totalforce = force_scale_deletable*abs(tmp1 - tmp2)
            #
            #====================================longitudinalforce, MUST BE NEGATIVE. 
            longitudinalforce = longitudinalforce - totalforce*abs(deltax)/(np.sqrt(deltax**2 + deltay**2))
            #
            lateralforce = lateralforce + totalforce*abs(deltay)/(np.sqrt(deltax**2 + deltay**2))
            #--------------------------------------
            """
            if ego_state[2] > neighbor_state[2]:
                lateralforce = lateralforce + totalforce*abs(deltay)/(np.sqrt(deltax**2 + deltay**2))
            else:
                lateralforce = lateralforce -totalforce*abs(deltay)/(np.sqrt(deltax**2 + deltay**2))
            """
        
        return longitudinalforce,lateralforce





    @classmethod
    def PotentialNeighboringLateral(self, ego_state, vehs_ids_within_area):
        """
        The lateral component of the vehicles from neighboring lanes. 
        
        --------------------------------------------------------
        @input: ego_state
        
            ego_state = np.array([x, vx, y, vy, zlon, zlat])
        
        @input: vehs_ids_within_area
            
            the keys are vids. 
            
            vehs_ids_within_area[vid] = np.array([x, vx, y, vy, zlon, zlat])
            
            vehs_ids_within_area = {}
        
        @OUTPUT: lateralforce
        
            a float. 
            
            The sign indicate the direction of the force. 
            
            negative means that the force points to the negative direction of the y axis. 
        
        --------------------------------------------------------
        
        """
        
        
        
        pass
    

    @classmethod
    def PotentialNeighboringLongitudinal(self, ego_state, vehs_info_within_area):
        """
        The lateral component of the vehicles from neighboring lanes. 
        
        -------------------------------------------------
        @input: ego_state
        
            ego_state = np.array([x, vx, y, vy, zlon, zlat])
        
        @vehs_info_within_area
        
            a dict. keys are the vehicle ids and value are the vehicle states. 
        
        
        @OUTPUT: longitudinalforces
        
            a dict.  longitudinalforces[vid] is a float. 
            
           It should be always negative. 
        
        
        """
        
        
        for vid in vehs_info_within_area.keys():
            #
            neighbor_state = vehs_info_within_area[vid]
            #
            deltax = ego_state[0] - neighbor_state[0]
            deltay = ego_state[2] - neighbor_state[2]
            #totalforce
            tmp0  = -(ego_state[0]**2)/2.0*deltax
            #tmp1 = 1.0/(deltay - )
            
            
            
            pass
        
        
        longitudinalforces = {}
        
        
        
        
        
        
        
        pass

    @classmethod
    def PotentialLaneMark(self, ego_state, ego_lane_marks_coor, two_dim_paras = two_dim_paras, right_force_exist = True, left_force_exist = True):
        """
        
        
        
        @input: ego_state
        
            ego_state
        
            a  state of the ego vehicle. 
            
            
            The state of the vehicle is represented as:
        
            - np.array([x, vx, y, vy, zlon, zlat])  x is the longitudinal, y is the lateral, z is the noise. 
        
        @input: two_dim_paras
        
            the parameters for the two dimensional microscopic model. 
        
        @input: ego_lane_marks_coor
        
            ego_lane_marks_coor = (float1, float2)
        
        @input: lane_middle_line_ccor
            
            a float which represent the lane middle line coordinate. 
        
        -------------------------------------------------------
        @OUTPUT: potential
        
            a float which represent the force generated by the lane mark. 
            NOTE THAT THE sign. 
            
            
        """
        
        #
        x,vx,y, vy,Z_long,Z_lat = ego_state[0],ego_state[1],ego_state[2],ego_state[3],ego_state[4],ego_state[5]
        #
        beta_lane_marks = two_dim_paras['beta_lane_marks']
        lw = abs(min(ego_lane_marks_coor) - max(ego_lane_marks_coor))
        #
        potential = 0
        for markcoor in ego_lane_marks_coor:
            deltay = y - markcoor
            #y>markcoor means this mark is at right hand side.
            if y>markcoor:
                #print(deltay)
                if right_force_exist and abs(deltay)<lw/2.0:
                    potential = potential + (np.exp(-beta_lane_marks*deltay*deltay) - np.exp(-beta_lane_marks*lw*lw/4.0))
                    #potential = potential + (np.exp(-beta_lane_marks*deltay*deltay))
                
            else:
                if left_force_exist and abs(deltay)<lw/2.0:
                    #potential = potential - (np.exp(-beta_lane_marks*deltay*deltay))
                    potential = potential - (np.exp(-beta_lane_marks*deltay*deltay) - np.exp(-beta_lane_marks*lw*lw/4.0))
            
        return potential


    @classmethod
    def PotentialLaneMark_parabolic(self, ego_state, ego_lane_marks_coor, two_dim_paras = two_dim_paras, right_force_exist = True, left_force_exist = True):
        """
        Difference: 
            - self.PotentialLaneMark_parabolic()
            - self.PotentialLaneMark()
        
        -----------------------------------------
        @input: ego_state
        
            ego_state
        
            a  state of the ego vehicle. 
            
            
            The state of the vehicle is represented as:
        
            - np.array([x, vx, y, vy, zlon, zlat])  x is the longitudinal, y is the lateral, z is the noise. 
        
        @input: two_dim_paras
        
            the parameters for the two dimensional microscopic model. 
        
        @input: ego_lane_marks_coor
        
            ego_lane_marks_coor = (float1, float2)
        
        @input: lane_middle_line_ccor
            
            a float which represent the lane middle line coordinate. 
        
        -------------------------------------------------------
        @OUTPUT: potential
        
            a float which represent the force generated by the lane mark. 
            NOTE THAT THE sign. 
            
            
        """
        
        #
        x,vx,y, vy,Z_long,Z_lat = ego_state[0],ego_state[1],ego_state[2],ego_state[3],ego_state[4],ego_state[5]
        #
        beta_lane_marks = two_dim_paras['beta_lane_marks']
        lw = abs(min(ego_lane_marks_coor) - max(ego_lane_marks_coor))
        #
        potential = 0
        for markcoor in ego_lane_marks_coor:
            deltay = y - markcoor
            #y>markcoor means this mark is at right hand side. Then the force must be positive. 
            if y>markcoor:
                #print(deltay)
                if right_force_exist and deltay<lw/2.0:# and abs(deltay)<lw/2.0:
                    potential = potential + (deltay - lw/2.0)**2
                    #potential = potential + (np.exp(-beta_lane_marks*deltay*deltay) - np.exp(-beta_lane_marks*lw*lw/4.0))
                    #potential = potential + (np.exp(-beta_lane_marks*deltay*deltay))
                
            else:
                if left_force_exist and deltay>-lw/2.0:# and abs(deltay)<lw/2.0:
                    potential = potential - (deltay - lw/2.0)**2
                    #potential = potential - (np.exp(-beta_lane_marks*deltay*deltay))
                    #potential = potential - (np.exp(-beta_lane_marks*deltay*deltay) - np.exp(-beta_lane_marks*lw*lw/4.0))
            
        return potential
        ###############################################################################################
        ###############################################################################################
        ###############################################################################################
        #
        #x,vx,y, vy,Z_long,Z_lat = ego_state[0],ego_state[1],ego_state[2],ego_state[3],ego_state[4],ego_state[5]
        #
        beta_lane_marks = two_dim_paras['beta_lane_marks']
        #
        potential = 0
        for markcoor in lane_mark_coors:
            deltay = y - markcoor
            if y>markcoor:
                #print(deltay)
                if right_force_exist and abs(deltay)<lw/2.0:
                    potential = potential + np.exp(-beta_lane_marks*deltay*deltay)
                    
                
            else:
                if left_force_exist and abs(deltay)<lw/2.0:
                    #
                    potential = potential - np.exp(-beta_lane_marks*deltay*deltay)
            
        return potential
        
        

    @classmethod
    def F(self, ego_state, \
            vehs_info_within_area_left, \
            vehs_info_within_area_right, \
            ego_lane_lw, \
            ego_lane_middle_line_coor, \
            ego_lane_marks_coor, \
            road_bounds, \
            lw_boundary_lanes, \
            leader_state, \
            ellipse_x, ellipse_y_left, ellipse_y_right, \
            two_dim_paras = two_dim_paras, \
            idm_paras = idm_paras, \
            stochastic_proecess_name = 'OU', \
            with_neighboring_influence = True, \
            right_mark_force = True,  \
            left_bound_force = True, \
            left_mark_force = True, 
            right_bound_force = True, \
            lanemark_force_type = 'parabolic' ):
        """
        dS = F(S) dt + L(S) dW
        -----------------------------------------
        
        @input: lanemark_force_type
        
            either 'parabolic' or 'exponential'
        
        
        @input:     
            
            The state of the vehicle is represented as:
        
            - x,vx,y, vy,Z_long,Z_lat = ego_state[0],ego_state[1],ego_state[2],ego_state[3],ego_state[4],ego_state[5]
            
        @Input: neighbores_states_dict
        
            a dict containing the state of the neighbores of the ego vehicles. 
        
        @input: with_neighboring_influence
        
            whether the neighboring lanes influence should be accounted. 
        
        @input: vehs_target_lateral_dict
        
            a dict. keys are vids and values are the lane middle line coordinate at target lane. 
            
        ----------------------------------------------
        @OUTPUT: np.array([diff_x, diff_vx, diff_y, diff_vy, diff_Z_long, diff_Z_lat])
        
        
        """
        sigma_long_drift = two_dim_paras['sigma_long_drift']
        sigma_lat_drift = two_dim_paras['sigma_lat_drift']
        sigma_long = two_dim_paras['sigma_long']
        sigma_lat = two_dim_paras['sigma_lat']
        
        #
        x,vx,y,vy,Z_long,Z_lat = ego_state[0],ego_state[1],ego_state[2],ego_state[3],ego_state[4],ego_state[5]
        
        #==============================
        diff_x = vx
        diff_y = vy

        #==============================diff_Z_long, diff_Z_lat
        if stochastic_proecess_name=='OU':
            #diff_Z_long = -(sigma_long**1.0)*(Z_long**3)
            #diff_Z_lat = -(sigma_lat**1.0)*(Z_lat)
            #print(Z_long, sigma_long_drift)
            diff_Z_long = -sigma_long_drift*Z_long
            diff_Z_lat = -sigma_lat_drift*Z_lat
        elif stochastic_proecess_name=='simple':
            #diff_Z_long = -(sigma_long**1.0)*(Z_long**3)
            #diff_Z_lat = -(sigma_lat**1.0)*(Z_lat)
            #print(Z_long, sigma_long_drift)
            diff_Z_long = 0
            diff_Z_lat = 0
        elif stochastic_proecess_name=='converted':
            #the converted. 
            diff_Z_long = -(sigma_long**2)*(1-Z_long**2)*Z_long
            diff_Z_lat = -(sigma_lat**2)*(1-Z_lat**2)*Z_lat
        elif stochastic_proecess_name=='geometric':
            #
            diff_Z_long =  -sigma_long_drift*(Z_long)
            diff_Z_lat = -sigma_lat_drift*(Z_lat)
            #
        elif stochastic_proecess_name=='jacobi':
            #
            diff_Z_long = -sigma_long_drift*(Z_long - .0)
            diff_Z_lat = -sigma_lat_drift*(Z_lat - .0)
            #
        elif stochastic_proecess_name=='hyperparabolic':
            #
            #diff_Z_long = -sigma_long_drift*(Z_long - .0)
            #diff_Z_lat = -sigma_lat_drift*(Z_lat - .0)
            diff_Z_long =  -Z_long-sigma_long_drift*Z_long
            diff_Z_lat = -Z_lat-sigma_lat_drift*Z_lat
            #print(diff_Z_long, diff_Z_lat)
        elif stochastic_proecess_name=='ROU':
            #ew_state = STATES[-1] + (theta/STATES[-1] -  STATES[-1] )*deltat + sigma*brownian
            diff_Z_long = -sigma_long_drift/Z_long +  Z_long#-sigma_long_drift*(Z_long - .0)
            diff_Z_lat = -sigma_lat_drift/Z_lat +  Z_lat #-sigma_lat_drift*(Z_lat - .0)
        #
        #==============================diff_vx and diff_vy
        #potentials is a dict. Its keys are 'boundary', 'idm', 'lanemark', 'neighboringlongitudial', 'neighboringlateral', 'lanemiddleline'
        potentials = self.Potential(ego_state = ego_state, \
            vehs_info_within_area_left = vehs_info_within_area_left, \
            vehs_info_within_area_right = vehs_info_within_area_right, \
            ego_lane_lw = ego_lane_lw, \
            ego_lane_middle_line_coor = ego_lane_middle_line_coor, \
            ego_lane_marks_coor = ego_lane_marks_coor, \
            road_bounds = road_bounds, \
            lw_boundary_lanes = lw_boundary_lanes, \
            leader_state = leader_state, \
            ellipse_x = ellipse_x, \
            ellipse_y_left = ellipse_y_left, \
            ellipse_y_right = ellipse_y_right, \
            two_dim_paras = two_dim_paras,\
            idm_paras = idm_paras, \
            right_mark_force = right_mark_force,  \
            left_bound_force = left_bound_force, \
            left_mark_force = left_mark_force, 
            right_bound_force = right_bound_force, \
            lanemark_force_type  = lanemark_force_type)
        #
        #--------------diff_vx
        if with_neighboring_influence:
            diff_vx = diff_Z_long + potentials['idm'] + \
                two_dim_paras['amplyfier_intra_lanes_long']*potentials['neighboringlongitudinal']
        else:
            diff_vx = diff_Z_long + potentials['idm']# + potentials['neighboringlongitudinal']
        #---------------diff_vy
        if with_neighboring_influence:
            diff_vy = diff_Z_lat + \
                potentials['lanemiddleline'] + \
                two_dim_paras['amplyfier_bound']*potentials['boundary']   + \
                two_dim_paras['amplyfier_lane_mark']*potentials['lanemark'] + \
                two_dim_paras['amplyfier_intra_lanes_lat']*potentials['neighboringlateral']
        else:
            diff_vy = diff_Z_lat + \
                potentials['lanemiddleline'] + \
                two_dim_paras['amplyfier_bound']*potentials['boundary']   + \
                two_dim_paras['amplyfier_lane_mark']*potentials['lanemark']
        #
        #diff_vx = potentials['idm'] + potentials['neighboringlongitudinal'] + diff_Z_long
        #diff_vy = potentials['neighboringlateral'] + potentials['boundary'] + potentials['lanemark'] + potentials['lanemiddleline'] + diff_Z_lat
        #
        #
        return np.array([diff_x, diff_vx, diff_y, diff_vy, diff_Z_long, diff_Z_lat]),potentials


    @classmethod
    def F_lw_base(self, ego_state, \
            vehs_info_within_area_left, \
            vehs_info_within_area_right, \
            ego_lane_lw, \
            ego_lane_middle_line_coor, \
            ego_lane_marks_coor, \
            road_bounds, \
            lw_boundary_lanes, \
            leader_state, \
            ellipse_x, ellipse_y_left, ellipse_y_right, \
            two_dim_paras = two_dim_paras, \
            idm_paras = idm_paras, \
            stochastic_proecess_name = 'OU', \
            with_neighboring_influence = True, \
            right_mark_force = True,  \
            left_bound_force = True, \
            left_mark_force = True, 
            right_bound_force = True, \
            lanemark_force_type = 'parabolic', lw_base = 3.5 ):
        """
        Difference between:
        
            - self.F()
            - self.F_lw_base()
        
        The latter is for the case of lane width, 
        
        
        dS = F(S) dt + L(S) dW
        -----------------------------------------
        
        @input: lanemark_force_type
        
            either 'parabolic' or 'exponential'
        
        
        @input:     
            
            The state of the vehicle is represented as:
        
            - x,vx,y, vy,Z_long,Z_lat = ego_state[0],ego_state[1],ego_state[2],ego_state[3],ego_state[4],ego_state[5]
            
        @Input: neighbores_states_dict
        
            a dict containing the state of the neighbores of the ego vehicles. 
        
        @input: with_neighboring_influence
        
            whether the neighboring lanes influence should be accounted. 
        
        @input: vehs_target_lateral_dict
        
            a dict. keys are vids and values are the lane middle line coordinate at target lane. 
            
        ----------------------------------------------
        @OUTPUT: np.array([diff_x, diff_vx, diff_y, diff_vy, diff_Z_long, diff_Z_lat])
        
        
        """
        sigma_long_drift = two_dim_paras['sigma_long_drift']
        sigma_lat_drift = two_dim_paras['sigma_lat_drift']
        sigma_long = two_dim_paras['sigma_long']
        sigma_lat = two_dim_paras['sigma_lat']
        
        #
        x,vx,y,vy,Z_long,Z_lat = ego_state[0],ego_state[1],ego_state[2],ego_state[3],ego_state[4],ego_state[5]
        
        #==============================
        diff_x = vx
        diff_y = vy

        #==============================diff_Z_long, diff_Z_lat
        if stochastic_proecess_name=='OU':
            #diff_Z_long = -(sigma_long**1.0)*(Z_long**3)
            #diff_Z_lat = -(sigma_lat**1.0)*(Z_lat)
            #print(Z_long, sigma_long_drift)
            diff_Z_long = -sigma_long_drift*Z_long
            diff_Z_lat = -sigma_lat_drift*Z_lat
        elif stochastic_proecess_name=='simple':
            #diff_Z_long = -(sigma_long**1.0)*(Z_long**3)
            #diff_Z_lat = -(sigma_lat**1.0)*(Z_lat)
            #print(Z_long, sigma_long_drift)
            diff_Z_long = 0
            diff_Z_lat = 0
        elif stochastic_proecess_name=='converted':
            #the converted. 
            diff_Z_long = -(sigma_long**2)*(1-Z_long**2)*Z_long
            diff_Z_lat = -(sigma_lat**2)*(1-Z_lat**2)*Z_lat
        elif stochastic_proecess_name=='geometric':
            #
            diff_Z_long =  -sigma_long_drift*(Z_long)
            diff_Z_lat = -sigma_lat_drift*(Z_lat)
            #
        elif stochastic_proecess_name=='jacobi':
            #
            diff_Z_long = -sigma_long_drift*(Z_long - .0)
            diff_Z_lat = -sigma_lat_drift*(Z_lat - .0)
            #
        elif stochastic_proecess_name=='hyperparabolic':
            #
            #diff_Z_long = -sigma_long_drift*(Z_long - .0)
            #diff_Z_lat = -sigma_lat_drift*(Z_lat - .0)
            diff_Z_long =  -Z_long-sigma_long_drift*Z_long
            diff_Z_lat = -Z_lat-sigma_lat_drift*Z_lat
            #print(diff_Z_long, diff_Z_lat)
        elif stochastic_proecess_name=='ROU':
            #ew_state = STATES[-1] + (theta/STATES[-1] -  STATES[-1] )*deltat + sigma*brownian
            diff_Z_long = -sigma_long_drift/Z_long +  Z_long#-sigma_long_drift*(Z_long - .0)
            diff_Z_lat = -sigma_lat_drift/Z_lat +  Z_lat #-sigma_lat_drift*(Z_lat - .0)
        #
        #==============================diff_vx and diff_vy
        #potentials is a dict. Its keys are 'boundary', 'idm', 'lanemark', 'neighboringlongitudial', 'neighboringlateral', 'lanemiddleline'
        potentials = self.Potential_lw_base(ego_state = ego_state, \
            vehs_info_within_area_left = vehs_info_within_area_left, \
            vehs_info_within_area_right = vehs_info_within_area_right, \
            ego_lane_lw = ego_lane_lw, \
            ego_lane_middle_line_coor = ego_lane_middle_line_coor, \
            ego_lane_marks_coor = ego_lane_marks_coor, \
            road_bounds = road_bounds, \
            lw_boundary_lanes = lw_boundary_lanes, \
            leader_state = leader_state, \
            ellipse_x = ellipse_x, \
            ellipse_y_left = ellipse_y_left, \
            ellipse_y_right = ellipse_y_right, \
            two_dim_paras = two_dim_paras,\
            idm_paras = idm_paras, \
            right_mark_force = right_mark_force,  \
            left_bound_force = left_bound_force, \
            left_mark_force = left_mark_force, 
            right_bound_force = right_bound_force, \
            lanemark_force_type  = lanemark_force_type, lw_base = lw_base)
        #
        #--------------diff_vx
        if with_neighboring_influence:
            diff_vx = diff_Z_long + potentials['idm'] + \
                two_dim_paras['amplyfier_intra_lanes_long']*potentials['neighboringlongitudinal']
        else:
            diff_vx = diff_Z_long + potentials['idm']# + potentials['neighboringlongitudinal']
        #---------------diff_vy
        if with_neighboring_influence:
            diff_vy = diff_Z_lat + \
                potentials['lanemiddleline'] + \
                two_dim_paras['amplyfier_bound']*potentials['boundary']   + \
                two_dim_paras['amplyfier_lane_mark']*potentials['lanemark'] + \
                two_dim_paras['amplyfier_intra_lanes_lat']*potentials['neighboringlateral']
        else:
            diff_vy = diff_Z_lat + \
                potentials['lanemiddleline'] + \
                two_dim_paras['amplyfier_bound']*potentials['boundary']   + \
                two_dim_paras['amplyfier_lane_mark']*potentials['lanemark']
        #
        #diff_vx = potentials['idm'] + potentials['neighboringlongitudinal'] + diff_Z_long
        #diff_vy = potentials['neighboringlateral'] + potentials['boundary'] + potentials['lanemark'] + potentials['lanemiddleline'] + diff_Z_lat
        #
        #
        return np.array([diff_x, diff_vx, diff_y, diff_vy, diff_Z_long, diff_Z_lat]),potentials
    
    @classmethod
    def IDM_equilibrium_v_from_deltax(self, deltax, idm_paras = idm_paras):
        """
        Given the space gap, find the speed. 
        
        deltax unit is m
        
        returned speed unit is m/s
        
        """
        #
        idm_vf = idm_paras['idm_vf']
        idm_T = idm_paras['idm_T']
        idm_delta = idm_paras['idm_delta']
        idm_s0 = idm_paras['idm_s0']
        idm_a = idm_paras['idm_a']
        idm_b = idm_paras['idm_b']
        veh_len = idm_paras['veh_len']
        
        #k unit is veh/km.
        k = 1000.0/deltax
        kjam = 1000.0/(idm_s0 + veh_len)
        #
        return max(0, idm_vf - idm_vf/kjam*k)
    
    @classmethod
    def BackwardInfluenceArea(self, state_ego):
        """
        
        """
        
        
        
        
        pass
    
    
    
    @classmethod
    def F_SingleLane(self, ego_state, \
            ego_lane_lw, \
            ego_lane_middle_line_coor, \
            ego_lane_marks_coor, \
            road_bounds, \
            lw_boundary_lanes, \
            leader_state, \
            two_dim_paras = two_dim_paras, \
            idm_paras = idm_paras, \
            stochastic_proecess_name = 'OU', \
            deltax_2d_or_not = False):
        """
        
        -----------------------------------------
        dS = F(S) dt + L(S) dW
        
        @input:     
            
            The state of the vehicle is represented as:
        
            - x,vx,y, vy,Z_long,Z_lat = ego_state[0],ego_state[1],ego_state[2],ego_state[3],ego_state[4],ego_state[5]
        
        @input: deltax_2d_or_not
            
            when calculateth the acceleration for the followers, the delatax in the IDM model can be set as the longitudinal distance or the 2d distance. 
            
            if yes, then the deltax is the 2d distance
            it not then the deladx is the conventional 1d. 
        
        @Input: neighbores_states_dict
        
            a dict containing the state of the neighbores of the ego vehicles. 
        
        @input: vehs_target_lateral_dict
        
            a dict. keys are vids and values are the lane middle line coordinate at target lane. 
            
        ----------------------------------------------
        @OUTPUT: np.array([diff_x, diff_vx, diff_y, diff_vy, diff_Z_long, diff_Z_lat])
        
        
        """
        sigma_long_drift = two_dim_paras['sigma_long_drift']
        sigma_lat_drift = two_dim_paras['sigma_lat_drift']
        sigma_long = two_dim_paras['sigma_long']
        sigma_lat = two_dim_paras['sigma_lat']
        
        #
        x,vx,y,vy,Z_long,Z_lat = ego_state[0],ego_state[1],ego_state[2],ego_state[3],ego_state[4],ego_state[5]
        
        #==============================
        diff_x = vx
        diff_y = vy

        #==============================diff_Z_long, diff_Z_lat
        if stochastic_proecess_name=='OU':
            #diff_Z_long = -(sigma_long**1.0)*(Z_long**3)
            #diff_Z_lat = -(sigma_lat**1.0)*(Z_lat)
            #print(Z_long, sigma_long_drift)
            diff_Z_long = -sigma_long_drift*Z_long
            diff_Z_lat = -sigma_lat_drift*Z_lat
        elif stochastic_proecess_name=='simple':
            #diff_Z_long = -(sigma_long**1.0)*(Z_long**3)
            #diff_Z_lat = -(sigma_lat**1.0)*(Z_lat)
            #print(Z_long, sigma_long_drift)
            diff_Z_long = 0
            diff_Z_lat = 0
        elif stochastic_proecess_name=='converted':
            #the converted. 
            diff_Z_long = -(sigma_long**2)*(1-Z_long**2)*Z_long
            diff_Z_lat = -(sigma_lat**2)*(1-Z_lat**2)*Z_lat
        elif stochastic_proecess_name=='geometric':
            #
            diff_Z_long =  -sigma_long_drift*(Z_long)
            diff_Z_lat = -sigma_lat_drift*(Z_lat)
            #
        elif stochastic_proecess_name=='jacobi':
            #
            diff_Z_long = -sigma_long_drift*(Z_long - .0)
            diff_Z_lat = -sigma_lat_drift*(Z_lat - .0)
            #
        elif stochastic_proecess_name=='hyperparabolic':
            #
            #diff_Z_long = -sigma_long_drift*(Z_long - .0)
            #diff_Z_lat = -sigma_lat_drift*(Z_lat - .0)
            diff_Z_long =  -Z_long-sigma_long_drift*Z_long
            diff_Z_lat = -Z_lat-sigma_lat_drift*Z_lat
            #print(diff_Z_long, diff_Z_lat)
        elif stochastic_proecess_name=='ROU':
            #ew_state = STATES[-1] + (theta/STATES[-1] -  STATES[-1] )*deltat + sigma*brownian
            diff_Z_long = -sigma_long_drift/Z_long +  Z_long#-sigma_long_drift*(Z_long - .0)
            diff_Z_lat = -sigma_lat_drift/Z_lat +  Z_lat #-sigma_lat_drift*(Z_lat - .0)
        
        #
        #==============================diff_vx and diff_vy
        #potentials is a dict. Its keys are 'boundary', 'idm', 'lanemark', 'neighboringlongitudial', 'neighboringlateral', 'lanemiddleline'
        potentials = {}
        #
        #------------------potentials['boundary']
        #PotentialRoadBoundary(ego_state, road_bounds, lw_boundary_lanes = [3.5, 3.5], two_dim_paras = two_dim_paras, right_force_exist = True, left_force_exist = True)
        potentials['boundary'] = self.PotentialRoadBoundary(ego_state = ego_state, road_bounds = road_bounds, lw_boundary_lanes = lw_boundary_lanes, two_dim_paras = two_dim_paras)
        #
        #-----------------potentials['idm']
        if deltax_2d_or_not:
            deltax = np.sqrt((leader_state[0] - ego_state[0])**2 + (leader_state[2] - ego_state[2])**2)
        else:
            deltax = abs(leader_state[0] - ego_state[0])
        #
        potentials['idm'] = self.Potential_IDM(v_self= ego_state[1]*3.6, v_leader = leader_state[1]*3.6, deltax = deltax, idm_paras = idm_paras)
        #
        #
        #-------------------potentials['lanemiddleline']
        potentials['lanemiddleline'] = self.PotentialLaneMiddleLine(ego_state  = ego_state, ego_lane_lw = ego_lane_lw, lane_middle_line_coor = ego_lane_middle_line_coor, two_dim_paras = two_dim_paras)
        #
        diff_vx = potentials['idm'] + diff_Z_long
        #diff_vx = potentials['idm'] + potentials['neighboringlongitudinal'] + diff_Z_long
        
        #
        diff_vy = potentials['lanemiddleline'] + \
                    two_dim_paras['amplyfier_bound']*potentials['boundary'] +  \
                    diff_Z_lat# + potentials['boundary']+ potentials['lanemiddleline']
        #diff_vy = potentials['lanemiddleline'] + diff_Z_lat# + potentials['boundary']+ potentials['lanemiddleline']
        #diff_vy = potentials['neighboringlateral'] + potentials['boundary'] + potentials['lanemark'] + potentials['lanemiddleline'] + diff_Z_lat
        
        #
        return np.array([diff_x, diff_vx, diff_y, diff_vy, diff_Z_long, diff_Z_lat]),potentials


    @classmethod
    def plot_Q_distribution_laneid_as_key(self, Q, ax = False,  figsize = (5,5), bins = 30):
        """
        Q,V,K = TwoDimMicroModel.Get_QVK_from_snapshots(self.snapshots, self.length)
        
            
            Q[laneid] = [q1, q2, q3, q4...]
            K[laneid] = [k1, k2, k3, k4...]
            V[laneid] = [v1,v2,....]
            Q unit is veh/h
            K unit is veh/km
        
        """
        if isinstance(ax, bool):
            fig,ax = plt.subplots(figsize = figsize)
            ax.set_xlabel('x');ax.set_ylabel('y'); 
        
        #
        for laneid in Q.keys():
            #
            hist0,edges = np.histogram(Q[laneid], bins = bins)
            #print(sum(hist0), edges[-1] - edges[-2])
            hist = hist0/sum(hist0)/(edges[-1] - edges[-2])
            ax.plot(edges[1:], hist, label = str(laneid))

        #
        ax.grid(0)
        #ax.legend()
        return ax
        
        #pass

    @classmethod
    def plot_QK_mean_laneid_as_key_im(self, QKVs_density_as_key, ax = False,  figsize = (5,5), color = 'b', alpha = .5, label = '2'):
        """
        
        QKVs_density_as_key[density] = Q,K,V

            Q[laneid] = [q1, q2, q3, q4...]
            K[laneid] = [k1, k2, k3, k4...]
            V[laneid] = [v1,v2,....]
            Q unit is veh/h
            K unit is veh/km
        
        """
        if isinstance(ax, bool):
            fig,ax = plt.subplots(figsize = figsize)
            ax.set_xlabel('x');ax.set_ylabel('y'); 
        
        legend_added = True
        #
        for density in QKVs_density_as_key.keys():
            Q,K,V = QKVs_density_as_key[density]
            for laneid in Q.keys():
                #
                if legend_added:
                #color = np.random.uniform(size = (3,))
                    #
                    ax.plot([np.mean(K[laneid])], [np.mean(Q[laneid])],'.', color = color, alpha = alpha, label = label)
                    #
                    legend_added = False
                else:
                    ax.plot([np.mean(K[laneid])], [np.mean(Q[laneid])],'.', color = color, alpha = alpha)
        
        #
        return ax

    @classmethod
    def plot_QK_mean_laneid_as_key(self, Q,K, ax = False,  figsize = (5,5), color = 'b', alpha = .5, label = '2'):
        """
        Q,V,K = TwoDimMicroModel.Get_QVK_from_snapshots(self.snapshots, self.length)
        
            
            Q[laneid] = [q1, q2, q3, q4...]
            K[laneid] = [k1, k2, k3, k4...]
            V[laneid] = [v1,v2,....]
            Q unit is veh/h
            K unit is veh/km
        
        """
        if isinstance(ax, bool):
            fig,ax = plt.subplots(figsize = figsize)
            ax.set_xlabel('x');ax.set_ylabel('y'); 
        
        legend_added = True
        #
        for laneid in Q.keys():
            #
            if legend_added:
            #color = np.random.uniform(size = (3,))
                #
                ax.plot([np.mean(K[laneid])], [np.mean(Q[laneid])],'.', color = color, alpha = alpha, label = label)
                #
                legend_added = False
            else:
                ax.plot([np.mean(K[laneid])], [np.mean(Q[laneid])],'.', color = color, alpha = alpha)
        
        #
        return ax
        
        #pass

    @classmethod
    def plot_QK_laneid_as_key(self, Q,K, ax = False,  figsize = (5,5), color = 'b', alpha = .5):
        """
        Q,V,K = TwoDimMicroModel.Get_QVK_from_snapshots(self.snapshots, self.length)
        
            
            Q[laneid] = [q1, q2, q3, q4...]
            K[laneid] = [k1, k2, k3, k4...]
            V[laneid] = [v1,v2,....]
            Q unit is veh/h
            K unit is veh/km
        
        """
        if isinstance(ax, bool):
            fig,ax = plt.subplots(figsize = figsize)
            ax.set_xlabel('x');ax.set_ylabel('y'); 
        
        #
        for laneid in Q.keys():
            #
            #color = np.random.uniform(size = (3,))
            ax.plot(K[laneid], Q[laneid],'.', color = color, alpha = alpha)
        
        #
        return ax
        
        #pass

    @classmethod
    def plot_sim_im(self, SNAPSHOTS, ax = False, figsize = (5,3), alpha = .4,):
        """
        
        @input: STATES
        
            STATES[moment] = {vid:np.array([x,vx, y, vy, zlon, zlat])}
        
        ----------------
        - collect the vid and its starting moment t
        - collect the xy
        - collect
        
        """
        
        
        if isinstance(ax, bool):
            fig,ax = plt.subplots(figsize = figsize)
            ax.set_xlabel('x');ax.set_ylabel('y'); 
            #ax.grid();
            #ax = host_subplot(111)
            #par = ax.twinx()
            #fig,ax = plt.subplots(figsize = figsize, nrows = 1, ncols = 1)
        
        #vids_startmoments[vid] = t, means that the vid first appear at moment t. 
        vids_startmoments = {}
        vids_existing = set()
        for t in sorted(SNAPSHOTS.keys()):
            #SNAPSHOTS[t].keys are the vids
            vids = set(SNAPSHOTS[t].keys())
            #
            #find the 
            new_vids = vids.difference(vids_existing)
            for vid in new_vids:
                vids_startmoments[vid] = t
                
            vids_existing = vids
        
        #
        for vid in vids_startmoments:
            #
            t = vids_startmoments[vid]
            #find the keys (effective_ts) that vid have data. 
            tmp = np.array(sorted(SNAPSHOTS.keys()))
            effective_ts =tmp[tmp>=t]
            
            #
            xs = [SNAPSHOTS[t][vid]['S'][0] for t  in effective_ts]
            ys = [SNAPSHOTS[t][vid]['S'][2] for t  in effective_ts]
            ax.plot(xs, ys, '.')
            #ax = self.plot_path(path = sim_res, ax = ax, figsize = figsize, alpha = alpha,)
        
        #
        ax.set_xlabel('x ( m )');ax.set_ylabel('y ( m )'); ax.grid()
        
            
        plt.tight_layout()
        
        return ax


    @classmethod
    def plot_sim_heatmap_from_snapshot(self, SNAPTHOTS, ax = False, figsize = (5,3), sigma= 5, alpha = .4,bins_x = 300, bins_y = 40, idx_x = 0, idx_y = 2):
        """
        
        @input: SNAPTHOTS
        
                    #SNAPTHOTS
                    self.snapshots[T]['vehs_at_lanes'] = copy.deepcopy(self.vehs_at_lanes)
                    self.snapshots[T][vid] = {'S':copy.deepcopy(self.vehs_dict[vid]), \
                        #'feasibleincrement':copy.deepcopy(feasible_increment), \
                        'L':copy.deepcopy(L_dicts[vid]), \
                        'F':copy.deepcopy(F_dicts[vid]), \
                        'vehs_info_within_area_left':copy.deepcopy(vehs_info_within_area_left_dict[vid]), \
                        'vehs_info_within_area_right':copy.deepcopy(vehs_info_within_area_right_dict[vid]), \
                        'potentials':copy.deepcopy(potentials_dict[vid]), }
                        
        """
        import matplotlib.cm as cm
        from scipy.ndimage.filters import gaussian_filter

        def myplot(x, y, sigma= 5, bins=(bins_x, bins_y)):
            #
            heatmap, xedges, yedges = np.histogram2d(x, y, bins=bins)
            heatmap = gaussian_filter(heatmap, sigma=sigma)
        
            extent = [xedges[0], xedges[-1], yedges[0], yedges[-1]]
            return heatmap.T, extent

        if isinstance(ax, bool):
            fig,ax = plt.subplots(figsize = figsize)
            ax.set_xlabel('x');ax.set_ylabel('y'); 
            #ax.grid();
            #ax = host_subplot(111)
            #par = ax.twinx()
            #fig,ax = plt.subplots(figsize = figsize, nrows = 1, ncols = 1)
        #keys are lane ids
        t0 = sorted(SNAPTHOTS.keys())[0]
        XS = {laneid:[] for laneid in SNAPTHOTS[t0]['vehs_at_lanes'].keys()}
        YS = {laneid:[] for laneid in SNAPTHOTS[t0]['vehs_at_lanes'].keys()}
        for t in sorted(SNAPTHOTS.keys()):
            #[SNAPTHOTS[t][vid]['S'][0] for vid in SNAPTHOTS[t].keys() ]
            for laneid in SNAPTHOTS[t]['vehs_at_lanes'].keys():
                #
                xs = []
                ys = []
                #
                for vid in SNAPTHOTS[t]['vehs_at_lanes'][laneid]:
                    xs.append(SNAPTHOTS[t][vid]['S'][idx_x])
                    ys.append(SNAPTHOTS[t][vid]['S'][idx_y])
                XS[laneid].extend(xs)
                YS[laneid].extend(ys)
        
        for laneid in XS.keys():
            #print(max(XS) , min(XS), max(YS), min(YS))
            img, extent = myplot(x = XS[laneid], y = YS[laneid], sigma = sigma, bins=(bins_x, bins_y))
            #print(img.shape)
            ax.imshow(img, extent = extent, origin='lower', cmap=cm.jet,  aspect='auto', interpolation='nearest')
        """
        XS = []
        YS = []
        for t in sorted(SNAPTHOTS.keys()):
            #[SNAPTHOTS[t][vid]['S'][0] for vid in SNAPTHOTS[t].keys() ]
            xs = []
            ys = []
            for vid in SNAPTHOTS[t].keys():
                if vid=='vehs_at_lanes':continue
                xs.append(SNAPTHOTS[t][vid]['S'][idx_x])
                ys.append(SNAPTHOTS[t][vid]['S'][idx_y])
            XS.extend(xs)
            YS.extend(ys)
        #
        #print(max(XS) , min(XS), max(YS), min(YS))
        img, extent = myplot(x = XS, y = YS, sigma = sigma, bins=(bins_x, bins_y))
        print(img.shape)
        ax.imshow(img, extent = extent, origin='lower', cmap=cm.jet,  aspect='auto', interpolation='nearest')
        
        
        """
        #
        #heatmap, xedges, yedges = np.histogram2d(XS, YS, bins= (bins_x, bins_y))
        #
        #extent = [xedges[0], xedges[-1], yedges[0], yedges[-1]]
        #ax.imshow(heatmap.T, extent=extent, origin='lower')
        #
        #ax.set_xlabel('x ( m )');ax.set_ylabel('y ( m )'); ax.grid()
        
            
        plt.tight_layout()
        
        return ax





    @classmethod
    def plot_sim_scatter(self, STATES, ax = False, figsize = (5,3), alpha = .4,):
        """
        
        @input: STATES
        
            STATES[moment] = {vid:np.array([x,vx, y, vy, zlon, zlat])}
        
        
        """
        
        
        if isinstance(ax, bool):
            fig,ax = plt.subplots(figsize = figsize)
            ax.set_xlabel('x');ax.set_ylabel('y'); 
            #ax.grid();
            #ax = host_subplot(111)
            #par = ax.twinx()
            #fig,ax = plt.subplots(figsize = figsize, nrows = 1, ncols = 1)

        for t in sorted(STATES.keys()):
            
            
            
            
            
            xs = [STATES[t][vid][0] for vid in STATES[t].keys()]
            ys = [STATES[t][vid][2] for vid in STATES[t].keys()]
            
            ax.plot(xs, ys, '.')
            #ax = self.plot_path(path = sim_res, ax = ax, figsize = figsize, alpha = alpha,)
        
        #
        ax.set_xlabel('x ( m )');ax.set_ylabel('y ( m )'); ax.grid()
        
            
        plt.tight_layout()
        
        return ax
        









    @classmethod
    def Potential_IDM(self, v_self= 10, v_leader = 10, deltax =20, idm_paras = idm_paras):
        """
        IDM formation output, the acceleration. 
        
        Note that the delta_v is defined as v_follower-v_leader. 
        
        @type v: float, unit is km/h
        
        @type vf: km/h.
        
        
        @type T: float.
        @param: T, unit is sec
            Average safe time headway.
            
        @type delta: delta:float
        @param: delta
            parameter in the model.
            
            
        @type s0:float
        @param: s0
            parameter 
        
        @OUTPUT: a
            unit is m/s2.
        """
        #
        idm_vf = idm_paras['idm_vf']
        idm_T = idm_paras['idm_T']
        idm_delta = idm_paras['idm_delta']
        idm_s0 = idm_paras['idm_s0']
        idm_a = idm_paras['idm_a']
        idm_b = idm_paras['idm_b']
        
        #
        v_self=v_self/3.6
        v_leader = v_leader/3.6
        #vf = idm_vf/3.6
        
        #builtins.tmp = v_self,v_leader
        
        try:
            #print()
            #
            s_star = idm_s0+v_self*idm_T+v_self*(v_self - v_leader)/(2.0*np.sqrt(idm_a*idm_b))
            #
            a = 1.0*idm_a*(1-np.power(v_self/idm_vf, idm_delta)-(s_star*s_star)/(deltax*deltax))
            
        except Exception as e:
            
            print('deltax = ',deltax,', v_self=',v_self,', v_leader',v_leader)
            raise ValueError(e)
            
        return a

        ##########################DEBUG
        v_self=v_self/3.6
        v_leader = v_leader/3.6
        vf = idm_vf/3.6
        
        builtins.tmp = v_self,v_leader
        
        try:
            s_star = idm_s0+v_self*idm_T+v_self*(v_self - v_leader)/(2.0*np.sqrt(idm_a*idm_b))
            a = 1.0*idm_a*(1-np.power(v_self/vf, idm_delta)-(s_star*s_star)/(deltax*deltax))
        except Exception as e:
            
            print('deltax = ',deltax,', v_self=',v_self,', v_leader',v_leader)
            raise ValueError(e)
            
        return a




    @classmethod
    def L(self, state, \
            two_dim_paras = two_dim_paras, \
            idm_paras = idm_paras, \
            stochastic_proecess_name = 'OU',\
            right_mark_force = True,  \
            left_bound_force = True, \
            left_mark_force = True, 
            right_bound_force = True ):
        """
        
        dS = F(S) dt + L(S) dW
        
        """
        sigma_long = two_dim_paras['sigma_long']
        sigma_lat = two_dim_paras['sigma_lat']
        
        #
        x,vx,y, vy,Z_long,Z_lat = state[0],state[1],state[2],state[3],state[4],state[5]
        
        #------------------------------------------
        if stochastic_proecess_name=='OU':
            tmp_long = sigma_long
            tmp_lat = sigma_lat
            #
        elif stochastic_proecess_name=='simple':
            #diff_Z_long = -(sigma_long**1.0)*(Z_long**3)
            #diff_Z_lat = -(sigma_lat**1.0)*(Z_lat)
            #print(Z_long, sigma_long_drift)
            tmp_long =  sigma_long#*min(1.0, np.sqrt(vx**2 + vy**2)/idm_paras['idm_vf'])
            tmp_lat = sigma_lat#*min(1, np.sqrt(vx**2 + vy**2)/idm_paras['idm_vf'])
            
        elif stochastic_proecess_name=='converted':
            #the converted. 
            tmp_long =  sigma_long*(1.0-Z_long**2)
            tmp_lat = sigma_lat*(1-Z_lat**2)
            #
        elif stochastic_proecess_name=='geometric':
            #
            tmp_long =  sigma_long*(Z_long)
            tmp_lat = sigma_lat*(Z_lat)
            #
        elif stochastic_proecess_name=='hyperparabolic':
            #
            tmp_long = sigma_long
            tmp_lat = sigma_lat
            
        elif stochastic_proecess_name=='jacobi':
            #new_state = STATES[-1] - theta*(STATES[-1])*deltat + sigma*np.sqrt((STATES[-1]+.5)*(.5-STATES[-1]))*brownian
            Z_long = max(-.499999, min(Z_long, .4999999))
            tmp_long =   np.sqrt(sigma_long*(Z_long+.5)*(.5-Z_long))
            #print(Z_lat, (.5-Z_lat), (Z_lat+.5))
            Z_lat = max(-.499999, min(Z_lat, .4999999))
            tmp_lat = np.sqrt(sigma_lat*(Z_lat+.5)*(.5-Z_lat))
        elif stochastic_proecess_name=='ROU':
            #
            tmp_long =  sigma_long
            tmp_lat = sigma_lat
        
        #
        #tmp_long =  sigma_long*(1.0-Z_long**2)
        #tmp_lat = sigma_lat*(1-Z_lat**2)
        
        array = np.array([[.0, .0, .0, .0, tmp_long, .0], \
                          [.0, .0, .0, .0, 0, tmp_lat]])
        
        
        return array.T
    
    @classmethod
    def Sample_two_dim_paras(self, ):
        """
        Sample the paramters such that the hetegreoenesou 
        
        """
        
        
        
        pass

    @classmethod
    def PotentialLaneMiddleLine(self, ego_state, ego_lane_lw, lane_middle_line_coor, two_dim_paras = two_dim_paras):
        """
        
        If ego_lateral>lane_middle_line_coor, return a negative value. 
        
        --------------------------------
        @input: lane_middle_line_coor
        
            a float. 
        
        """
        beta = two_dim_paras['beta_lane_middle_line']
        
        #ego_state[2] is y. 
        #if ego_state[2]>lane_middle_line_coor:
        deltay = ego_state[2]-lane_middle_line_coor
        #
        tmp0 = beta*beta*(2.0*deltay-ego_lane_lw)*np.exp(-beta*beta*(deltay-ego_lane_lw/2.0)*(deltay-ego_lane_lw/2.0))
        tmp1 = beta*beta*(2.0*deltay+ego_lane_lw)*np.exp(-beta*beta*(deltay+ego_lane_lw/2.0)*(deltay+ego_lane_lw/2.0))
        #ys2 =  beta*beta*(2.0*deltay-ego_lane_lw)*np.exp(-beta*beta*(deltay-ego_lane_lw/2.0)*(deltay-ego_lane_lw/2.0)) - \
        #        beta*beta*(2.0*deltay+lw)*np.exp(-beta*beta*(deltay+lw/2.0)*(deltay+lw/2.0))
        
        
        return (tmp0 - tmp1)*ego_state[3]

        ################################################################
        ################################################################
        
        beta = two_dim_paras['beta_lane_middle_line']
        #ego_state[2] is y. 
        #if ego_state[2]>lane_middle_line_coor:
        #deltay = ego_state[2]-lane_middle_line_coor
        deltay = y -lane_middle_line_coor
        #
        tmp0 = beta*beta*(2.0*deltay-ego_lane_lw)*np.exp(-beta*beta*(deltay-ego_lane_lw/2.0)*(deltay-ego_lane_lw/2.0))
        tmp1 = beta*beta*(2.0*deltay+ego_lane_lw)*np.exp(-beta*beta*(deltay+ego_lane_lw/2.0)*(deltay+ego_lane_lw/2.0))
        #ys2 =  beta*beta*(2.0*deltay-ego_lane_lw)*np.exp(-beta*beta*(deltay-ego_lane_lw/2.0)*(deltay-ego_lane_lw/2.0)) - \
        #        beta*beta*(2.0*deltay+lw)*np.exp(-beta*beta*(deltay+lw/2.0)*(deltay+lw/2.0))
        return (tmp0 - tmp1)*u


    
    @classmethod
    def PotentialLaneMiddleLine_BKP(self, ego_state, ego_lane_lw, lane_middle_line_coor, two_dim_paras = two_dim_paras):
        """
        
        If ego_lateral>lane_middle_line_coor, return a negative value. 
        
        --------------------------------
        @input: lane_middle_line_coor
        
            a float. 
        
        """
        beta = two_dim_paras['beta_lane_middle_line']
        
        #ego_state[2] is y. 
        
        #if ego_state[2]>lane_middle_line_coor:
        deltay = ego_state[2]-lane_middle_line_coor
        #
        return -ego_lane_lw/2.0*beta*deltay*np.exp(-beta*beta*deltay*deltay)

    
    @classmethod
    def Potential_lw_base(self, ego_state, \
            vehs_info_within_area_left, \
            vehs_info_within_area_right, \
            ego_lane_lw, \
            ego_lane_middle_line_coor, \
            ego_lane_marks_coor, \
            road_bounds, \
            lw_boundary_lanes, \
            leader_state, \
            ellipse_x, ellipse_y_left, ellipse_y_right, \
            two_dim_paras = two_dim_paras, \
            idm_paras = idm_paras, \
            right_mark_force = True,  \
            left_bound_force = True, \
            left_mark_force = True, 
            right_bound_force = True, \
            lanemark_force_type = 'parabolic', \
            lw_base = 3.5):
        """
        Difference between:
        
            - self.Potential()
            - self.Potential_lw_base()
        
        The latter have a specfal base lane width parameter: lw_base
        
        The latter is for the case of lane width, 
        
        
        
        Calculate the potential of the vehicle. 
        
        @input: ego_state
        
            ego_state
        
            a  state of the ego vehicle. 
            
            
            The state of the vehicle is represented as:
        
            - np.array([x, vx, y, vy, zlon, zlat])  x is the longitudinal, y is the lateral, z is the noise. 
        
        @input: lw_boundary_lanes
        
            tuple. 
            
        
            leftmost lane width and rightmost lane width. 
        
        @input: lanes_marks_coors
            
            lanes_marks_coors = (left, right). 
            
            The coordinate of left mark and right mark. 
        
        @input: neighbores_states_dict
        
            neighbores_states_dict[neighbor_id] = state_dict. 
            
            state_dict is a dictionary containing the np.array([x, vx, y, vy, zlon, zlat])
        -------------------------------------------------
        @OUTPUT: potentials
        
            potentials['boundary'], a float
            potentials['lanemark'], a float
            potentials['idm'], a float
            potentials['lanemiddleline'], a float.
            potentials['neighboringlongitudinal'], a float
            potentials['neighboringlateral'], a float.
        
        """
        #x, vx, y, vy, zlon, zlat = 
        #=============================
        potentials = {}
        #
        #------------------potentials['boundary']
        potentials['boundary'] = self.PotentialRoadBoundary(ego_state = ego_state, road_bounds = road_bounds, lw_boundary_lanes = lw_boundary_lanes, two_dim_paras = two_dim_paras, right_force_exist = right_bound_force, left_force_exist = left_bound_force)
        #
        #-----------------potentials['lanemark']
        if lanemark_force_type=='parabolic':
            potentials['lanemark'] = self.PotentialLaneMark_parabolic(ego_state = ego_state, ego_lane_marks_coor = ego_lane_marks_coor, two_dim_paras = two_dim_paras, right_force_exist = right_mark_force, left_force_exist = left_mark_force)
        elif lanemark_force_type=='exponential':
            potentials['lanemark'] = self.PotentialLaneMark(ego_state = ego_state, ego_lane_marks_coor = ego_lane_marks_coor, two_dim_paras = two_dim_paras, right_force_exist = right_mark_force, left_force_exist = left_mark_force)
        #
        #-----------------potentials['idm']
        potentials['idm'] = self.Potential_IDM(v_self= ego_state[1]*3.6, v_leader = leader_state[1]*3.6, deltax =abs(leader_state[0] - ego_state[0]), idm_paras = idm_paras)
        #
        #-------------------potentials['lanemiddleline']
        potentials['lanemiddleline'] = self.PotentialLaneMiddleLine(ego_state  = ego_state, \
            ego_lane_lw = ego_lane_lw, \
            lane_middle_line_coor = ego_lane_middle_line_coor, \
            two_dim_paras = two_dim_paras)
        #
        #-----------------potentials['neighboringlongitudinal']
        longitudinalforce,lateralforce = self.PotentialNeighboringLongitudinalLateral_lw_base(ego_state = ego_state, \
            ego_lane_lw = ego_lane_lw, \
            vehs_info_within_area_left = vehs_info_within_area_left, \
            vehs_info_within_area_right = vehs_info_within_area_right, \
            ellipse_x = ellipse_x, \
            ellipse_y_left  = ellipse_y_left, \
            ellipse_y_right = ellipse_y_right, \
            lw_base = lw_base)
        #
        #
        potentials['neighboringlongitudinal'] = longitudinalforce
        potentials['neighboringlateral'] = lateralforce
        
        
        return potentials


    
    @classmethod
    def Potential(self, ego_state, \
            vehs_info_within_area_left, \
            vehs_info_within_area_right, \
            ego_lane_lw, \
            ego_lane_middle_line_coor, \
            ego_lane_marks_coor, \
            road_bounds, \
            lw_boundary_lanes, \
            leader_state, \
            ellipse_x, ellipse_y_left, ellipse_y_right, \
            two_dim_paras = two_dim_paras, \
            idm_paras = idm_paras, \
            right_mark_force = True,  \
            left_bound_force = True, \
            left_mark_force = True, 
            right_bound_force = True, \
            lanemark_force_type = 'parabolic'):
        """
        Calculate the potential of the vehicle. 
        
        @input: ego_state
        
            ego_state
        
            a  state of the ego vehicle. 
            
            
            The state of the vehicle is represented as:
        
            - np.array([x, vx, y, vy, zlon, zlat])  x is the longitudinal, y is the lateral, z is the noise. 
        
        @input: lw_boundary_lanes
        
            tuple. 
            
        
            leftmost lane width and rightmost lane width. 
        
        @input: lanes_marks_coors
            
            lanes_marks_coors = (left, right). 
            
            The coordinate of left mark and right mark. 
        
        @input: neighbores_states_dict
        
            neighbores_states_dict[neighbor_id] = state_dict. 
            
            state_dict is a dictionary containing the np.array([x, vx, y, vy, zlon, zlat])
        -------------------------------------------------
        @OUTPUT: potentials
        
            potentials['boundary'], a float
            potentials['lanemark'], a float
            potentials['idm'], a float
            potentials['lanemiddleline'], a float.
            potentials['neighboringlongitudinal'], a float
            potentials['neighboringlateral'], a float.
        
        """
        #x, vx, y, vy, zlon, zlat = 
        #=============================
        potentials = {}
        #
        #------------------potentials['boundary']
        potentials['boundary'] = self.PotentialRoadBoundary(ego_state = ego_state, road_bounds = road_bounds, lw_boundary_lanes = lw_boundary_lanes, two_dim_paras = two_dim_paras, right_force_exist = right_bound_force, left_force_exist = left_bound_force)
        #
        #-----------------potentials['lanemark']
        if lanemark_force_type=='parabolic':
            potentials['lanemark'] = self.PotentialLaneMark_parabolic(ego_state = ego_state, ego_lane_marks_coor = ego_lane_marks_coor, two_dim_paras = two_dim_paras, right_force_exist = right_mark_force, left_force_exist = left_mark_force)
        elif lanemark_force_type=='exponential':
            potentials['lanemark'] = self.PotentialLaneMark(ego_state = ego_state, ego_lane_marks_coor = ego_lane_marks_coor, two_dim_paras = two_dim_paras, right_force_exist = right_mark_force, left_force_exist = left_mark_force)
        #
        #-----------------potentials['idm']
        potentials['idm'] = self.Potential_IDM(v_self= ego_state[1]*3.6, v_leader = leader_state[1]*3.6, deltax =abs(leader_state[0] - ego_state[0]), idm_paras = idm_paras)
        #
        #-------------------potentials['lanemiddleline']
        potentials['lanemiddleline'] = self.PotentialLaneMiddleLine(ego_state  = ego_state, \
            ego_lane_lw = ego_lane_lw, \
            lane_middle_line_coor = ego_lane_middle_line_coor, \
            two_dim_paras = two_dim_paras)
        #
        #-----------------potentials['neighboringlongitudinal']
        longitudinalforce,lateralforce = self.PotentialNeighboringLongitudinalLateral(ego_state = ego_state, \
            ego_lane_lw = ego_lane_lw, \
            vehs_info_within_area_left = vehs_info_within_area_left, \
            vehs_info_within_area_right = vehs_info_within_area_right, \
            ellipse_x = ellipse_x, \
            ellipse_y_left  = ellipse_y_left, \
            ellipse_y_right = ellipse_y_right, )
        #
        potentials['neighboringlongitudinal'] = longitudinalforce
        potentials['neighboringlateral'] = lateralforce
        
        
        return potentials






class LateralWandering():
    """
    The class for the lateral wandering analysis. 
    """
    
    @classmethod
    def meta_discretize_multilane(self, laneids, lanes_marks_coors, u_bounds = (-1.0, 1.0), n_deltay = 10, n_deltau = 10):
        """
        
        states = twodim.LateralWandering.meta_discretize_multilane()
        
        --------------------------------------------------
        Given multiple lane, discretize the system state:
        
            [y0,u0,y1,u1,y2,u2,....yN,uN], where N is the number of the lanes. 
        
        
        ------------------------------------------
        @input: laneids,lanes_marks_coors
            
            laneids is an ordered iterable. 
            
            lanes_marks_coors[laneid] = (left_mark_coor, right_mark_coor)
        
        @input: n_deltay and n_deltau
        
            the number of the discretization of the y and u.
            
        @OUTPUT: states
        
            state = states[idx]
            
            state shoudld be:
            
                [(y0a,y0b),(u0a,u0b), (y1a,y1b), (u1a,u1b),...]
        
        """
        
        #===========================================Discretize ys and us
        us = np.linspace(u_bounds[0], u_bounds[1], n_deltau)
        ys_dict = {}
        for laneid in laneids:
            #
            ys_dict[laneid] = np.linspace(lanes_marks_coors[laneid][0], lanes_marks_coors[laneid][1], n_deltay)
        #
        #=======================================================
        Intervals = []
        for laneid in laneids:
            ys = ys_dict[laneid]
            #========================================================
            discretized_y_intervals = []
            discretized_u_intervals = []
            #----------------------------
            for i in range(len(ys)-1):
                #
                discretized_y_intervals.append((ys[i], ys[i+1]))
            #----------------------------
            for i in range(len(us)-1):
                #
                discretized_u_intervals.append((us[i], us[i+1]))
            #========================================================
            #
            Intervals.append(discretized_y_intervals)
            #
            Intervals.append(discretized_u_intervals)
        #
        #=======================================================
        #
        return itertools.product(*Intervals)
        
        pass
    
    
    
    @classmethod
    def meta_discretize(self, y_bounds = (-1.75, 1.75), u_bounds = (-1.0, 1.0), n_deltay = 10, n_deltau = 10):#, two_dim_paras = two_dim_paras):
        """
        Disceretize the 
        
        ------------------------------------
        @input: y_bounds, u_bounds
        
            y_bounds = (y_MIN, y_MAX), unit is m
            
            u_bounds = (u_MIN, u_MAX), unit is m/s
            
        @input: two_dim_paras
        
            two_dim_paras['y_MAX']
            two_dim_paras['u_MAX']
        
        @output: discretized_y_intervals,discretized_u_intervals,states
            
            discretized_y_intervals[idx] = (y_lower, y_upper)
            
            discretized_u_intervals[idx] = (u_lower, u_upper)
            
            states[idx]  = (((y_lower, y_upper)), (u_lower, u_upper))
            
            NOTE that len(states) = len(discretized_y_intervals)*len(discretized_u_intervals)
        
        """
        #=======================================================
        #discretized_y_intervals[idx] = (y_lower, y_upper)
        discretized_y_intervals = []
        #discretized_u_intervals[idx] = (u_lower, u_upper)
        discretized_u_intervals = []
        
        #=======================================================
        ys = np.linspace(y_bounds[0], y_bounds[1], n_deltay)
        us = np.linspace(u_bounds[0], u_bounds[1], n_deltau)
        
        #
        for i in range(len(ys)-1):
            #
            discretized_y_intervals.append((ys[i], ys[i+1]))
        for i in range(len(us)-1):
            #
            discretized_u_intervals.append((us[i], us[i+1]))
        #
        #====================================================
        states = [(i,j) for i,j in itertools.product(discretized_y_intervals, discretized_u_intervals)]
        
        return discretized_y_intervals,discretized_u_intervals,states
        

class LateralWanderingSingleLane(LateralWandering):
    """
    
    """
    @classmethod
    def std_from_paths(self, selected_marginal_ts, tspan, sim_res):
        """
        calculate the std from the simulated paths. 
        
        =========================
        @input: sim_res
        
            sim_res[idx] is a 2d array, with shape (len(ts), 3). 3 is because there are three variables: y,u,z

        
        @input: selected_marginal_ts, tspan,
        
            both are lists or 1d array. 
            
            the former one is the 
        
            tspan = np.linspace(0, 100, 100)
            #
            two_dim_paras = {'alpha_roadbounds': .05, 'beta_lane_marks':3.6, 'beta_lane_middle_line':.56, \
                'sigma_long':.1, 'sigma_lat':.2, 'sigma_long_drift':1.0, 'sigma_lat_drift':1.0, 'gamma_middle_line':2.0, 'theta_ou':.1, \
                        'amplyfier_lane_mark':10}

            sim_res = twodim.LateralWanderingSingleLane.sim(tspan = tspan, two_dim_paras = two_dim_paras)
        
        sim_res[idx] shape is (len(ts), *3). '*3' because for each lane there are three states: y,u,z. 
        

 


        """
        stds = []
        
        tspan = np.array(tspan)
        #ax = axs[0]
        
        
        for t in selected_marginal_ts:
            #----------------------------------
            indexes = np.array(range(len(tspan)))
            #
            tmp = abs(tspan-t)
            idx_most_near = indexes[tmp==min(tmp)][0]
            #data = [res[idx_most_near, 0] for res in sim_res if max(res[:,0])<lw/2.0]
            data = [res[idx_most_near, 0] for res in sim_res]
            
            stds.append(np.std(data))
            
        return stds
            
        """
        #data = [res[idx_most_near, 0] for res in sim_res if max(res[:,0])<lw/2.0]
        hist0,edges = np.histogram(data, bins = bins)
        #print(sum(hist0), edges[-1] - edges[-2])
        hist = hist0/sum(hist0)/(edges[-1] - edges[-2])
        #
        if isinstance(label, bool):
            ax.plot(edges[1:], hist)
        else:
            ax.plot(edges[1:], hist, label = label)
        """

    
    
    @classmethod
    def sim(self, tspan = np.linspace(0, 100, 100), STATE_init = [.0, .0, .0], two_dim_paras = two_dim_paras, lw = 3.5, length = 1000, stochastic_proecess_name='OU', N_paths = 100, left_mark_force = True, right_mark_force = True, left_bound_force = True, right_bound_force = True):
        """
        
        @input: single_lane_ini_states
        
            the initial state for single lane. 
            The state is [y,u,z].
            
            The state of the whole road then can be expressed as:
            
                STATE_init = copy.deepcopy(single_lane_init_states*len(lanes_ids))
        
        @input: two_dim_paras_dict4each_lane
        
            two_dim_paras_dict4each_lane[lane_id] = two_dim_paras
        
        @inut: 
        
        """
        import sdeint
        
        #print(len(road_attrs['lanes_ids']))
        #===================================
        def F(STATE, t):
            """
            #road_attrs = copy.deepcopy(road_attrs), 
            @input: state
            
                state = [y0, u0, z0,]
                
            
            @OUTPUT: diff_states
            
                diff_states = np.array([diff_y, diff_u, diff_Z_lat])
                
            """
            #===============================diff_y
            diff_y = STATE[1]
            #
            #===============================diff_u
            #diff_u
            force = self.force(state = STATE, lw = lw, two_dim_paras = two_dim_paras, left_mark_force = left_mark_force, right_mark_force = right_mark_force, left_bound_force = left_bound_force, right_bound_force = right_bound_force)
            #
            diff_u = force + STATE[2]
            
            #========================diff_z_i
            Z_lat = STATE[2]
            #iff_Z_long, diff_Z_lat
            if stochastic_proecess_name=='OU':
                #diff_Z_long = -(sigma_long**1.0)*(Z_long**3)
                #diff_Z_lat = -(sigma_lat**1.0)*(Z_lat)
                #print(Z_long, sigma_long_drift)
                #diff_Z_long = -two_dim_paras['sigma_long_drift']*Z_long
                diff_Z_lat = -two_dim_paras['sigma_lat_drift']*Z_lat
            elif stochastic_proecess_name=='simple':
                #diff_Z_long = -(sigma_long**1.0)*(Z_long**3)
                #diff_Z_lat = -(sigma_lat**1.0)*(Z_lat)
                #print(Z_long, sigma_long_drift)
                #diff_Z_long = 0
                diff_Z_lat = 0
            elif stochastic_proecess_name=='converted':
                #the converted. 
                #diff_Z_long = -(two_dim_paras['sigma_long']**2)*(1-Z_long**2)*Z_long
                diff_Z_lat = -(two_dim_paras['sigma_lat']**2)*(1-Z_lat**2)*Z_lat
            elif stochastic_proecess_name=='geometric':
                #
                #diff_Z_long =  -two_dim_paras['sigma_long_drift']*(Z_long)
                diff_Z_lat = -two_dim_paras['sigma_lat_drift']*(Z_lat)
                #
            elif stochastic_proecess_name=='jacobi':
                #
                #diff_Z_long = -two_dim_paras['sigma_long_drift']*(Z_long - .0)
                diff_Z_lat = -two_dim_paras['sigma_lat_drift']*(Z_lat - .0)
                #
            elif stochastic_proecess_name=='hyperparabolic':
                #
                #diff_Z_long = -sigma_long_drift*(Z_long - .0)
                #diff_Z_lat = -sigma_lat_drift*(Z_lat - .0)
                #diff_Z_long =  -Z_long-two_dim_paras['sigma_long_drift']*Z_long
                diff_Z_lat = -Z_lat-two_dim_paras['sigma_lat_drift']*Z_lat
                #print(diff_Z_long, diff_Z_lat)
            elif stochastic_proecess_name=='ROU':
                #ew_state = STATES[-1] + (theta/STATES[-1] -  STATES[-1] )*deltat + sigma*brownian
                #diff_Z_long = -two_dim_paras['sigma_long_drift']/Z_long +  Z_long#-sigma_long_drift*(Z_long - .0)
                diff_Z_lat = -two_dim_paras['sigma_lat_drift']/Z_lat +  Z_lat #-sigma_lat_drift*(Z_lat - .0)
                #----------------------
            #diffs[idx] = diff_Z_lat
            #--------------------------------------------
            #print(np.array([diff_y, diff_u, diff_Z_lat]))
            return np.array([diff_y, diff_u, diff_Z_lat])
            
        #===================================
        def L(STATE, t):
            """
            @OUTPUT: res
            
                shape is np.zeros((3*n_lanes, n_lanes))
                
                
            """
            #S = [y, vy, z], z is the nois. 
            res = np.zeros((3, 1))
            #
            #
            Z_lat = STATE[2]
            #
            sigma_lat = two_dim_paras['sigma_lat']
            
            #------------------------------------------
            if stochastic_proecess_name=='OU':
                tmp_lat = sigma_lat
                #
            elif stochastic_proecess_name=='simple':
                tmp_lat = sigma_lat
                
            elif stochastic_proecess_name=='converted':
                tmp_lat = sigma_lat*(1-Z_lat**2)
                #
            elif stochastic_proecess_name=='geometric':
                tmp_lat = sigma_lat*(Z_lat)
                #
            elif stochastic_proecess_name=='hyperparabolic':

                tmp_lat = sigma_lat
                
            elif stochastic_proecess_name=='jacobi':
                #print(Z_lat, (.5-Z_lat), (Z_lat+.5))
                Z_lat = max(-.499999, min(Z_lat, .4999999))
                tmp_lat = np.sqrt(sigma_lat*(Z_lat+.5)*(.5-Z_lat))
            elif stochastic_proecess_name=='ROU':

                tmp_lat = sigma_lat
            #
            res[2, 0] = tmp_lat
            
            #
            #
            return res
        
        
        
        """
        #Simulation. 
        results = []
        #---------------------------------------------
        for iterr in range(N_paths):
            #result.shape is (len(tspan),2), '2' corresponds to Z.
            #   the first column is lateral displacement, and the 2nd columns is the noize. 
            #
            realtime_STATE = copy.deepcopy(STATE_init)
            #
            delta_ts = np.diff(tspan)
            #
            for t,deltat in zip(tspan[1:], delta_ts):
                #get F and L
                
                
                
                pass
            
            
            
            result = sdeint.itoint(F, L, STATE_init, tspan)
            results.append(result)
            #res_Y.append(result[:,0])
            #res_Z.append(result[:,1])
        #-----------------------------------------
        #np.array(res_Y) shape is N_paths,len(tspan)
        #np.array(res_Z) shape is N_paths,len(tspan)
        return results
        """
        #Simulation. 
        results = []
        #---------------------------------------------
        for iterr in range(N_paths):
            #result.shape is (len(tspan),2), '2' corresponds to Z.
            #   the first column is lateral displacement, and the 2nd columns is the noize. 
            result = sdeint.itoint(F, L, STATE_init, tspan)
            results.append(result)
            #res_Y.append(result[:,0])
            #res_Z.append(result[:,1])
        #-----------------------------------------
        #np.array(res_Y) shape is N_paths,len(tspan)
        #np.array(res_Z) shape is N_paths,len(tspan)
        return results
        #return pd.DataFrame(res_Y, columns =  tspan).T,pd.DataFrame(res_Z, columns =  tspan).T
        
        
    
    
    @classmethod
    def sampler_mcint(self, y0a, y0b, u0a, u0b, N_mc = 1):
        """
        
        """
        ys = np.random.uniform(y0a, y0b, size = N_mc)
        us = np.random.uniform(u0a, u0b, size = N_mc)
        
        return zip(ys,us)
        
    @classmethod
    def TransitionBetweenStates_mcint(self, source_state, end_state, current_t_for_sigma_computing = np.inf, deltat_sec = .5, ego_lane_lw = 3.5, two_dim_paras = two_dim_paras, N_mc = 1000):
        """
        Double integral using mcint:
        
            - integration_res, error =  scipy.integrate.dblquad(func, a, b, gfun, hfun, args=(), epsabs=1.49e-08, epsrel=1.49e-08)
            
            
        The 'func' is self.transition_from_point_to_discretized_state
        
            - transition_prob_from_point_to_discretized_state(self,  point, end_IntervalType_state, current_t_for_sigma_computing = np.inf, deltat_sec = .5, ego_lane_lw = 3.5, two_dim_paras = two_dim_paras)
        
        The usage of scipy.integrate.dblquad is as follows:
        
                    
            from scipy import integrate
            f = lambda y, x: x*y**2
            integrate.dblquad(f, 0, 2, 0, 1)
                (0.6666666666666667, 7.401486830834377e-15)
            
            
            
        ---------------------------------------------------------------
        
        @input: source_state, end_state
            
            #
            source_state = ([y0a, y0b], [u0a, u0b])
            
            #
            end_state = ([y1a, y1b], [u1a, u1b])
        
        @input: integration_res, error
        
            error is an estimate of the error. 
        
        ----------------------------------
        """
        #======================
        (y0a,y0b),(u0a, u0b) = source_state
        (y1a, y1b),(u1a, u1b) = end_state
        
        if y0a+deltat_sec*u0a>y1b or y0b+deltat_sec*u0b<y1a:
            return .0
        
        #======================
        def func(u,y, end_IntervalType_state, current_t_for_sigma_computing = current_t_for_sigma_computing, deltat_sec = deltat_sec, ego_lane_lw = ego_lane_lw, two_dim_paras = two_dim_paras):
            #
            #
            #
            return self.transition_prob_from_point_to_discretized_state(point = (y,u), end_IntervalType_state = end_IntervalType_state, current_t_for_sigma_computing = current_t_for_sigma_computing, deltat_sec = deltat_sec, ego_lane_lw = ego_lane_lw, two_dim_paras = two_dim_paras)
            
            
        
        #
        #print(y0a, y0b, u0a, u0b)
        #SampledPoints[idx] = (y,u)
        SampledPoints = self.sampler_mcint(y0a, y0b, u0a, u0b, N_mc = int(N_mc))
        #
        RES = []
        for y,u in SampledPoints:
            res  = self.transition_prob_from_point_to_discretized_state(point = (y,u), end_IntervalType_state = end_state, current_t_for_sigma_computing = current_t_for_sigma_computing, deltat_sec = deltat_sec, ego_lane_lw = ego_lane_lw, two_dim_paras = two_dim_paras)
            
            
            RES.append(res)
        
        return sum(RES)/N_mc
        
        
        #integration_res, error = integrate.dblquad(func, a = y0a, b = y0b, gfun = u0a, hfun = u0b, args = (end_state, current_t_for_sigma_computing, deltat_sec, ego_lane_lw, two_dim_paras), )
        
        #=======================================
        #return integration_res, error
    
    
    
    
    @classmethod
    def TransitionBetweenStates(self, source_state, end_state, current_t_for_sigma_computing = np.inf, deltat_sec = .5, ego_lane_lw = 3.5, two_dim_paras = two_dim_paras):
        """
        Double integral using:
        
            - integration_res, error =  scipy.integrate.dblquad(func, a, b, gfun, hfun, args=(), epsabs=1.49e-08, epsrel=1.49e-08)
            
            
        The 'func' is self.transition_from_point_to_discretized_state
        
            - transition_prob_from_point_to_discretized_state(self,  point, end_IntervalType_state, current_t_for_sigma_computing = np.inf, deltat_sec = .5, ego_lane_lw = 3.5, two_dim_paras = two_dim_paras)
        
        The usage of scipy.integrate.dblquad is as follows:
        
                    
            from scipy import integrate
            f = lambda y, x: x*y**2
            integrate.dblquad(f, 0, 2, 0, 1)
                (0.6666666666666667, 7.401486830834377e-15)
            
            
            
        ---------------------------------------------------------------
        
        @input: source_state, end_state
            
            #
            source_state = ([y0a, y0b], [u0a, u0b])
            
            #
            end_state = ([y1a, y1b], [u1a, u1b])
        
        @input: integration_res, error
        
            error is an estimate of the error. 
        
        ----------------------------------
        """
        #======================
        (y0a,y0b),(u0a, u0b) = source_state
        (y1a, y1b),(u1a, u1b) = end_state
        
        #======================
        def func(u,y, end_IntervalType_state, current_t_for_sigma_computing = current_t_for_sigma_computing, deltat_sec = deltat_sec, ego_lane_lw = ego_lane_lw, two_dim_paras = two_dim_paras):
            #
            #
            #
            return self.transition_prob_from_point_to_discretized_state(point = (y,u), end_IntervalType_state = end_IntervalType_state, current_t_for_sigma_computing = current_t_for_sigma_computing, deltat_sec = deltat_sec, ego_lane_lw = ego_lane_lw, two_dim_paras = two_dim_paras)
        
        #
        print(y0a, y0b, u0a, u0b)
        integration_res, error = integrate.dblquad(func, a = y0a, b = y0b, gfun = u0a, hfun = u0b, args = (end_state, current_t_for_sigma_computing, deltat_sec, ego_lane_lw, two_dim_paras), )
        
        #=======================================
        return integration_res, error

    
    
    @classmethod
    def force(self, state, lw, two_dim_paras = two_dim_paras, left_mark_force = True, right_mark_force = True, left_bound_force = True, right_bound_force = True):
        """
        
        @input: left_mark_force = True, right_mark_force = True, left_bound_force = True, right_bound_force = True
        
        @OUTPUT: diff_u
        
            the differential of the u, the lateral speed. 
            
        
        """
        #
        y,u,z = state
        #
        #=========force_mark
        force_mark = self.force_mark( y = y, lane_mark_coors = (-lw/2.0, lw/2.0), two_dim_paras = two_dim_paras, left_force_exist = left_mark_force, right_force_exit = right_mark_force)
        #
        #=========foce bound. 
        force_bound = self.force_road_bound(y = y, ego_lane_lw  = lw,  two_dim_paras = two_dim_paras, left_force_exist = left_bound_force, right_force_exit = right_bound_force)
        #
        #========force middleline. 
        force_middle_line = self.force_middleline(y = y, u = u, ego_lane_lw  = lw,  two_dim_paras = two_dim_paras)
        #
        
        return force_mark + force_bound + force_middle_line
    
    
    
    @classmethod
    def force_mark(self, y, lane_mark_coors = (-3.5/2.0, 3.5/2.0), two_dim_paras = two_dim_paras, left_force_exist = True, right_force_exit = True):
        """
        Note that the left direction points to the positive y axis. 
        ----------------------------
        @input: left_force_exist and right_force_exit
        
            both are bool. 
            
            Determine whether the left or right boundary exist. 
            
        
        @input: two_dim_paras
        
            the parameters for the two dimensional microscopic model. 
        
        @input: ego_lane_marks_coor
        
            ego_lane_marks_coor = (float1, float2)
        
        @input: lane_middle_line_ccor
            
            a float which represent the lane middle line coordinate. 
        
        -------------------------------------------------------
        @OUTPUT: potential
        
            a float which represent the force generated by the lane mark. 
            NOTE THAT THE sign. 
            
            
        """
        
        #
        #x,vx,y, vy,Z_long,Z_lat = ego_state[0],ego_state[1],ego_state[2],ego_state[3],ego_state[4],ego_state[5]
        #
        beta_lane_marks = two_dim_paras['beta_lane_marks']
        #
        potential = 0
        for markcoor in lane_mark_coors:
            deltay = y - markcoor
            if y>markcoor:
                #print(deltay)
                if right_force_exit:
                    potential = potential + np.exp(-beta_lane_marks*deltay*deltay)
                
            else:
                if left_force_exist:
                    potential = potential - np.exp(-beta_lane_marks*deltay*deltay)
            
        return potential
    
    @classmethod
    def force_middleline(self, y, u, ego_lane_lw  = 3.5,  two_dim_paras = two_dim_paras):
        """
        
        """
        
        beta = two_dim_paras['beta_lane_middle_line']
        
        #ego_state[2] is y. 
        #if ego_state[2]>lane_middle_line_coor:
        deltay = y
        #
        tmp0 = beta*beta*(2.0*deltay-ego_lane_lw)*np.exp(-beta*beta*(deltay-ego_lane_lw/2.0)*(deltay-ego_lane_lw/2.0))
        tmp1 = beta*beta*(2.0*deltay+ego_lane_lw)*np.exp(-beta*beta*(deltay+ego_lane_lw/2.0)*(deltay+ego_lane_lw/2.0))
        #ys2 =  beta*beta*(2.0*deltay-ego_lane_lw)*np.exp(-beta*beta*(deltay-ego_lane_lw/2.0)*(deltay-ego_lane_lw/2.0)) - \
        #        beta*beta*(2.0*deltay+lw)*np.exp(-beta*beta*(deltay+lw/2.0)*(deltay+lw/2.0))
        
        
        return (tmp0 - tmp1)*u
    
    
    
    
    @classmethod
    def force_road_bound_BKP(self, y, ego_lane_lw  = 3.5,  two_dim_paras = two_dim_paras):
        """
        
        """
        road_bounds = (-ego_lane_lw/2.0, ego_lane_lw/2.0)
        #
        #x,vx,y, vy,Z_long,Z_lat = ego_state[0],ego_state[1],ego_state[2],ego_state[3],ego_state[4],ego_state[5]
        #
        #   the parameter. 
        alpha_roadbounds =  two_dim_paras['alpha_roadbounds']
        #
        #potential0 must be negative. 
        deltay = y-road_bounds[0]
        deltay0 = max(1e-10, abs(deltay))
        #print(y, road_bounds[0])
        if deltay>0:
            potential0 = 1.0/(np.power(deltay0*2.0/ego_lane_lw, alpha_roadbounds)) - 1
        else:
            potential0 = -(1.0/(np.power(deltay0*2.0/ego_lane_lw, alpha_roadbounds)) - 1)
        
        #
        deltay = y-road_bounds[1]
        deltay1 = max(1e-10, abs(deltay))
        #print(deltay1*2.0/lw_boundary_lanes[1], alpha_roadbounds)
        if deltay>0:
            potential1 = 1.0/(np.power(deltay1*2.0/ego_lane_lw, alpha_roadbounds)) - 1
        else:
            #print(deltay1)
            potential1 = -(1.0/(np.power(deltay1*2.0/ego_lane_lw, alpha_roadbounds)) -1)
        
        #
        return potential0 + potential1
    
    
    
    
    
    
    @classmethod
    def force_road_bound(self, y, ego_lane_lw  = 3.5,  two_dim_paras = two_dim_paras, left_force_exist = True, right_force_exit = True):
        """
        Left direction points to the positive y-axis. 
        In other 
        -------------------------------------
        @input: left_force_exist and right_force_exit
        
            both are bool. 
            
            Determine whether the left or right boundary exist. 
            
            Notet hat 
        
        """
        road_bounds = (-ego_lane_lw/2.0, ego_lane_lw/2.0)
        #
        #x,vx,y, vy,Z_long,Z_lat = ego_state[0],ego_state[1],ego_state[2],ego_state[3],ego_state[4],ego_state[5]
        #
        #   the parameter. 
        alpha_roadbounds =  two_dim_paras['alpha_roadbounds']
        #
        #potential0 must be negative. 
        deltay = y-road_bounds[0]
        deltay0 = max(1e-10, abs(deltay))
        #print(y, road_bounds[0])
        if deltay>0:
            #=====force from the right bound
            if right_force_exit:
                potential0 = 1.0/(np.power(deltay0*2.0/ego_lane_lw, alpha_roadbounds)) - 1
            else:
                potential0 = .0
        else:
            #=====force from the left bound
            if left_force_exist:
                potential0 = -(1.0/(np.power(deltay0*2.0/ego_lane_lw, alpha_roadbounds)) - 1)
            else:
                potential0 = .0
        #
        deltay = y-road_bounds[1]
        deltay1 = max(1e-10, abs(deltay))
        #print(deltay1*2.0/lw_boundary_lanes[1], alpha_roadbounds)
        if deltay>0:
            #=====force from the right bound
            if right_force_exit:
                potential1 = 1.0/(np.power(deltay1*2.0/ego_lane_lw, alpha_roadbounds)) - 1
            else:
                potential1 = .0
        else:
            #print(deltay1)
            #=====force from the left bound
            if left_force_exist:
                potential1 = -(1.0/(np.power(deltay1*2.0/ego_lane_lw, alpha_roadbounds)) -1)
            else:
                potential1 = .0
        #
        return potential0 + potential1

    
    @classmethod
    def plot_lateral_marginals(self, selected_marginal_ts, tspan, sim_res, lw = 3.5, ax = False, figsize = (5,3), alpha = .4, bins = 20, filtering = True, label = False):
        """
        
        @input: selected_marginal_ts, tspan,
        
            both are lists or 1d array. 
            
            the former one is the 
        
            tspan = np.linspace(0, 100, 100)
            #
            two_dim_paras = {'alpha_roadbounds': .05, 'beta_lane_marks':3.6, 'beta_lane_middle_line':.56, \
                'sigma_long':.1, 'sigma_lat':.2, 'sigma_long_drift':1.0, 'sigma_lat_drift':1.0, 'gamma_middle_line':2.0, 'theta_ou':.1, \
                        'amplyfier_lane_mark':10}

            sim_res = twodim.LateralWanderingSingleLane.sim(tspan = tspan, two_dim_paras = two_dim_paras)
        
        sim_res[idx] shape is (len(ts), *3). '*3' because for each lane there are three states: y,u,z. 
        

 
        
        """
        
        #
        if isinstance(ax, bool):
            fig,ax = plt.subplots(figsize = figsize,)
            #fig,axs = plt.subplots(figsize = figsize, nrows = 2, ncols = 1)
            #ax = host_subplot(111)
            #par = ax.twinx()
        tspan = np.array(tspan)
        #ax = axs[0]
        
        for t in selected_marginal_ts:
            #----------------------------------
            indexes = np.array(range(len(tspan)))
            #
            tmp = abs(tspan-t)
            idx_most_near = indexes[tmp==min(tmp)][0]
            data = [res[idx_most_near, 0] for res in sim_res]
            #data = [res[idx_most_near, 0] for res in sim_res if max(res[:,0])<lw/2.0]
            hist0,edges = np.histogram(data, bins = bins)
            #print(sum(hist0), edges[-1] - edges[-2])
            hist = hist0/sum(hist0)/(edges[-1] - edges[-2])
            #
            if isinstance(label, bool):
                ax.plot(edges[1:], hist)
            else:
                ax.plot(edges[1:], hist, label = label)
        
        #ax.set_xlim(road_attrs['lanes_marks_coors'][lane_id])
        ax.set_xlabel('Lateral location (m)');ax.set_ylabel('Frequency'); ax.grid();#ax.set_title('(a)')
        
        """
        #plot the u
        ax = axs[1]
        for res in sim_res:
            for i in range(n_lanes):
                ax.plot(tspan, res[:, i*3 + 1])
        ax.set_xlabel('Time ( sec )');ax.set_ylabel('u (m/s) '); ax.grid();ax.set_title('(a)')
        """

        #
        return ax

    @classmethod
    def plot_debug(self, tspan, sim_res, ax = False, figsize = (5,3), alpha = .4, idx_ploted = 0):
        """
        
        sim_res.shape  is (len(ts), 3)
        
        res = twodim.LateralWanderingSingleLane.sim()
        sim_res,road_attrs = twodim.LateralWanderingMultiLane.sim(stochastic_proecess_name='OU', tspan = np.linspace(0, 100, 400), N_paths=10)
        
        sim_res[idx] shape is (len(ts), n_lanes*3). '*3' because for each lane there are three states: y,u,z. 
        
        road_attrs.keys():
        
            ['lanes_ids',
             'lws',
             'length',
             'lws_dict',
             'two_dim_paras_dict',
             'left_lane_id',
             'right_lane_id',
             'ellipse_y_left',
             'ellipse_y_right',
             'lanes_middle_line',
             'lanes_marks_coors',
             'road_bounds',
             'lw_boundary_lanes']
        
        """
        
        #
        if isinstance(ax, bool):
            fig,ax = plt.subplots(figsize = figsize,)
            #fig,axs = plt.subplots(figsize = figsize, nrows = 2, ncols = 1)
            #ax = host_subplot(111)
            #par = ax.twinx()
        
        #plot the y
        #ax = axs[0]
        for res in sim_res:
            #for i in range(n_lanes):
            #ax.plot(tspan[1:],  np.diff(res[:, idx_ploted]))
            ax.plot(tspan,  res[:, idx_ploted])
        
        #ax.set_xlabel('Time ( sec )');ax.set_ylabel('y (m) '); ax.grid();ax.set_title('(a)')
        return ax

    @classmethod
    def plot_paths(self, tspan, sim_res, ax = False, figsize = (5,3), alpha = .4, idx_ploted = 0, N_plotted = 10):
        """
        
        sim_res.shape  is (len(ts), 3)
        
        res = twodim.LateralWanderingSingleLane.sim()
        sim_res,road_attrs = twodim.LateralWanderingMultiLane.sim(stochastic_proecess_name='OU', tspan = np.linspace(0, 100, 400), N_paths=10)
        
        sim_res[idx] shape is (len(ts), n_lanes*3). '*3' because for each lane there are three states: y,u,z. 
        
        road_attrs.keys():
        
            ['lanes_ids',
             'lws',
             'length',
             'lws_dict',
             'two_dim_paras_dict',
             'left_lane_id',
             'right_lane_id',
             'ellipse_y_left',
             'ellipse_y_right',
             'lanes_middle_line',
             'lanes_marks_coors',
             'road_bounds',
             'lw_boundary_lanes']
        
        """
        
        #
        if isinstance(ax, bool):
            fig,ax = plt.subplots(figsize = figsize,)
            #fig,axs = plt.subplots(figsize = figsize, nrows = 2, ncols = 1)
            #ax = host_subplot(111)
            #par = ax.twinx()
        
        #plot the y
        #ax = axs[0]
        selected = np.random.choice(list(range(len(sim_res))), min(N_plotted, len(sim_res)))
        #for res in sim_res:
        for idx in selected:
            res = sim_res[idx]
            #for i in range(n_lanes):
            ax.plot(tspan, res[:, idx_ploted])
        
        ax.set_xlabel('Time ( sec )');ax.set_ylabel('y (m) '); ax.grid();ax.set_title('(a)')
        
        """
        #plot the u
        ax = axs[1]
        for res in sim_res:
            for i in range(n_lanes):
                ax.plot(tspan, res[:, i*3 + 1])
        ax.set_xlabel('Time ( sec )');ax.set_ylabel('u (m/s) '); ax.grid();ax.set_title('(a)')
        """

        #
        return ax
    
    
    @classmethod
    def transition_prob_from_point_to_discretized_state(self,  point, end_IntervalType_state, current_t_for_sigma_computing = np.inf, deltat_sec = .5, ego_lane_lw = 3.5, two_dim_paras = two_dim_paras):
        """
        The probabiltiy of the transition from one state point (y,u) to a discrtetized state inverval, or end_state. 
        
        The end_state is defined as ([y1a, y1b], [u1a, u1b]).
        
        The returned probability is an integration over normal distribution. 
        
        ----------------------------------------
        @input: point
        
            a tuple, point = (y,u)
        
        @input: current_t_for_sigma_computing
        
            the current moment for the computation of sigma. 
            
        @input: end_IntervalType_state
            
            end_IntervalType_state = ([y1a, y1b], [u1a, u1b])
            
        @input: 
            
            two_dim_paras the parameters used include two_dim_paras['theta_ou'] and two_dim_paras['sigma_lat']
            
            It is defined as:
            
                two_dim_paras = {'alpha_roadbounds':1.51, 'beta_lane_marks':3.6, 'beta_lane_middle_line':.56, 'sigma_long':.01, 'sigma_lat':.1, 'sigma_long_drift':1.0, 'sigma_lat_drift':1.0, 'gamma_middle_line':1.0, 'theta_ou':.1,}

        
        """
        y, u = point
        #========================================================
        y_interval = end_IntervalType_state[0]
        u_interval = end_IntervalType_state[1]
        
        #========================================================outof bound then return 0
        if (y+deltat_sec*u>max(y_interval)) or (y+deltat_sec*u<min(y_interval)):
            #
            return .0
        
        #========================================================find the sigma, a float. 
        #   sigma and mu are both float. 
        if current_t_for_sigma_computing==np.inf:
        
            sigma = two_dim_paras['sigma_lat']**2/(2.0*two_dim_paras['theta_ou'])
        else:
            #
            tmp = 1.0 - np.exp(-2.0*two_dim_paras['theta_ou']*current_t_for_sigma_computing)
            #
            sigma = two_dim_paras['sigma_lat']**2/(2.0*two_dim_paras['theta_ou'])*tmp
        
        #===============================================================find the mu, a float. 
        #mu = u + (force_lane_middle_line + force_bound)*deltat_sec
        #--------------------force 
        force_lane_middle_line = self.force_middleline(y = y, u = u, ego_lane_lw  = ego_lane_lw,  two_dim_paras = two_dim_paras)
        #
        force_road_bound = self.force_road_bound(y = y, ego_lane_lw  = ego_lane_lw,  two_dim_paras = two_dim_paras)
        #
        mu = u + (force_lane_middle_line + force_road_bound)*deltat_sec
        #
        #=====================================================
        
        res = normal_integral(x = min(u_interval), y = max(u_interval),  mean = mu, sigma = sigma)
        #
        #print(res)
        #
        return res
    
    @classmethod
    def MarginalFromMatrix(self, PoweredP, states):
        """
        
        
        @input: 
        
            state = states[idx]
        
            state = [(y0a, y0b), (u0a, u0b)]
        
        @input: poweredP
        
            the matrix that is powered by np.linalg.matrix_power(P,n). shaple of P is len(states)*len(states)
        
        
        """
        #
        ys = np.array([(state[0][0]+state[0][1])/2.0 for state in states])
        #
        init_ps = .0*ys
        init_ps[ys==min(abs(ys))] = 1.0/(sum(ys==min(abs(ys))))
        #print(init_ps)
        #init_ps = np.array([1.0/len(states)]*len(states))
        #init_ps[ys==min(abs(ys))] = 1.0/(sum(ys==min(abs(ys))))
        #
        ps0 = np.matmul(init_ps, PoweredP)
        
        ys_not_repeated = sorted(set(ys))
        #init_ps = np.array([0]*len(states))
        
        
        ps = [sum(ps0[ys==y]) for y in ys_not_repeated]
        
        
        return ys_not_repeated,ps
        
        pass
    
    
    @classmethod
    def TransitionMatrixConstruct(self, y_bounds = (-1.75, 1.75), u_bounds = (-1.0, 1.0), n_deltay = 10, n_deltau = 10, current_t_for_sigma_computing = np.inf, deltat_sec = .5, ego_lane_lw = 3.5, two_dim_paras = two_dim_paras,  revise = True):
        """
        Construct the transition matrix P
        
        Find the stable distribution x:
        
            x = np.linalg.solve(P.T - np.eye(P.shape[0]), np.zeros(( P.shape[0],)))
            
        """
        #
        #Discretize the system
        discretized_y_intervals,discretized_u_intervals,states= self.meta_discretize( y_bounds = y_bounds, u_bounds = u_bounds, n_deltay = n_deltay, n_deltau = n_deltau)
        #
        #shape is len(states),len(states)
        P = pd.DataFrame(np.zeros((len(states), len(states))))
        #
        for idx0,idx1 in itertools.permutations(range(len(states)), 2):
            s,e = states[idx0],states[idx1]
            tmp = self.TransitionBetweenStates_mcint(source_state = s, end_state = e,  current_t_for_sigma_computing = current_t_for_sigma_computing, deltat_sec = deltat_sec, ego_lane_lw = ego_lane_lw, two_dim_paras = two_dim_paras)
            P.iloc[idx0,idx1] = tmp
            #i=i+1
            #print(idx0, idx1, P.shape, tmp)
        
        if revise:
            Pnew = copy.deepcopy(P)
            for i in range(P.shape[0]):
                rowsum = sum(P.iloc[i, :])
                if rowsum==0:
                    Pnew.iloc[i,i] = 1.0
                elif rowsum!=1.0:
                    Pnew.iloc[i, :] = P.loc[i, :]/rowsum
        #
        return Pnew,states


class LateralWanderingMultiLane(LateralWandering):
    """
    
    """
    @classmethod
    def std_from_paths_normalized(self, selected_marginal_ts, tspan, sim_res, idx_y = 0, middleline_coor = 0, lw = 3.5):
        """
        calculate the std from the simulated paths. 
        
        =========================
        @input: sim_res
        
            sim_res[idx] is a 2d array, with shape (len(ts), 3*lanes_number). 3 is because there are three variables: y,u,z
            
            idx_y is 3*n. if idx_y = 0, it means the y at first lane (leftmost lane)
            
        
        @input: selected_marginal_ts, tspan,
        
            both are lists or 1d array. 
            
            the former one is the 
        
            tspan = np.linspace(0, 100, 100)
            #
            two_dim_paras = {'alpha_roadbounds': .05, 'beta_lane_marks':3.6, 'beta_lane_middle_line':.56, \
                'sigma_long':.1, 'sigma_lat':.2, 'sigma_long_drift':1.0, 'sigma_lat_drift':1.0, 'gamma_middle_line':2.0, 'theta_ou':.1, \
                        'amplyfier_lane_mark':10}

            sim_res = twodim.LateralWanderingSingleLane.sim(tspan = tspan, two_dim_paras = two_dim_paras)
        
        sim_res[idx] shape is (len(ts), *3). '*3' because for each lane there are three states: y,u,z. 
        

 


        """
        stds = []
        means = []
        skews = []
        tspan = np.array(tspan)
        #ax = axs[0]
        
        
        for t in selected_marginal_ts:
            #----------------------------------
            indexes = np.array(range(len(tspan)))
            #
            tmp = abs(tspan-t)
            idx_most_near = indexes[tmp==min(tmp)][0]
            #data = [res[idx_most_near, 0] for res in sim_res if max(res[:,0])<lw/2.0]
            data0 = np.array([res[idx_most_near, idx_y] for res in sim_res])
            #
            data = (data0-middleline_coor)/lw
            #
            stds.append(np.std(data))
            means.append(np.mean(data))
            skews.append(scipy.stats.skew(data))
            
        return stds,means,skews
    
    
    
    @classmethod
    def std_from_paths(self, selected_marginal_ts, tspan, sim_res, idx_y = 0):
        """
        calculate the std from the simulated paths. 
        
        =========================
        @input: sim_res
        
            sim_res[idx] is a 2d array, with shape (len(ts), 3*lanes_number). 3 is because there are three variables: y,u,z
            
            idx_y is 3*n. if idx_y = 0, it means the y at first lane (leftmost lane)
            
        
        @input: selected_marginal_ts, tspan,
        
            both are lists or 1d array. 
            
            the former one is the 
        
            tspan = np.linspace(0, 100, 100)
            #
            two_dim_paras = {'alpha_roadbounds': .05, 'beta_lane_marks':3.6, 'beta_lane_middle_line':.56, \
                'sigma_long':.1, 'sigma_lat':.2, 'sigma_long_drift':1.0, 'sigma_lat_drift':1.0, 'gamma_middle_line':2.0, 'theta_ou':.1, \
                        'amplyfier_lane_mark':10}

            sim_res = twodim.LateralWanderingSingleLane.sim(tspan = tspan, two_dim_paras = two_dim_paras)
        
        sim_res[idx] shape is (len(ts), *3). '*3' because for each lane there are three states: y,u,z. 
        

 


        """
        stds = []
        means = []
        skews = []
        tspan = np.array(tspan)
        #ax = axs[0]
        
        
        for t in selected_marginal_ts:
            #----------------------------------
            indexes = np.array(range(len(tspan)))
            #
            tmp = abs(tspan-t)
            idx_most_near = indexes[tmp==min(tmp)][0]
            #data = [res[idx_most_near, 0] for res in sim_res if max(res[:,0])<lw/2.0]
            data = [res[idx_most_near, idx_y] for res in sim_res]
            
            stds.append(np.std(data))
            means.append(np.mean(data))
            skews.append(scipy.stats.skew(data))
            
        return stds,means,skews
    
    
    
    @classmethod
    def histogram_from_sim_paths(self, tspan, sim_res, road_attrs, ):
        """
        
        
        sim_res,road_attrs = twodim.LateralWanderingMultiLane.sim(stochastic_proecess_name='OU', tspan = np.linspace(0, 100, 400), N_paths=10)
        
        sim_res[idx] shape is (len(ts), n_lanes*3). '*3' because for each lane there are three states: y,u,z. 
        
        road_attrs.keys():
        
            ['lanes_ids',
             'lws',
             'length',
             'lws_dict',
             'two_dim_paras_dict',
             'left_lane_id',
             'right_lane_id',
             'ellipse_y_left',
             'ellipse_y_right',
             'lanes_middle_line',
             'lanes_marks_coors',
             'road_bounds',
             'lw_boundary_lanes']
             
        @OUTPUT: 
        
            histogram_normalized_dict.
            
            histogram_normalized_dict[lane_id] = (edges, hists).  plt.plot(edges, hists)
            
            Note that the histogram
            
            
            
        
        """
        
        
        
        pass
    
    
    
    @classmethod
    def plot_pair_distance2marks_just_for_twolanes(self, sim_res,  road_attrs, ax = False, figsize = (5,3), alpha = .4, ):
        """
        
        plot the distances of the vehicles to the lane marks JUST for the cases of two lanes road.
        
        -------------------------------------------------------
        @input: sim_res
        
            res = sim_res[idx] is an array. 
            
            res.shape is (len(ts), 6). 6 is because 2*3: for each lane there are 3 state variables: y,u and z. z is the noise and u is the lateral speed. 
        
        @input: road_attrs
        
            sim_res,road_attrs = twodim.LateralWanderingMultiLane.sim(stochastic_proecess_name='OU', tspan = np.linspace(0, 100, 400), N_paths=10)
            
            sim_res[idx] shape is (len(ts), n_lanes*3). '*3' because for each lane there are three states: y,u,z. 
            
            road_attrs.keys():
            
                ['lanes_ids',
                 'lws',
                 'length',
                 'lws_dict',
                 'two_dim_paras_dict',
                 'left_lane_id',
                 'right_lane_id',
                 'ellipse_y_left',
                 'ellipse_y_right',
                 'lanes_middle_line',
                 'lanes_marks_coors',
                 'road_bounds',
                 'lw_boundary_lanes']
        
        """
        #
        if isinstance(ax, bool):
            fig,ax = plt.subplots(figsize = figsize,)
            #fig,axs = plt.subplots(figsize = figsize, nrows = 2, ncols = 1)
            #ax = host_subplot(111)
            #par = ax.twinx()
        #tspan = np.array(tspan)
        lane_id0 = road_attrs['lanes_ids'][0]
        lane_id1 = road_attrs['lanes_ids'][1]
        for res in sim_res:
            #
            #lane_id0 = road_attrs['lanes_ids'][0]
            delta_y0s = res[:, 0]- min(road_attrs['lanes_marks_coors'][lane_id0])
            #
            #lane_id1 = road_attrs['lanes_ids'][1]
            delta_y1s = -res[:, 3]+ max(road_attrs['lanes_marks_coors'][lane_id1])
            
            ax.plot(delta_y0s, delta_y1s, alpha = alpha)
        
        #
        ax.set_xlim([0, road_attrs['lws'][0]])
        ax.set_ylim([0, road_attrs['lws'][1]])
        #
        #====plot the symmetric lines. 
        xs = [0, road_attrs['lws'][0]]
        ys = [road_attrs['lws'][1]/2.0, road_attrs['lws'][1]/2.0]
        ax.plot(xs,ys, 'k')
        #
        ys = [0, road_attrs['lws'][1]]
        xs = [road_attrs['lws'][0]/2.0, road_attrs['lws'][0]/2.0]
        ax.plot(xs,ys, 'k')
        #
        ax.grid()
        ax.set_xlabel('Distance 1 (m)');ax.set_ylabel('Distance 2 (m)')
        return ax
            

    @classmethod
    def plot_lateral_marginals_normalized(self, selected_marginal_ts, tspan, sim_res, road_attrs, ax = False, figsize = (5,3), alpha = .4, bins = 20):
        """
        Difference betweenL
        
            - self.plot_lateral_marginals()
            - self.plot_lateral_marginals_normalized(), the domain of the axis is [-.5, .5]
        
        ---------------------------------------
        @input: selected_marginal_ts, tspan,
        
            both are lists or 1d array. 
            
            the former one is the 
        
        
        sim_res,road_attrs = twodim.LateralWanderingMultiLane.sim(stochastic_proecess_name='OU', tspan = np.linspace(0, 100, 400), N_paths=10)
        
        sim_res[idx] shape is (len(ts), n_lanes*3). '*3' because for each lane there are three states: y,u,z. 
        
        road_attrs.keys():
        
            ['lanes_ids',
             'lws',
             'length',
             'lws_dict',
             'two_dim_paras_dict',
             'left_lane_id',
             'right_lane_id',
             'ellipse_y_left',
             'ellipse_y_right',
             'lanes_middle_line',
             'lanes_marks_coors',
             'road_bounds',
             'lw_boundary_lanes']
        
        
        
        
        """
        n_lanes = len(road_attrs['lanes_ids'])
        
        #
        if isinstance(ax, bool):
            #fig,axs = plt.subplots(figsize = figsize,nrows = n_lanes, ncols = 1)
            fig,ax = plt.subplots(figsize = figsize, )
            #fig,axs = plt.subplots(figsize = figsize, nrows = 2, ncols = 1)
            #ax = host_subplot(111)
            #par = ax.twinx()
        #ax = axs[0]
        y_max = -np.inf
        for i in range(n_lanes):
            #
            lane_id = road_attrs['lanes_ids'][i]
            lane_lw = road_attrs['lws'][i]
            middle_line_coor = road_attrs['lanes_middle_line'][lane_id]
            color = np.random.uniform(size =(3))
            marker =   int(np.random.uniform(11))
            #
            for t in selected_marginal_ts:
                #----------------------------------
                indexes = np.array(range(len(tspan)))
                #
                tmp = abs(tspan-t)
                idx_most_near = indexes[tmp==min(tmp)][0]
                #
                data = [res[idx_most_near, i*3] for res in sim_res]
                hist0,edges = np.histogram(data, bins = bins)
                #
                eges_normalized = (edges[1:] - middle_line_coor)/lane_lw
                #
                hist = hist0/sum(hist0)/(eges_normalized[-1] - eges_normalized[-2])
                #
                y_max = max(y_max, max(hist))
                ax.plot(eges_normalized, hist, color = color, marker = marker, label = 'lane id  = ' + str(lane_id))
        
        #-------------------------------------
        ax.set_xlim([-.5, .5]);ax.set_ylim([0, y_max*1.05]);ax.legend()
        ax.set_xlabel('Relative lateral');ax.set_ylabel('Frequency'); ax.grid();
        
        """
        #plot the u
        ax = axs[1]
        for res in sim_res:
            for i in range(n_lanes):
                ax.plot(tspan, res[:, i*3 + 1])
        ax.set_xlabel('Time ( sec )');ax.set_ylabel('u (m/s) '); ax.grid();ax.set_title('(a)')
        """

        #
        return ax

    @classmethod
    def marginal_whole_road_section(self, selected_t, tspan, sim_res, road_attrs, bins = 20, ):
        """
        
        hist,edges = twodim.LateralWanderingMultiLane.marginal_whole_road_section()
        
        
        Difference:
        
            - self.plot_lateral_marginals()
            - self.plot_lateral_marginals_whole_road_section()
        
        The latter one is for the road section, which convers the multi lane at the same time. 
        
        ---------------------------------------------------
        @input: selected_marginal_ts, tspan,
        
            both are lists or 1d array. 
            
            the former one is the 
        
        
        sim_res,road_attrs = twodim.LateralWanderingMultiLane.sim(stochastic_proecess_name='OU', tspan = np.linspace(0, 100, 400), N_paths=10)
        
        sim_res[idx] shape is (len(ts), n_lanes*3). '*3' because for each lane there are three states: y,u,z. 
        
        road_attrs.keys():
        
            ['lanes_ids',
             'lws',
             'length',
             'lws_dict',
             'two_dim_paras_dict',
             'left_lane_id',
             'right_lane_id',
             'ellipse_y_left',
             'ellipse_y_right',
             'lanes_middle_line',
             'lanes_marks_coors',
             'road_bounds',
             'lw_boundary_lanes']
        
        
        
        
        """
        n_lanes = len(road_attrs['lanes_ids'])
        #
        tspan = np.array(tspan)
        #ax = axs[0]
        max_h = -np.inf
        #
        #----------------------------------

        
        #
        #----------------------------------the most near temporal index idx_most_near
        indexes = np.array(range(len(tspan)))
        #
        tmp = abs(tspan-selected_t)
        idx_most_near = indexes[tmp==min(tmp)][0]
        #
        #-------------------------------collect the data
        datas = []
        for i in range(n_lanes):
            data = [res[idx_most_near, i*3] for res in sim_res]
            datas.extend(data)
        #
        #------------------------------histogram
        hist0,edges = np.histogram(datas, bins = bins, range = (min(road_attrs['road_bounds']) , max(road_attrs['road_bounds'])))
        hist = hist0/sum(hist0)/(edges[-1] - edges[-2])
        
        return hist,edges[1:]
        
    @classmethod
    def plot_lateral_marginals_whole_road_section(self, selected_marginal_ts, tspan, sim_res, road_attrs, ax = False, figsize = (5,3), alpha = .4, bins = 20, label = ' ', lanrmark_color = 'k'):
        """
        Difference:
        
            - self.plot_lateral_marginals()
            - self.plot_lateral_marginals_whole_road_section()
        
        The latter one is for the road section, which convers the multi lane at the same time. 
        
        ---------------------------------------------------
        @input: selected_marginal_ts, tspan,
        
            both are lists or 1d array. 
            
            the former one is the 
        
        
        sim_res,road_attrs = twodim.LateralWanderingMultiLane.sim(stochastic_proecess_name='OU', tspan = np.linspace(0, 100, 400), N_paths=10)
        
        sim_res[idx] shape is (len(ts), n_lanes*3). '*3' because for each lane there are three states: y,u,z. 
        
        road_attrs.keys():
        
            ['lanes_ids',
             'lws',
             'length',
             'lws_dict',
             'two_dim_paras_dict',
             'left_lane_id',
             'right_lane_id',
             'ellipse_y_left',
             'ellipse_y_right',
             'lanes_middle_line',
             'lanes_marks_coors',
             'road_bounds',
             'lw_boundary_lanes']
        
        
        
        
        """
        n_lanes = len(road_attrs['lanes_ids'])
        
        #
        if isinstance(ax, bool):
            fig,ax = plt.subplots(figsize = figsize,)
            #fig,axs = plt.subplots(figsize = figsize, nrows = 2, ncols = 1)
            #ax = host_subplot(111)
            #par = ax.twinx()
        tspan = np.array(tspan)
        #ax = axs[0]
        max_h = -np.inf
        #
        #----------------------------------
        for t in selected_marginal_ts:
            datas = []
            #
            #----------------------------------the most near temporal index idx_most_near
            indexes = np.array(range(len(tspan)))
            #
            tmp = abs(tspan-t)
            idx_most_near = indexes[tmp==min(tmp)][0]
            #
            #-------------------------------collect the data
            for i in range(n_lanes):
                data = [res[idx_most_near, i*3] for res in sim_res]
                datas.extend(data)
            #
            #------------------------------histogram
            hist0,edges = np.histogram(datas, bins = bins, range = (min(road_attrs['road_bounds']) , max(road_attrs['road_bounds'])))
            hist = hist0/sum(hist0)/(abs((edges[-1] - edges[-2])))
            #hist = hist0/sum(hist0)
            max_h = max(max_h, max(hist))
            #
            #------------------------------plot
            ax.plot(edges[1:], hist, label = label, color = lanrmark_color)
        #
        #--------------Lane lines
        for lane_id in road_attrs['lanes_ids']:
            #
            leftmark,rightmark = road_attrs['lanes_marks_coors'][lane_id]
            #
            ax.plot([leftmark,leftmark], [0, max_h*1.1], color = lanrmark_color,  linewidth = 4)
            ax.plot([rightmark,rightmark], [0, max_h*1.1], color = lanrmark_color,  linewidth = 4)
            ax.plot([road_attrs['lanes_middle_line'][lane_id],road_attrs['lanes_middle_line'][lane_id]], [0, max_h*1.1], '-.', color = lanrmark_color, alpha = .4)
        
        
        #----------------------------------
        ax.set_xlim([min(road_attrs['road_bounds']) , max(road_attrs['road_bounds'])])
        ax.set_xlabel('Lateral location (m)');ax.set_ylabel('Distribution'); ax.grid();#ax.set_title('(a)')
        
        
        
        
        """
        #plot the u
        ax = axs[1]
        for res in sim_res:
            for i in range(n_lanes):
                ax.plot(tspan, res[:, i*3 + 1])
        ax.set_xlabel('Time ( sec )');ax.set_ylabel('u (m/s) '); ax.grid();ax.set_title('(a)')
        """

        #
        return ax
    
    

    @classmethod
    def plot_marginal_given_hists_edges_whole_road_section(self, hists, edges, road_attrs, ax = False, figsize = (5,3), alpha = .4, bins = 20, label = ' ', color = 'k', lanrmark_color = 'k'):
        """
        Difference:
        
            - self.plot_lateral_marginals()
            - self.plot_lateral_marginals_whole_road_section()
        
        The latter one is for the road section, which convers the multi lane at the same time. 
        
        ---------------------------------------------------
        @input: selected_marginal_ts, tspan,
        
            both are lists or 1d array. 
            
            the former one is the 
        
        
        sim_res,road_attrs = twodim.LateralWanderingMultiLane.sim(stochastic_proecess_name='OU', tspan = np.linspace(0, 100, 400), N_paths=10)
        
        sim_res[idx] shape is (len(ts), n_lanes*3). '*3' because for each lane there are three states: y,u,z. 
        
        road_attrs.keys():
        
            ['lanes_ids',
             'lws',
             'length',
             'lws_dict',
             'two_dim_paras_dict',
             'left_lane_id',
             'right_lane_id',
             'ellipse_y_left',
             'ellipse_y_right',
             'lanes_middle_line',
             'lanes_marks_coors',
             'road_bounds',
             'lw_boundary_lanes']
        
        
        
        
        """
        n_lanes = len(road_attrs['lanes_ids'])
        
        #
        if isinstance(ax, bool):
            fig,ax = plt.subplots(figsize = figsize,)
            #fig,axs = plt.subplots(figsize = figsize, nrows = 2, ncols = 1)
            #ax = host_subplot(111)
            #par = ax.twinx()
        ax.plot(edges, hists, label = label, color = color)
        #
        #--------------Lane lines
        for lane_id in road_attrs['lanes_ids']:
            #
            leftmark,rightmark = road_attrs['lanes_marks_coors'][lane_id]
            #
            ax.plot([leftmark,leftmark], [0, max(hists)*1.1], color = lanrmark_color,  linewidth = 4)
            ax.plot([rightmark,rightmark], [0, max(hists)*1.1], color = lanrmark_color,  linewidth = 4)
            ax.plot([road_attrs['lanes_middle_line'][lane_id],road_attrs['lanes_middle_line'][lane_id]], [0, max(hists)*1.1], '-.', color = lanrmark_color, alpha = .4)
        
        
        #----------------------------------
        ax.set_xlim([min(road_attrs['road_bounds']) , max(road_attrs['road_bounds'])])
        ax.set_xlabel('Lateral location (m)');ax.set_ylabel('Distribution'); ax.grid();#ax.set_title('(a)')
        
        
        
        
        """
        #plot the u
        ax = axs[1]
        for res in sim_res:
            for i in range(n_lanes):
                ax.plot(tspan, res[:, i*3 + 1])
        ax.set_xlabel('Time ( sec )');ax.set_ylabel('u (m/s) '); ax.grid();ax.set_title('(a)')
        """

        #
        return ax
    
    
    
    @classmethod
    def plot_lateral_marginals(self, selected_marginal_ts, tspan, sim_res, road_attrs, ax = False, figsize = (5,3), alpha = .4, bins = 20):
        """
        
        @input: selected_marginal_ts, tspan,
        
            both are lists or 1d array. 
            
            the former one is the 
        
        
        sim_res,road_attrs = twodim.LateralWanderingMultiLane.sim(stochastic_proecess_name='OU', tspan = np.linspace(0, 100, 400), N_paths=10)
        
        sim_res[idx] shape is (len(ts), n_lanes*3). '*3' because for each lane there are three states: y,u,z. 
        
        road_attrs.keys():
        
            ['lanes_ids',
             'lws',
             'length',
             'lws_dict',
             'two_dim_paras_dict',
             'left_lane_id',
             'right_lane_id',
             'ellipse_y_left',
             'ellipse_y_right',
             'lanes_middle_line',
             'lanes_marks_coors',
             'road_bounds',
             'lw_boundary_lanes']
        
        
        
        
        """
        n_lanes = len(road_attrs['lanes_ids'])
        
        #
        if isinstance(ax, bool):
            fig,axs = plt.subplots(figsize = figsize,nrows = n_lanes, ncols = 1)
            #fig,axs = plt.subplots(figsize = figsize, nrows = 2, ncols = 1)
            #ax = host_subplot(111)
            #par = ax.twinx()
        tspan = np.array(tspan)
        #ax = axs[0]
        
        for i in range(n_lanes):
            for t in selected_marginal_ts:
                #----------------------------------
                indexes = np.array(range(len(tspan)))
                #
                tmp = abs(tspan-t)
                idx_most_near = indexes[tmp==min(tmp)][0]
                data = [res[idx_most_near, i*3] for res in sim_res]
                hist0,edges = np.histogram(data, bins = bins)
                hist = hist0/sum(hist0)/(edges[-1] - edges[-2])
                #
                axs[i].plot(edges[1:], hist)
        
        for i in range(n_lanes):
            ax = axs[i]
            lane_id = road_attrs['lanes_ids'][i]
            ax.set_xlim(road_attrs['lanes_marks_coors'][lane_id])
            ax.set_xlabel('Time ( sec )');ax.set_ylabel('y (m) '); ax.grid();ax.set_title('(a)')
        
        """
        #plot the u
        ax = axs[1]
        for res in sim_res:
            for i in range(n_lanes):
                ax.plot(tspan, res[:, i*3 + 1])
        ax.set_xlabel('Time ( sec )');ax.set_ylabel('u (m/s) '); ax.grid();ax.set_title('(a)')
        """

        #
        return ax
    
    @classmethod
    def plot_debug(self, tspan, sim_res, road_attrs, ax = False, figsize = (5,3), alpha = .4, idx_plotted = 0):
        """
        
        
        sim_res,road_attrs = twodim.LateralWanderingMultiLane.sim(stochastic_proecess_name='OU', tspan = np.linspace(0, 100, 400), N_paths=10)
        
        sim_res[idx] shape is (len(ts), n_lanes*3). '*3' because for each lane there are three states: y,u,z. 
        
        road_attrs.keys():
        
            ['lanes_ids',
             'lws',
             'length',
             'lws_dict',
             'two_dim_paras_dict',
             'left_lane_id',
             'right_lane_id',
             'ellipse_y_left',
             'ellipse_y_right',
             'lanes_middle_line',
             'lanes_marks_coors',
             'road_bounds',
             'lw_boundary_lanes']
        
        """
        n_lanes = len(road_attrs['lanes_ids'])
        
        #
        if isinstance(ax, bool):
            #f#ig,ax = plt.subplots(figsize = figsize,)
            fig,axs = plt.subplots(figsize = figsize, nrows = n_lanes, ncols = 1)
            #ax = host_subplot(111)
            #par = ax.twinx()
        
        #plot the y
        #ax = axs[0]
        for res in sim_res:
            for i in range(n_lanes):
                axs[i].plot(tspan, res[:, i*3 + idx_plotted], '.-')

        
        #ax.set_xlabel('Time ( sec )');ax.set_ylabel('y (m) '); ax.grid();ax.set_title('(a)')
        
        """
        #plot the u
        ax = axs[1]
        for res in sim_res:
            for i in range(n_lanes):
                ax.plot(tspan, res[:, i*3 + 1])
        ax.set_xlabel('Time ( sec )');ax.set_ylabel('u (m/s) '); ax.grid();ax.set_title('(a)')
        """

        #
        return ax
    
    
    
    @classmethod
    def plot_paths(self, tspan, sim_res, road_attrs, ax = False, figsize = (5,3), alpha = .4, idx_plotted = 0):
        """
        
        
        sim_res,road_attrs = twodim.LateralWanderingMultiLane.sim(stochastic_proecess_name='OU', tspan = np.linspace(0, 100, 400), N_paths=10)
        
        sim_res[idx] shape is (len(ts), n_lanes*3). '*3' because for each lane there are three states: y,u,z. 
        
        road_attrs.keys():
        
            ['lanes_ids',
             'lws',
             'length',
             'lws_dict',
             'two_dim_paras_dict',
             'left_lane_id',
             'right_lane_id',
             'ellipse_y_left',
             'ellipse_y_right',
             'lanes_middle_line',
             'lanes_marks_coors',
             'road_bounds',
             'lw_boundary_lanes']
        
        """
        n_lanes = len(road_attrs['lanes_ids'])
        
        #
        if isinstance(ax, bool):
            fig,ax = plt.subplots(figsize = figsize,)
            #fig,axs = plt.subplots(figsize = figsize, nrows = 2, ncols = 1)
            #ax = host_subplot(111)
            #par = ax.twinx()
        
        #plot the y
        #ax = axs[0]
        for res in sim_res:
            for i in range(n_lanes):
                ax.plot(tspan, res[:, i*3 + idx_plotted])
        
        #==========lane marks
        for laneid in road_attrs['lanes_ids']:
            #
            leftmark,rightmark = road_attrs['lanes_marks_coors'][laneid]
            #
            ax.plot([tspan[0], tspan[-1]] , [leftmark, leftmark], 'k')
            ax.plot([tspan[0], tspan[-1]] , [rightmark, rightmark], 'k')
            
            
            pass
        
        ax.set_xlabel('Time ( sec )');ax.set_ylabel('y (m) '); ax.grid();ax.set_title('(a)')
        
        """
        #plot the u
        ax = axs[1]
        for res in sim_res:
            for i in range(n_lanes):
                ax.plot(tspan, res[:, i*3 + 1])
        ax.set_xlabel('Time ( sec )');ax.set_ylabel('u (m/s) '); ax.grid();ax.set_title('(a)')
        """

        #
        return ax
    
    
    @classmethod
    def get_neighbores_y(self, idx_ego_lane, n_lanes, STATE, road_attrs, lw_default = 3.5):
        """
        left correspond to the positive y axis. and right points to the negative y axis 
        --------------------------
        @input: lw_default
        
            assign the lane width default. 
            
        @inpu: idx_lane
        
            the idx of the ego lane in lanes_id,
            
            idx_ego_land is within [0, N-1], where N is the number of lanes. 
        
        @input: STATE
        
            STATE = [y0, u0, z0, y1, u1, z1,....yN, uN, zN]
        
        @OUTPUT; y_others
        
            y_others = [y_left_lane, y_right_lane]
        
        """
        #y of vehicle at left lane
        if idx_ego_lane==0:
            y_left_lane = np.inf
            lw_left_lane = lw_default
            flow_type_left = 'NULL'
        else:
            y_left_lane = STATE[(idx_ego_lane - 1)*3]
            lw_left_lane = road_attrs['lws'][idx_ego_lane - 1]
            flow_type_left = road_attrs['flow_types'][idx_ego_lane - 1]
        
        #y of vehicle at right lane. 
        if idx_ego_lane==n_lanes-1:
            y_right_lane = -np.inf
            lw_right_lane = lw_default
            flow_type_right = 'NULL'
        else:
            y_right_lane = STATE[(idx_ego_lane + 1)*3]
            lw_right_lane = road_attrs['lws'][idx_ego_lane + 1]
            flow_type_right = road_attrs['flow_types'][idx_ego_lane + 1]
        
        return [y_left_lane, y_right_lane],[lw_left_lane,lw_right_lane],[flow_type_left,flow_type_right]
    
    @classmethod
    def force_neighbors(self, y_ego, y_others, ego_lane_lw, lw_left_right, flow_type_left_right, two_dim_paras = two_dim_paras):
        """
        The forces between vehicles at neighboring lanes. 
        @input: flow_type_left_right
        
            flow_type_left_right = ['AV', 'HDV']
            
            
        
        @input: y_others
        
            a list of length 2.
            
            If a vehicle locates at leftmost lane, then y_others = (np.inf, y_right)
            
            The order is left and right. 
            
        @input: lw_left_right
        
            lw_left_right = [3.5, 3.5]
            
            the left and right lane width. 
        
        """
        
        #==============================================
        def force_neighbor(ego_y, y_other, lw_other, ego_lane_lw = ego_lane_lw, ):
            """
            
            """
            lw_equivalently  = ego_lane_lw/2.0 + lw_other/2.0
            #
            if abs(ego_y - y_other)>=lw_equivalently:
                return .0
            else:
                #
                if ego_y - y_other>0:
                    return -(1.0/lw_equivalently - 1.0/abs(ego_y - y_other))
                else:
                    #print(ego_y, y_other)
                    return 1.0/lw_equivalently - 1.0/abs(ego_y - y_other)
                #
            #
        #==============================================
        #print(y_ego, y_others)
        force_left_and_right = [force_neighbor(y_ego, y, lw_other, ego_lane_lw) for y,lw_other in zip(y_others, lw_left_right)]
        force_left_and_right = []
        for y,lw_other,flow_type_other in zip(y_others, lw_left_right, flow_type_left_right):
            #
            if 'AV' in flow_type_other:
                force_left_and_right.append(0)
            else:
                force_left_and_right.append(force_neighbor(y_ego, y, lw_other, ego_lane_lw))
            #
        return force_left_and_right
    
    
    @classmethod
    def force_mark(self, y, lw, lane_mark_coors = (-3.5/2.0, 3.5/2.0), two_dim_paras = two_dim_paras, left_force_exist = True, right_force_exist = True):
        """
        @input: two_dim_paras
        
            the parameters for the two dimensional microscopic model. 
        @input: lw
            
            the lane width of the ego lane. 
        
        @input: ego_lane_marks_coor
        
            ego_lane_marks_coor = (float1, float2)

        
        @input: left_force_exist and right_force_exist
        
            whether calculate the left or right force. 
            
            

        @input: lane_middle_line_ccor
            
            a float which represent the lane middle line coordinate. 
        
        -------------------------------------------------------
        @OUTPUT: potential
        
            a float which represent the force generated by the lane mark. 
            NOTE THAT THE sign. 
            
            
        """
        
        #
        #x,vx,y, vy,Z_long,Z_lat = ego_state[0],ego_state[1],ego_state[2],ego_state[3],ego_state[4],ego_state[5]
        #
        beta_lane_marks = two_dim_paras['beta_lane_marks']
        #
        potential = 0
        for markcoor in lane_mark_coors:
            deltay = y - markcoor
            if y>markcoor:
                #print(deltay)
                if right_force_exist and abs(deltay)<lw/2.0:
                    potential = potential + np.exp(-beta_lane_marks*deltay*deltay)
                    
                
            else:
                if left_force_exist and abs(deltay)<lw/2.0:
                    #
                    potential = potential - np.exp(-beta_lane_marks*deltay*deltay)
            
        return potential
    
    
    @classmethod
    def force_middleline(self, y, u, ego_lane_lw, lane_middle_line_coor, two_dim_paras = two_dim_paras, ):
        """
        @input: y,u
        
            the lateral coor and lateral speed. 
            
        @input: lane_middle_line_coor
        
            the coordinate of the lane_middle_line_coor.
        
        """
        beta = two_dim_paras['beta_lane_middle_line']
        
        #ego_state[2] is y. 
        #if ego_state[2]>lane_middle_line_coor:
        #deltay = ego_state[2]-lane_middle_line_coor
        deltay = y -lane_middle_line_coor
        #
        tmp0 = beta*beta*(2.0*deltay-ego_lane_lw)*np.exp(-beta*beta*(deltay-ego_lane_lw/2.0)*(deltay-ego_lane_lw/2.0))
        tmp1 = beta*beta*(2.0*deltay+ego_lane_lw)*np.exp(-beta*beta*(deltay+ego_lane_lw/2.0)*(deltay+ego_lane_lw/2.0))
        #ys2 =  beta*beta*(2.0*deltay-ego_lane_lw)*np.exp(-beta*beta*(deltay-ego_lane_lw/2.0)*(deltay-ego_lane_lw/2.0)) - \
        #        beta*beta*(2.0*deltay+lw)*np.exp(-beta*beta*(deltay+lw/2.0)*(deltay+lw/2.0))
        return (tmp0 - tmp1)*u

        ################################################################
        ################################################################
        ################################################################
        ################################################################
        beta = two_dim_paras['beta_lane_middle_line']
        #ego_state[2] is y. 
        #if ego_state[2]>lane_middle_line_coor:
        deltay = y
        #
        tmp0 = beta*beta*(2.0*deltay-ego_lane_lw)*np.exp(-beta*beta*(deltay-ego_lane_lw/2.0)*(deltay-ego_lane_lw/2.0))
        tmp1 = beta*beta*(2.0*deltay+ego_lane_lw)*np.exp(-beta*beta*(deltay+ego_lane_lw/2.0)*(deltay+ego_lane_lw/2.0))
        return (tmp0 - tmp1)*u

    
    @classmethod
    def force_road_bound(self, y, lw_boundary_lanes, ego_lane_lw  = 3.5,  road_bounds = (-3.5/2.0, 3.5/2.0), two_dim_paras = two_dim_paras, left_force_exist = True, right_force_exist = True):
        """
        NOTE that the 'left' direction points to the positive y axis. 
        
        
        
        @input: left_force_exist and right_force_exist
        
            whether calculate the left or right force. 
            
            
        
        @input: lw_boundary_lanes
        
            lw_boundary_lanes = (3.5, 3.5)
            
            The lanes at leftmost or rightmost lane. 
            
            
        """
        
        #
        #x,vx,y, vy,Z_long,Z_lat = ego_state[0],ego_state[1],ego_state[2],ego_state[3],ego_state[4],ego_state[5]
        #
        #   the parameter. 
        alpha_roadbounds =  two_dim_paras['alpha_roadbounds']
        #
        #========================================================the first bound
        #potential0 must be negative. 
        deltay = y-road_bounds[0]
        deltay0 = max(1e-10, abs(deltay))
        #print(y, road_bounds[0])
        if abs(deltay)<lw_boundary_lanes[0]/2.0:
            if deltay>0:
                #deltay>0 means the right force
                if right_force_exist:
                    #potential0 = 1.0/(np.power(deltay0*2.0/ego_lane_lw, alpha_roadbounds)) - 1
                    potential0 = 1.0/(np.power(deltay0*2.0/ego_lane_lw, alpha_roadbounds)) - 1
                else:
                    potential0 = 0.0
                    
            else:
                if left_force_exist:
                    #potential0 = -(1.0/(np.power(deltay0*2.0/ego_lane_lw, alpha_roadbounds)) - 1)
                    potential0 = -(1.0/(np.power(deltay0*2.0/ego_lane_lw, alpha_roadbounds)) - 1)
                else:
                    potential0 = 0
        else:
            potential0 = .0
        #========================================================the second bound
        deltay = y-road_bounds[1]
        deltay1 = max(1e-10, abs(deltay))
        if abs(deltay)<lw_boundary_lanes[1]/2.0:
            if deltay>0:
                #deltay>0 means the right force
                if right_force_exist:
                    #potential1 = 1.0/(np.power(deltay1*2.0/ego_lane_lw, alpha_roadbounds)) - 1
                    potential1 = 1.0/(np.power(deltay1*2.0/ego_lane_lw, alpha_roadbounds)) - 1
                else:
                    potential1 = 0.0
            else:
                if left_force_exist:
                    #print(deltay1)
                    #potential1 = -(1.0/(np.power(deltay1*2.0/ego_lane_lw, alpha_roadbounds)) -1)
                    potential1 = -(1.0/(np.power(deltay1*2.0/ego_lane_lw, alpha_roadbounds)) -1)
                else:
                    potential1 = 0.0
        else:
            potential1 = 0.0
        
        return potential0 + potential1
    
        ##########################################################
        ##########################################################
        ##########################################################
        ##########################################################
        road_bounds = (-ego_lane_lw/2.0, ego_lane_lw/2.0)
        #
        #x,vx,y, vy,Z_long,Z_lat = ego_state[0],ego_state[1],ego_state[2],ego_state[3],ego_state[4],ego_state[5]
        #
        #   the parameter. 
        alpha_roadbounds =  two_dim_paras['alpha_roadbounds']
        #
        #potential0 must be negative. 
        deltay = y-road_bounds[0]
        deltay0 = max(1e-10, abs(deltay))
        #print(y, road_bounds[0])
        if deltay>0:
            #=====force from the right bound
            if right_force_exit:
                potential0 = 1.0/(np.power(deltay0*2.0/ego_lane_lw, alpha_roadbounds)) - 1
            else:
                potential0 = .0
        else:
            #=====force from the left bound
            if left_force_exist:
                potential0 = -(1.0/(np.power(deltay0*2.0/ego_lane_lw, alpha_roadbounds)) - 1)
            else:
                potential0 = .0
        #
        deltay = y-road_bounds[1]
        deltay1 = max(1e-10, abs(deltay))
        #print(deltay1*2.0/lw_boundary_lanes[1], alpha_roadbounds)
        if deltay>0:
            #=====force from the right bound
            if right_force_exit:
                potential1 = 1.0/(np.power(deltay1*2.0/ego_lane_lw, alpha_roadbounds)) - 1
            else:
                potential1 = .0
        else:
            #print(deltay1)
            #=====force from the left bound
            if left_force_exist:
                potential1 = -(1.0/(np.power(deltay1*2.0/ego_lane_lw, alpha_roadbounds)) -1)
            else:
                potential1 = .0
        #
        return potential0 + potential1


    
    @classmethod
    def force_road_bound_BKP0(self, y, lw_boundary_lanes, ego_lane_lw  = 3.5,  road_bounds = (-3.5/2.0, 3.5/2.0), two_dim_paras = two_dim_paras, left_force_exist = True, right_force_exist = True):
        """
        NOTE that the 'left' direction points to the positive y axis. 
        
        
        
        @input: left_force_exist and right_force_exist
        
            whether calculate the left or right force. 
            
            
        
        @input: lw_boundary_lanes
        
            lw_boundary_lanes = (3.5, 3.5)
            
            The lanes at leftmost or rightmost lane. 
            
            
        """
        
        #
        #x,vx,y, vy,Z_long,Z_lat = ego_state[0],ego_state[1],ego_state[2],ego_state[3],ego_state[4],ego_state[5]
        #
        #   the parameter. 
        alpha_roadbounds =  two_dim_paras['alpha_roadbounds']
        #
        #potential0 must be negative. 
        deltay = y-road_bounds[0]
        deltay0 = max(1e-10, abs(deltay))
        #print(y, road_bounds[0])
        if deltay>0:
            #deltay>0 means the right force
            if right_force_exist:
                #potential0 = 1.0/(np.power(deltay0*2.0/ego_lane_lw, alpha_roadbounds)) - 1
                potential0 = 1.0/(np.power(deltay0*2.0/ego_lane_lw, alpha_roadbounds)) - 1
            else:
                potential0 = 0.0
                
        else:
            if left_force_exist:
                #potential0 = -(1.0/(np.power(deltay0*2.0/ego_lane_lw, alpha_roadbounds)) - 1)
                potential0 = -(1.0/(np.power(deltay0*2.0/ego_lane_lw, alpha_roadbounds)) - 1)
            else:
                potential0 = 0
        #
        deltay = y-road_bounds[1]
        deltay1 = max(1e-10, abs(deltay))
        if deltay>0:
            #deltay>0 means the right force
            if right_force_exist:
                #potential1 = 1.0/(np.power(deltay1*2.0/ego_lane_lw, alpha_roadbounds)) - 1
                potential1 = 1.0/(np.power(deltay1*2.0/ego_lane_lw, alpha_roadbounds)) - 1
            else:
                potential1 = 0.0
        else:
            if left_force_exist:
                #print(deltay1)
                #potential1 = -(1.0/(np.power(deltay1*2.0/ego_lane_lw, alpha_roadbounds)) -1)
                potential1 = -(1.0/(np.power(deltay1*2.0/ego_lane_lw, alpha_roadbounds)) -1)
            else:
                potential1 = 0.0
        
        return potential0 + potential1
    
        ##########################################################
        ##########################################################
        ##########################################################
        ##########################################################
        road_bounds = (-ego_lane_lw/2.0, ego_lane_lw/2.0)
        #
        #x,vx,y, vy,Z_long,Z_lat = ego_state[0],ego_state[1],ego_state[2],ego_state[3],ego_state[4],ego_state[5]
        #
        #   the parameter. 
        alpha_roadbounds =  two_dim_paras['alpha_roadbounds']
        #
        #potential0 must be negative. 
        deltay = y-road_bounds[0]
        deltay0 = max(1e-10, abs(deltay))
        #print(y, road_bounds[0])
        if deltay>0:
            #=====force from the right bound
            if right_force_exit:
                potential0 = 1.0/(np.power(deltay0*2.0/ego_lane_lw, alpha_roadbounds)) - 1
            else:
                potential0 = .0
        else:
            #=====force from the left bound
            if left_force_exist:
                potential0 = -(1.0/(np.power(deltay0*2.0/ego_lane_lw, alpha_roadbounds)) - 1)
            else:
                potential0 = .0
        #
        deltay = y-road_bounds[1]
        deltay1 = max(1e-10, abs(deltay))
        #print(deltay1*2.0/lw_boundary_lanes[1], alpha_roadbounds)
        if deltay>0:
            #=====force from the right bound
            if right_force_exit:
                potential1 = 1.0/(np.power(deltay1*2.0/ego_lane_lw, alpha_roadbounds)) - 1
            else:
                potential1 = .0
        else:
            #print(deltay1)
            #=====force from the left bound
            if left_force_exist:
                potential1 = -(1.0/(np.power(deltay1*2.0/ego_lane_lw, alpha_roadbounds)) -1)
            else:
                potential1 = .0
        #
        return potential0 + potential1


    
    
    @classmethod
    def force_road_bound_BKP(self, y, lw_boundary_lanes, ego_lane_lw  = 3.5,  road_bounds = (-3.5/2.0, 3.5/2.0), two_dim_paras = two_dim_paras, left_force_exist = True, right_force_exist = True):
        """
        NOTE that the 'left' direction points to the positive y axis. 
        
        
        
        @input: left_force_exist and right_force_exist
        
            whether calculate the left or right force. 
            
            
        
        @input: lw_boundary_lanes
        
            lw_boundary_lanes = (3.5, 3.5)
            
            The lanes at leftmost or rightmost lane. 
            
            
        """
        
        #
        #x,vx,y, vy,Z_long,Z_lat = ego_state[0],ego_state[1],ego_state[2],ego_state[3],ego_state[4],ego_state[5]
        #
        #   the parameter. 
        alpha_roadbounds =  two_dim_paras['alpha_roadbounds']
        #
        #potential0 must be negative. 
        deltay = y-road_bounds[0]
        deltay0 = max(1e-10, abs(deltay))
        if abs(deltay)<lw_boundary_lanes[0]/2.0:
            
            #print(y, road_bounds[0])
            if deltay>0:
                #deltay>0 means the right force
                if right_force_exist:
                    potential0 = 1.0/(np.power(deltay0*2.0/ego_lane_lw, alpha_roadbounds)) - 1
                else:
                    potential0 = 0.0
                    
            else:
                if left_force_exist:
                    potential0 = -(1.0/(np.power(deltay0*2.0/ego_lane_lw, alpha_roadbounds)) - 1)
                else:
                    potential0 = 0
        else:
            potential0 = 0
        
        #
        deltay = y-road_bounds[1]
        deltay1 = max(1e-10, abs(deltay))
        if abs(deltay)<lw_boundary_lanes[1]/2.0:
            #print(deltay1*2.0/lw_boundary_lanes[1], alpha_roadbounds)
            if deltay>0:
                #deltay>0 means the right force
                if right_force_exist:
                    potential1 = 1.0/(np.power(deltay1*2.0/ego_lane_lw, alpha_roadbounds)) - 1
                else:
                    potential1 = 0.0
            else:
                if left_force_exist:
                    #print(deltay1)
                    potential1 = -(1.0/(np.power(deltay1*2.0/ego_lane_lw, alpha_roadbounds)) -1)
                else:
                    potential1 = 0.0
            #
        else:
            potential1 = 0
            
        #
        return potential0 + potential1
    
        ##########################################################
        ##########################################################
        ##########################################################
        ##########################################################
        road_bounds = (-ego_lane_lw/2.0, ego_lane_lw/2.0)
        #
        #x,vx,y, vy,Z_long,Z_lat = ego_state[0],ego_state[1],ego_state[2],ego_state[3],ego_state[4],ego_state[5]
        #
        #   the parameter. 
        alpha_roadbounds =  two_dim_paras['alpha_roadbounds']
        #
        #potential0 must be negative. 
        deltay = y-road_bounds[0]
        deltay0 = max(1e-10, abs(deltay))
        #print(y, road_bounds[0])
        if deltay>0:
            #=====force from the right bound
            if right_force_exit:
                potential0 = 1.0/(np.power(deltay0*2.0/ego_lane_lw, alpha_roadbounds)) - 1
            else:
                potential0 = .0
        else:
            #=====force from the left bound
            if left_force_exist:
                potential0 = -(1.0/(np.power(deltay0*2.0/ego_lane_lw, alpha_roadbounds)) - 1)
            else:
                potential0 = .0
        #
        deltay = y-road_bounds[1]
        deltay1 = max(1e-10, abs(deltay))
        #print(deltay1*2.0/lw_boundary_lanes[1], alpha_roadbounds)
        if deltay>0:
            #=====force from the right bound
            if right_force_exit:
                potential1 = 1.0/(np.power(deltay1*2.0/ego_lane_lw, alpha_roadbounds)) - 1
            else:
                potential1 = .0
        else:
            #print(deltay1)
            #=====force from the left bound
            if left_force_exist:
                potential1 = -(1.0/(np.power(deltay1*2.0/ego_lane_lw, alpha_roadbounds)) -1)
            else:
                potential1 = .0
        #
        return potential0 + potential1

    
    
    
    
    @classmethod
    def forces_HDVs_AVs(self, STATE, road_attrs, ):
        """
        Calculate the forces
        
        Diference:
        
            self.forces_HDVs_AVs()
            self.forces()
            
        The former one can accomodate the different flow structures on diferent vehicles. Note that for each lane, the flow is either HDV or AV. 
        
        
        It is given by the arg road_attrs['flow_types'] =  ['HDV', 'AV', 'HDV', 'AV'], 
        
        The brhavioral difference bween HDV and AV:
        
            - the force from vehicles at neighboring lanes are zero for AV. 
            - The two_dim_paras for AV are different
            
        
        diff_us = self.forces(STATE, road_attrs)
        -----------------------------------
        @input: STATE
        
            STATE = [y0, u0, z0, y1, u1, z1,....yN, uN, zN]
        
            its length is 3*n_lanes
        
        @input: road_attrs 
        
            a dict. 
            
            road_attrs = self.get_road_attributes()
            
            road_attrs is:
        
                {'two_dim_paras_dict':
                'lanes_ids': [0, 1, 2, 3],
                 'lws': [3.5, 3.5, 3.5, 3.5],
                 'length': 1000,
                 'lws_dict': {0: 3.5, 1: 3.5, 2: 3.5, 3: 3.5},
                 'left_lane_id': {1: 0, 2: 1, 3: 2},
                 'right_lane_id': {0: 1, 1: 2, 2: 3},
                 'ellipse_y_left': {0: 0, 1: 3.5, 2: 3.5, 3: 3.5},
                 'ellipse_y_right': {0: 3.5, 1: 3.5, 2: 3.5, 3: 0},
                 'lanes_middle_line': {0: 12.25, 1: 8.75, 2: 5.25, 3: 1.75},
                 'lanes_marks_coors': {0: (10.5, 14.0),
                  1: (7.0, 10.5),
                  2: (3.5, 7.0),
                  3: (0.0, 3.5)},
                 'road_bounds': (0, 14.0),
                 'lw_boundary_lanes': (3.5, 3.5)}
            
            
            
        
        @OUTPUT: diff_us
        
            diff_us are the forces for each lane. 
            
            diff_us is a 1d array, length is the same as number of lanes 
        
            
        """
        #
        
        n_lanes = len(road_attrs['lanes_ids'])
        diff_us = np.zeros((n_lanes,))
        
        #
        for idx_lane,lane_id in enumerate(road_attrs['lanes_ids']):
            left_mark_force = True;right_mark_force = True
            left_bound_force = True;right_bound_force = True
            #
            #flow_type is either AV or HDV. 
            flow_type  = road_attrs['flow_types'][idx_lane]
            #lw = road_attrs['lws'][idx_lane]
            #
            #idx_lane = 0 means leftmost lane, rightbound not exit and left mark force not exist. 
            if idx_lane==0:
                left_mark_force = False
                right_bound_force = False
                #
                right_mark_force = True
                left_bound_force = True
            #idx_lane==len(road_attrs['lanes_ids'])-1 means RIGHTMOST lane. 
            if idx_lane==len(road_attrs['lanes_ids'])-1:
                right_mark_force = False
                left_bound_force = False
                #
                left_mark_force = True
                right_bound_force = True
            #
            #--------------------------AV. 
            if 'AV' in flow_type:
                left_bound_force = True
                right_bound_force = True
                left_mark_force = False
                right_mark_force = False
            #
            #
            #==================================force_bound
            #force_road_bound(self, y, ego_lane_lw  = 3.5,  road_bounds = (-3.5/2.0, 3.5/2.0), two_dim_paras = two_dim_paras)
            #*3 is because for each lane the state ys [y,u,z]
            ego_y = STATE[idx_lane*3]
            ego_lane_lw = road_attrs['lws'][idx_lane]
            road_bounds = road_attrs['road_bounds']
            two_dim_paras1 =  road_attrs['two_dim_paras_dict'][lane_id]
            #
            if 'AV' in flow_type:
                #print(two_dim_paras['sigma_lat'])
                #print(y - )
                force_bound = self.force_road_bound(y = ego_y, lw_boundary_lanes = (ego_lane_lw, ego_lane_lw), ego_lane_lw  = ego_lane_lw,  road_bounds = road_attrs['lanes_marks_coors'][lane_id], two_dim_paras = two_dim_paras1, left_force_exist = left_bound_force, right_force_exist = right_bound_force)
                #force_bound = self.force_road_bound(y = ego_y, lw_boundary_lanes = road_attrs['lw_boundary_lanes'], ego_lane_lw  = ego_lane_lw,  road_bounds = road_bounds, two_dim_paras = two_dim_paras1, left_force_exist = left_bound_force, right_force_exist = right_bound_force)
                
            else:
                
                force_bound = self.force_road_bound(y = ego_y, lw_boundary_lanes = road_attrs['lw_boundary_lanes'], ego_lane_lw  = ego_lane_lw,  road_bounds = road_bounds, two_dim_paras = two_dim_paras1, left_force_exist = left_bound_force, right_force_exist = right_bound_force)
                #force_bound = self.force_road_bound(y = ego_y, lw_boundary_lanes = road_attrs['lw_boundary_lanes'], ego_lane_lw  = ego_lane_lw,  road_bounds = road_bounds, two_dim_paras = two_dim_paras, left_force_exist = left_bound_force, right_force_exist = right_bound_force)
                
                #DEBUG BEGIN
                if lane_id==1:
                    #
                    #print(ego_y, lane_middle_line_coor,'-------', force_bound, force_middleline, force_neighbors, force_mark)
                    #
                    pass
                #DEBUG END
                
                
            #
            #==================================force_middleline
            ego_u = STATE[idx_lane*3 + 1]
            lane_middle_line_coor = road_attrs['lanes_middle_line'][lane_id]
            #if flow_type=='AV':print(ego_y, lane_middle_line_coor)
            #
            force_middleline = self.force_middleline(y = ego_y, u = ego_u, ego_lane_lw = ego_lane_lw, lane_middle_line_coor = lane_middle_line_coor, two_dim_paras = two_dim_paras1)

            #==================================force_neighbores
            #force_neighbors(self, y_ego, y_others, ego_lane_lw, two_dim_paras = two_dim_paras)
            y_others,lw_left_right,flow_type_left_right = self.get_neighbores_y(idx_ego_lane = idx_lane, n_lanes  = n_lanes, STATE = STATE, road_attrs = road_attrs)
            #----------
            force_left_and_right  = self.force_neighbors(y_ego = ego_y, y_others = y_others, ego_lane_lw = ego_lane_lw, two_dim_paras = two_dim_paras1, lw_left_right = lw_left_right, flow_type_left_right = flow_type_left_right)
            force_neighbors = sum(force_left_and_right)

            #==================================force_mark
            #force_mark(self, y, lane_mark_coors = (-3.5/2.0, 3.5/2.0), two_dim_paras = two_dim_paras)
            lane_mark_coors  = road_attrs['lanes_marks_coors'][lane_id]
            #
            force_mark = self.force_mark(y = ego_y, lw = ego_lane_lw, lane_mark_coors = lane_mark_coors, two_dim_paras = two_dim_paras1,left_force_exist = left_mark_force, right_force_exist = right_mark_force)
            
            #==============================
            if 'AV' in flow_type:
                diff_us[idx_lane] = force_bound + force_middleline
                #
                #diff_us[idx_lane] = force_middleline
                #
            else:
                diff_us[idx_lane] = force_bound*road_attrs['two_dim_paras_dict'][lane_id]['amplyfier_bound'] +\
                    force_middleline + \
                    force_neighbors*road_attrs['two_dim_paras_dict'][lane_id]['amplyfier_intra_lanes'] + \
                    force_mark*road_attrs['two_dim_paras_dict'][lane_id]['amplyfier_lane_mark']
            
                
            #DEBUG BEGIN
            if lane_id==1:
                #
                #print(ego_y, ego_lane_lw,'-------', '==', force_left_and_right, '==', force_middleline,'==',  #force_neighbors, '==', force_mark)
                #if force_bound!=0:
                #    raise ValueError(force_bound, 'ssfsdf')
                pass
                
            #DEBUG END
            
            
            
        return diff_us


    @classmethod
    def forces(self, STATE, road_attrs, two_dim_paras = two_dim_paras):
        """
        diff_us = self.forces(STATE, road_attrs)
        -----------------------------------
        @input: STATE
        
            STATE = [y0, u0, z0, y1, u1, z1,....yN, uN, zN]
        
            its length is 3*n_lanes
        
        @input: road_attrs 
        
            a dict. 
            
            road_attrs = self.get_road_attributes()
            
            road_attrs is:
        
                {'two_dim_paras_dict':
                'lanes_ids': [0, 1, 2, 3],
                 'lws': [3.5, 3.5, 3.5, 3.5],
                 'length': 1000,
                 'lws_dict': {0: 3.5, 1: 3.5, 2: 3.5, 3: 3.5},
                 'left_lane_id': {1: 0, 2: 1, 3: 2},
                 'right_lane_id': {0: 1, 1: 2, 2: 3},
                 'ellipse_y_left': {0: 0, 1: 3.5, 2: 3.5, 3: 3.5},
                 'ellipse_y_right': {0: 3.5, 1: 3.5, 2: 3.5, 3: 0},
                 'lanes_middle_line': {0: 12.25, 1: 8.75, 2: 5.25, 3: 1.75},
                 'lanes_marks_coors': {0: (10.5, 14.0),
                  1: (7.0, 10.5),
                  2: (3.5, 7.0),
                  3: (0.0, 3.5)},
                 'road_bounds': (0, 14.0),
                 'lw_boundary_lanes': (3.5, 3.5)}
            
            
            
        
        @OUTPUT: diff_us
        
            diff_us are the forces for each lane. 
            
            diff_us is a 1d array, length is the same as number of lanes 
        
            
        """
        #
        
        n_lanes = len(road_attrs['lanes_ids'])
        diff_us = np.zeros((n_lanes,))
        
        #
        for idx_lane,lane_id in enumerate(road_attrs['lanes_ids']):
            left_mark_force = True;right_mark_force = True
            left_bound_force = True;right_bound_force = True
            #
            #idx_lane = 0 means rightbound not exit and left mark force not exist. 
            if idx_lane==0:
                left_mark_force = False
                right_bound_force = False
                #
                right_mark_force = True
                left_bound_force = True
                
            #
            if idx_lane==len(road_attrs['lanes_ids'])-1:
                right_mark_force = False
                left_bound_force = False
                #
                left_mark_force = True
                right_bound_force = True
                
            
            #===================
            road_bounds = road_attrs['road_bounds']
            #==================================force_bound
            #force_road_bound(self, y, ego_lane_lw  = 3.5,  road_bounds = (-3.5/2.0, 3.5/2.0), two_dim_paras = two_dim_paras)
            #*3 is because for each lane the state ys [y,u,z]
            ego_y = STATE[idx_lane*3]
            ego_lane_lw = road_attrs['lws'][idx_lane]
            #
            road_bounds = road_attrs['road_bounds']
            #
            two_dim_paras =  road_attrs['two_dim_paras_dict'][lane_id]
            #
            #---------------
            force_bound = self.force_road_bound(y = ego_y, lw_boundary_lanes = road_attrs['lw_boundary_lanes'], ego_lane_lw  = ego_lane_lw,  road_bounds = road_bounds, two_dim_paras = two_dim_paras, left_force_exist = left_bound_force, right_force_exist = right_bound_force)
            #DEBUG
            if lane_id==2:
                #print(ego_y, road_bounds, force_bound, road_attrs['lw_boundary_lanes'])
                pass
            #DEBUG END
            
            #
            #==================================force_middleline
            ego_u = STATE[idx_lane*3 + 1]
            lane_middle_line_coor = road_attrs['lanes_middle_line'][lane_id]
            #
            force_middleline = self.force_middleline(y = ego_y, u = ego_u, ego_lane_lw = ego_lane_lw, lane_middle_line_coor = lane_middle_line_coor, two_dim_paras = two_dim_paras)

            #==================================force_neighbores
            #force_neighbors(self, y_ego, y_others, ego_lane_lw, two_dim_paras = two_dim_paras)
            y_others,lw_left_right,flow_type_left_right = self.get_neighbores_y(idx_ego_lane = idx_lane, n_lanes  = n_lanes, STATE = STATE, road_attrs = road_attrs)
            #
            force_left_and_right = self.force_neighbors(y_ego = ego_y, y_others = y_others, ego_lane_lw = ego_lane_lw, two_dim_paras = two_dim_paras, lw_left_right = lw_left_right, flow_type_left_right = flow_type_left_right)
            force_neighbors = sum(force_left_and_right)

            #==================================force_mark
            #force_mark(self, y, lane_mark_coors = (-3.5/2.0, 3.5/2.0), two_dim_paras = two_dim_paras)
            lane_mark_coors  = road_attrs['lanes_marks_coors'][lane_id]
            #
            force_mark = self.force_mark(y = ego_y, lw = ego_lane_lw, lane_mark_coors = lane_mark_coors, two_dim_paras = two_dim_paras,left_force_exist = left_mark_force, right_force_exist = right_mark_force)
            
            #==============================
            diff_us[idx_lane] = \
                force_bound * road_attrs['two_dim_paras_dict'][lane_id]['amplyfier_bound'] +\
                force_middleline + \
                force_neighbors * road_attrs['two_dim_paras_dict'][lane_id]['amplyfier_intra_lanes'] + \
                force_mark * road_attrs['two_dim_paras_dict'][lane_id]['amplyfier_lane_mark']
            
            
        
        return diff_us
    
    
    @classmethod
    def get_road_attributes(self, two_dim_paras_dict4each_lane = {i:two_dim_paras for i in  [0, 1, 2, 3]}, lanes_ids = [0, 1, 2, 3], lws = [3.5, 3.5, 3.5, 3.5], length = 1000):
        """
        
        
        Callback:
        
            road_attrs = self.get_road_attributes()
            
            road_attrs is:
        
                {'two_dim_paras_dict':
                'lanes_ids': [0, 1, 2, 3],
                 'lws': [3.5, 3.5, 3.5, 3.5],
                 'length': 1000,
                 'lws_dict': {0: 3.5, 1: 3.5, 2: 3.5, 3: 3.5},
                 'left_lane_id': {1: 0, 2: 1, 3: 2},
                 'right_lane_id': {0: 1, 1: 2, 2: 3},
                 'ellipse_y_left': {0: 0, 1: 3.5, 2: 3.5, 3: 3.5},
                 'ellipse_y_right': {0: 3.5, 1: 3.5, 2: 3.5, 3: 0},
                 'lanes_middle_line': {0: 12.25, 1: 8.75, 2: 5.25, 3: 1.75},
                 'lanes_marks_coors': {0: (10.5, 14.0),
                  1: (7.0, 10.5),
                  2: (3.5, 7.0),
                  3: (0.0, 3.5)},
                 'road_bounds': (0, 14.0),
                 'lw_boundary_lanes': (3.5, 3.5)}
        
        """
        #returned value. 
        road_attributes = {}
        
        #========================================lanes_ids, self.lws, self.length
        #   lane id
        road_attributes['lanes_ids'] = lanes_ids
        road_attributes['lws'] = lws
        road_attributes['length'] = length
        
        #========================================self.lws_dict
        road_attributes['lws_dict'] = {laneid:lw for laneid,lw in zip(lanes_ids, lws)}
        #print(road_attributes['lws_dict'])
        
        #============================================two_dim_paras
        road_attributes['two_dim_paras_dict'] = copy.deepcopy(two_dim_paras_dict4each_lane)
        
        #========================================self.left_lane_id and self.right_lane_id
        #   calculate the left-lane and right_lane. 
        road_attributes['left_lane_id'] = {}
        road_attributes['right_lane_id'] = {}
        for idx in range(len(lanes_ids)-1):
            laneid = lanes_ids[idx]
            road_attributes['right_lane_id'][laneid] = lanes_ids[idx + 1] 
        #
        for idx in range(1, len(lanes_ids)):
            laneid = lanes_ids[idx]
            road_attributes['left_lane_id'][laneid] = lanes_ids[idx - 1] 
        #========================================self.ellipse_y_left and self.ellipse_y_right
        #calcualte the ellipse_y
        road_attributes['ellipse_y_left'] = {}
        road_attributes['ellipse_y_right'] = {}
        for idx in range( len(lanes_ids)):
            laneid = lanes_ids[idx]
            #self.ellipse_y_left
            if idx==0:
                road_attributes['ellipse_y_left'][laneid] = 0
                #
                road_attributes['ellipse_y_right'][laneid] = road_attributes['lws_dict'][laneid]/2.0 + road_attributes['lws_dict'][road_attributes['right_lane_id'][laneid]]/2.0
                continue
            #self.ellipse_y_left
            if idx==len(lanes_ids)-1:
                road_attributes['ellipse_y_right'][laneid] = 0
                road_attributes['ellipse_y_left'][laneid] = road_attributes['lws_dict'][laneid]/2.0 + road_attributes['lws_dict'][road_attributes['left_lane_id'][laneid]]/2.0
                continue
            #-----------
            road_attributes['ellipse_y_left'][laneid] = road_attributes['lws_dict'][laneid]/2.0 + road_attributes['lws_dict'][road_attributes['left_lane_id'][laneid]]/2.0
            #print(road_attributes['lws_dict'].keys())
            road_attributes['ellipse_y_right'][laneid] = road_attributes['lws_dict'][laneid]/2.0 + road_attributes['lws_dict'][road_attributes['right_lane_id'][laneid]]/2.0
        
        #========================================self.length
        road_attributes['length'] = length
        #
        #========================================self.lanes_middle_line
        #calculate the lanes middle line coordinate. 
        #self.lanes_middle_line[land_id] = the lateral coordinate of the lane middle line. 
        #   NOTE that the origin locates at the rightmost lane boundary. 
        road_attributes['lanes_middle_line'] = {}
        for idx in range(len(lanes_ids)):
            #
            laneid = lanes_ids[idx]
            #
            road_attributes['lanes_middle_line'][laneid]  = road_attributes['lws_dict'][laneid]/2.0 + sum(lws[idx+1:])
            #
        #========================================self.lanes_marks_coors
        #self.lanes_marks_coors[laneid] = (left_mark_coor, right_mark_coor), both are floats. 
        road_attributes['lanes_marks_coors'] = {}
        for idx in range(len(lanes_ids)):
            #
            laneid = lanes_ids[idx]
            #
            road_attributes['lanes_marks_coors'][laneid]  = (road_attributes['lanes_middle_line'][laneid] - road_attributes['lws_dict'][laneid]/2.0, road_attributes['lanes_middle_line'][laneid] + road_attributes['lws_dict'][laneid]/2.0)
        #======================================self.road_bounds
        road_attributes['road_bounds'] = (0, sum(lws))
        #lw_boundary_lanes
        road_attributes['lw_boundary_lanes'] = (lws[-1], lws[0])
        
        #========================================Dynmaic properties. 
        #   ----------------self.vehs_at_lanes, self.vehs_dict,self.vehs_target_lane
        #self.vehs_at_lanes[lane_id] = [vid1, vid2,....]. NOTE THAT THEY ARE SPORTED FROM 1st vehicle to last vehicle. 
        #self.vehs_at_lanes  =  {lane_ids:[] for lane_ids in lanes_ids}
        #self.vehs_dict[vehicle_id] = [x, vx, y, vy, zlon, zlat]
        #self.vehs_dict = {}
        #self.vehs_target_lane = {vid:lane_id}, the target lane id of each vehicle. 
        #   then the target lateral location is determined via: self.lanes_middle_line[self.vehs_target_lane[vid]]
        #self.vehs_target_lane = {}
        #   self.snapshots[moment] is a dict. 
        #   self.snapshots[moment][vid] is a dict. 
        #   self.snapshots[moment][vid] keys include 'leader','neighbores','potentials.'
        #self.snapshots = {}
        #-------------------------------
        
        return road_attributes
        #
        pass
    
    
    @classmethod
    def WeightProb(self, ):
        """
        
        """
        
        
        pass
    
    @classmethod
    def Ratio_extract(self,  lanes_ids = [0, 1, 2, 3], ratios_HDV = [.4, .5, .6, .7]):
        """
        
        
        #three lanes
        combinations,probabilities = twodim.LateralWanderingMultiLane.Ratio_extract(lanes_ids = [0, 1], ratios_HDV = [.4, .5,])
        
        #Four lanes
        combinations,probabilities = twodim.LateralWanderingMultiLane.Ratio_extract()
        """
        #
        structures = [['HDV','AV'] for laneid in lanes_ids]
        #possible_combinations = [('HDV', 'HDV', 'AV', 'AV'), ]
        possible_combinations = list(itertools.product(*structures))
        #len(combination)=len(lanes_ids)
        probabilities_combinations = []
        for combination in possible_combinations:
            p = 1.0
            for typee,ratio in zip(combination, ratios_HDV):
                if typee=='HDV':
                    p = p*ratio
                else:
                    p = p*(1-ratio)
            probabilities_combinations.append(p)
        
        #
        probabilities_combinations = np.array(probabilities_combinations)
        all_indexes = np.array(range(len(probabilities_combinations)))
        #
        effective_indexes = all_indexes[probabilities_combinations>.0]
        #
        effective_combinations = [possible_combinations[i] for i in effective_indexes]
        #print(probabilities_combinations)
        effective_probabilities = probabilities_combinations[effective_indexes]
        #
        return effective_combinations,effective_probabilities
    
    
    @classmethod
    def set_init_STATE(self, road_attrs, single_lane_init_states = [.0, .0, .0]):
        """
        
        """

        
        #STATE_init = copy.deepcopy(single_lane_init_states*len(road_attrs['lanes_ids']))
        STATE_init = []
        for i in range(len(road_attrs['lanes_ids'])):
            STATE_init.extend(copy.deepcopy(single_lane_init_states))
        #
        #change y.
        for i,lane_id in enumerate(road_attrs['lanes_ids']):
            idx_y  = i*3
            STATE_init[idx_y] = road_attrs['lanes_middle_line'][lane_id]
            
        return STATE_init
        
    
    @classmethod
    def sim_lanes_HDVs_AVs(self, \
        tspan = np.linspace(0, 100, 100), \
        single_lane_init_states = [.0, .0, .0], \
        two_dim_paras_dict4each_lane = {i:two_dim_paras for i in  [0, 1, 2, 3]}, \
        lanes_ids = [0, 1, 2, 3], \
        lws = [3.5, 3.5, 3.5, 3.5], \
        length = 1000, \
        stochastic_proecess_name='OU', \
        N_paths = 100, \
        flow_types = ['HDV', 'AV', 'HDV', 'AV'], \
        two_dim_paras_AV = two_dim_paras_AV, \
        two_dim_paras_HDV = two_dim_paras):
        """
        The simulation of the multi lane lateral dynamics condiering the mixed AV flow. 
        
        Whether the lanr traffic flow is AV or HDV is given by the arg:
        
            flow_structure = ['HDV', 'AV', 'HDV', 'AV']
            
        It is the same length as lanes_ids. 
        
        The following diffeences exist for the HDV and AV:
        
            - The two_dim_paras are different from the HDV
            - The neighbroing vehicles don't influence  the AVs. That is to say, the 
        
        -------------------------------------------------------
        @input: 
        
        
        """
        import sdeint
        #==================================two_dim_paras_dict4each_lane
        two_dim_paras_dict4each_lane = {}
        for lane_id,flow_type in zip(lanes_ids, flow_types):
            if 'AV' in flow_type:
                two_dim_paras_dict4each_lane[lane_id] = copy.deepcopy(two_dim_paras_AV)
            else:
                two_dim_paras_dict4each_lane[lane_id] = copy.deepcopy(two_dim_paras_HDV)

        #==============================road_attrs
        #road attributes
        # {'two_dim_paras_dict': 
        # {'lanes_ids': [0, 1, 2, 3],
        # 'lws': [3.5, 3.5, 3.5, 3.5],
        # 'length': 1000,
        # 'lws_dict': {0: 3.5, 1: 3.5, 2: 3.5, 3: 3.5},
        # 'left_lane_id': {1: 0, 2: 1, 3: 2},
        # 'right_lane_id': {0: 1, 1: 2, 2: 3},
        # 'ellipse_y_left': {0: 0, 1: 3.5, 2: 3.5, 3: 3.5},
        # 'ellipse_y_right': {0: 3.5, 1: 3.5, 2: 3.5, 3: 0},
        # 'lanes_middle_line': {0: 12.25, 1: 8.75, 2: 5.25, 3: 1.75},
        # 'lanes_marks_coors': {0: (10.5, 14.0),
        # 1: (7.0, 10.5),
        # 2: (3.5, 7.0),
        # 3: (0.0, 3.5)},
        # 'road_bounds': (0, 14.0),
        # 'lw_boundary_lanes': (3.5, 3.5)}
        #print(lanes_ids)
        road_attrs = self.get_road_attributes(two_dim_paras_dict4each_lane = two_dim_paras_dict4each_lane, lanes_ids = lanes_ids, lws = lws, length = length)
        road_attrs['flow_types'] = copy.deepcopy(flow_types)
        
        #=============================STATE_init
        #the state of the whold road. 
        STATE_init = self.set_init_STATE(single_lane_init_states = single_lane_init_states, road_attrs =road_attrs)#copy.deepcopy(single_lane_init_states*len(lanes_ids))
        
        #print(len(road_attrs['lanes_ids']))
        #===================================
        def F(STATE, t):
            """
            #road_attrs = copy.deepcopy(road_attrs), 
            @input: state
            
                state = [y0, u0, z0, y1, u1, z1, y2, u2...]
                
                The length of state is three times.  the number of lanes. 
            
            @OUTPUT: diff_states
            """
            #returned value
            diffs = 0*np.array(STATE)
            #
            #print(road_attrs, '----')
            #
            n_lanes = len(road_attrs['lanes_ids'])
            
            #=========================diff_y_i
            #diff_y_i = u_i
            for i in range(n_lanes):
                #print(len(diffs), len(STATE), i, idx)
                diffs[i*3] = STATE[i*3 + 1]
            
            #========================diff_u_i
            #diff_u = force, shape is the same as number of lanes. 
            diff_us = self.forces_HDVs_AVs(STATE = copy.deepcopy(STATE), road_attrs = road_attrs, )
            for i in range(n_lanes):
                #idx = i*3 +1, 
                #the noise. 
                diffs[i*3 +1 ] = copy.deepcopy(diff_us[i] + STATE[i*3 + 2] ) 
            
            
            #========================diff_z_i
            #
            for i,lane_id in enumerate(road_attrs['lanes_ids']):
                #
                two_dim_paras = road_attrs['two_dim_paras_dict'][lane_id]
                #
                Z_lat = STATE[i*3 + 2]
                #==============================diff_Z_long, diff_Z_lat
                if stochastic_proecess_name=='OU':
                    #diff_Z_long = -(sigma_long**1.0)*(Z_long**3)
                    #diff_Z_lat = -(sigma_lat**1.0)*(Z_lat)
                    #print(Z_long, sigma_long_drift)
                    #diff_Z_long = -two_dim_paras['sigma_long_drift']*Z_long
                    diff_Z_lat = -two_dim_paras['sigma_lat_drift']*Z_lat
                elif stochastic_proecess_name=='simple':
                    #diff_Z_long = -(sigma_long**1.0)*(Z_long**3)
                    #diff_Z_lat = -(sigma_lat**1.0)*(Z_lat)
                    #print(Z_long, sigma_long_drift)
                    #diff_Z_long = 0
                    diff_Z_lat = 0
                elif stochastic_proecess_name=='converted':
                    #the converted. 
                    #diff_Z_long = -(two_dim_paras['sigma_long']**2)*(1-Z_long**2)*Z_long
                    diff_Z_lat = -(two_dim_paras['sigma_lat']**2)*(1-Z_lat**2)*Z_lat
                elif stochastic_proecess_name=='geometric':
                    #
                    #diff_Z_long =  -two_dim_paras['sigma_long_drift']*(Z_long)
                    diff_Z_lat = -two_dim_paras['sigma_lat_drift']*(Z_lat)
                    #
                elif stochastic_proecess_name=='jacobi':
                    #
                    #diff_Z_long = -two_dim_paras['sigma_long_drift']*(Z_long - .0)
                    diff_Z_lat = -two_dim_paras['sigma_lat_drift']*(Z_lat - .0)
                    #
                elif stochastic_proecess_name=='hyperparabolic':
                    #
                    #diff_Z_long = -sigma_long_drift*(Z_long - .0)
                    #diff_Z_lat = -sigma_lat_drift*(Z_lat - .0)
                    #diff_Z_long =  -Z_long-two_dim_paras['sigma_long_drift']*Z_long
                    diff_Z_lat = -Z_lat-two_dim_paras['sigma_lat_drift']*Z_lat
                    #print(diff_Z_long, diff_Z_lat)
                elif stochastic_proecess_name=='ROU':
                    #ew_state = STATES[-1] + (theta/STATES[-1] -  STATES[-1] )*deltat + sigma*brownian
                    #diff_Z_long = -two_dim_paras['sigma_long_drift']/Z_long +  Z_long#-sigma_long_drift*(Z_long - .0)
                    diff_Z_lat = -two_dim_paras['sigma_lat_drift']/Z_lat +  Z_lat #-sigma_lat_drift*(Z_lat - .0)
                #----------------------
                diffs[i*3 + 2] = diff_Z_lat
            #--------------------------------------------
            return diffs
            
        #===================================
        def L(STATE, t):
            """
            @OUTPUT: res
            
                shape is np.zeros((3*n_lanes, n_lanes))
                
                
            """
            n_lanes = len(road_attrs['lanes_ids'])
            #S = [y, vy, z], z is the nois. 
            res = np.zeros((3*n_lanes, n_lanes))
            #
            #
            for i,lane_id in enumerate(road_attrs['lanes_ids']):
                #
                Z_lat = STATE[i*3 + 2]
                #
                two_dim_paras = road_attrs['two_dim_paras_dict'][lane_id]
                sigma_lat = two_dim_paras['sigma_lat']
                
                #------------------------------------------
                if stochastic_proecess_name=='OU':
                    tmp_lat = sigma_lat
                    #
                elif stochastic_proecess_name=='simple':
                    tmp_lat = sigma_lat
                    
                elif stochastic_proecess_name=='converted':
                    tmp_lat = sigma_lat*(1-Z_lat**2)
                    #
                elif stochastic_proecess_name=='geometric':
                    tmp_lat = sigma_lat*(Z_lat)
                    #
                elif stochastic_proecess_name=='hyperparabolic':

                    tmp_lat = sigma_lat
                    
                elif stochastic_proecess_name=='jacobi':
                    #print(Z_lat, (.5-Z_lat), (Z_lat+.5))
                    Z_lat = max(-.499999, min(Z_lat, .4999999))
                    tmp_lat = np.sqrt(sigma_lat*(Z_lat+.5)*(.5-Z_lat))
                elif stochastic_proecess_name=='ROU':

                    tmp_lat = sigma_lat
                #
                res[i*3 + 2, i] = tmp_lat
            #
            #
            return res
        
        
        
        """
        #Simulation. 
        results = []
        #---------------------------------------------
        for iterr in range(N_paths):
            #result.shape is (len(tspan),2), '2' corresponds to Z.
            #   the first column is lateral displacement, and the 2nd columns is the noize. 
            #
            realtime_STATE = copy.deepcopy(STATE_init)
            #
            delta_ts = np.diff(tspan)
            #
            for t,deltat in zip(tspan[1:], delta_ts):
                #get F and L
                
                
                
                pass
            
            
            
            result = sdeint.itoint(F, L, STATE_init, tspan)
            results.append(result)
            #res_Y.append(result[:,0])
            #res_Z.append(result[:,1])
        #-----------------------------------------
        #np.array(res_Y) shape is N_paths,len(tspan)
        #np.array(res_Z) shape is N_paths,len(tspan)
        return results
        """
        #Simulation. 
        results = []
        #---------------------------------------------
        for iterr in range(N_paths):
            #result.shape is (len(tspan),2), '2' corresponds to Z.
            #   the first column is lateral displacement, and the 2nd columns is the noize. 
            result = sdeint.itoint(F, L, STATE_init, tspan)
            results.append(result)
            #res_Y.append(result[:,0])
            #res_Z.append(result[:,1])
        #-----------------------------------------
        #np.array(res_Y) shape is N_paths,len(tspan)
        #np.array(res_Z) shape is N_paths,len(tspan)
        return results,road_attrs
        #return pd.DataFrame(res_Y, columns =  tspan).T,pd.DataFrame(res_Z, columns =  tspan).T
        
        
    
    @classmethod
    def sim(self, tspan = np.linspace(0, 100, 100), single_lane_init_states = [.0, .0, .0], two_dim_paras_dict4each_lane = {i:two_dim_paras for i in  [0, 1, 2, 3]}, lanes_ids = [0, 1, 2, 3], lws = [3.5, 3.5, 3.5, 3.5], length = 1000, stochastic_proecess_name='OU', N_paths = 100):
        """
        
        @input: single_lane_ini_states
        
            the initial state for single lane. 
            The state is [y,u,z].
            
            The state of the whole road then can be expressed as:
            
                STATE_init = copy.deepcopy(single_lane_init_states*len(lanes_ids))
        
        @input: two_dim_paras_dict4each_lane
        
            two_dim_paras_dict4each_lane[lane_id] = two_dim_paras
        
        @inut: 
        
        """
        import sdeint

        #==============================road_attrs
        #road attributes
        # {'two_dim_paras_dict': 
        # {'lanes_ids': [0, 1, 2, 3],
        # 'lws': [3.5, 3.5, 3.5, 3.5],
        # 'length': 1000,
        # 'lws_dict': {0: 3.5, 1: 3.5, 2: 3.5, 3: 3.5},
        # 'left_lane_id': {1: 0, 2: 1, 3: 2},
        # 'right_lane_id': {0: 1, 1: 2, 2: 3},
        # 'ellipse_y_left': {0: 0, 1: 3.5, 2: 3.5, 3: 3.5},
        # 'ellipse_y_right': {0: 3.5, 1: 3.5, 2: 3.5, 3: 0},
        # 'lanes_middle_line': {0: 12.25, 1: 8.75, 2: 5.25, 3: 1.75},
        # 'lanes_marks_coors': {0: (10.5, 14.0),
        # 1: (7.0, 10.5),
        # 2: (3.5, 7.0),
        # 3: (0.0, 3.5)},
        # 'road_bounds': (0, 14.0),
        # 'lw_boundary_lanes': (3.5, 3.5)}
        road_attrs = self.get_road_attributes(two_dim_paras_dict4each_lane = two_dim_paras_dict4each_lane, lanes_ids = lanes_ids, lws = lws, length = length)
        
        #=============================STATE_init
        #the state of the whold road. 
        STATE_init = self.set_init_STATE(single_lane_init_states = single_lane_init_states, road_attrs =road_attrs)#copy.deepcopy(single_lane_init_states*len(lanes_ids))
        
        #print(len(road_attrs['lanes_ids']))
        #===================================
        def F(STATE, t):
            """
            #road_attrs = copy.deepcopy(road_attrs), 
            @input: state
            
                state = [y0, u0, z0, y1, u1, z1, y2, u2...]
                
                The length of state is three times.  the number of lanes. 
            
            @OUTPUT: diff_states
            """
            #returned value
            diffs = copy.deepcopy(0*np.array(STATE))
            #
            #print(road_attrs, '----')
            #
            n_lanes = len(road_attrs['lanes_ids'])
            
            #=========================diff_y_i
            #diff_y_i = u_i
            for i in range(n_lanes):
                #print(len(diffs), len(STATE), i, idx)
                diffs[i*3] = copy.deepcopy(STATE[i*3 + 1])
            
            #========================diff_u_i
            #diff_u = force, shape is the same as number of lanes. 
            diff_us = self.forces(STATE = STATE, road_attrs = road_attrs,)
            for i in range(n_lanes):
                diffs[i*3 +1] = diff_us[i] + STATE[i*3 + 2]
            
            
            #========================diff_z_i
            #
            for i,lane_id in enumerate(road_attrs['lanes_ids']):
                #
                idx = i*3 + 2
                two_dim_paras = road_attrs['two_dim_paras_dict'][lane_id]
                #
                Z_lat = STATE[idx]
                #==============================diff_Z_long, diff_Z_lat
                if stochastic_proecess_name=='OU':
                    #diff_Z_long = -(sigma_long**1.0)*(Z_long**3)
                    #diff_Z_lat = -(sigma_lat**1.0)*(Z_lat)
                    #print(Z_long, sigma_long_drift)
                    #diff_Z_long = -two_dim_paras['sigma_long_drift']*Z_long
                    diff_Z_lat = -two_dim_paras['sigma_lat_drift']*Z_lat
                elif stochastic_proecess_name=='simple':
                    #diff_Z_long = -(sigma_long**1.0)*(Z_long**3)
                    #diff_Z_lat = -(sigma_lat**1.0)*(Z_lat)
                    #print(Z_long, sigma_long_drift)
                    #diff_Z_long = 0
                    diff_Z_lat = 0
                elif stochastic_proecess_name=='converted':
                    #the converted. 
                    #diff_Z_long = -(two_dim_paras['sigma_long']**2)*(1-Z_long**2)*Z_long
                    diff_Z_lat = -(two_dim_paras['sigma_lat']**2)*(1-Z_lat**2)*Z_lat
                elif stochastic_proecess_name=='geometric':
                    #
                    #diff_Z_long =  -two_dim_paras['sigma_long_drift']*(Z_long)
                    diff_Z_lat = -two_dim_paras['sigma_lat_drift']*(Z_lat)
                    #
                elif stochastic_proecess_name=='jacobi':
                    #
                    #diff_Z_long = -two_dim_paras['sigma_long_drift']*(Z_long - .0)
                    diff_Z_lat = -two_dim_paras['sigma_lat_drift']*(Z_lat - .0)
                    #
                elif stochastic_proecess_name=='hyperparabolic':
                    #
                    #diff_Z_long = -sigma_long_drift*(Z_long - .0)
                    #diff_Z_lat = -sigma_lat_drift*(Z_lat - .0)
                    #diff_Z_long =  -Z_long-two_dim_paras['sigma_long_drift']*Z_long
                    diff_Z_lat = -Z_lat-two_dim_paras['sigma_lat_drift']*Z_lat
                    #print(diff_Z_long, diff_Z_lat)
                elif stochastic_proecess_name=='ROU':
                    #ew_state = STATES[-1] + (theta/STATES[-1] -  STATES[-1] )*deltat + sigma*brownian
                    #diff_Z_long = -two_dim_paras['sigma_long_drift']/Z_long +  Z_long#-sigma_long_drift*(Z_long - .0)
                    diff_Z_lat = -two_dim_paras['sigma_lat_drift']/Z_lat +  Z_lat #-sigma_lat_drift*(Z_lat - .0)
                #----------------------
                diffs[idx] = copy.deepcopy(diff_Z_lat)
            #--------------------------------------------
            return diffs
            
        #===================================
        def L(STATE, t):
            """
            @OUTPUT: res
            
                shape is np.zeros((3*n_lanes, n_lanes))
                
                
            """
            n_lanes = len(road_attrs['lanes_ids'])
            #S = [y, vy, z], z is the nois. 
            res = np.zeros((3*n_lanes, n_lanes))
            #
            #
            for i,lane_id in enumerate(road_attrs['lanes_ids']):
                #
                idx = i*3 + 2
                Z_lat = copy.deepcopy(STATE[idx])
                #
                two_dim_paras = road_attrs['two_dim_paras_dict'][lane_id]
                sigma_lat = two_dim_paras['sigma_lat']
                
                #------------------------------------------
                if stochastic_proecess_name=='OU':
                    tmp_lat = sigma_lat
                    #
                elif stochastic_proecess_name=='simple':
                    tmp_lat = sigma_lat
                    
                elif stochastic_proecess_name=='converted':
                    tmp_lat = sigma_lat*(1-Z_lat**2)
                    #
                elif stochastic_proecess_name=='geometric':
                    tmp_lat = sigma_lat*(Z_lat)
                    #
                elif stochastic_proecess_name=='hyperparabolic':

                    tmp_lat = sigma_lat
                    
                elif stochastic_proecess_name=='jacobi':
                    #print(Z_lat, (.5-Z_lat), (Z_lat+.5))
                    Z_lat = max(-.499999, min(Z_lat, .4999999))
                    tmp_lat = np.sqrt(sigma_lat*(Z_lat+.5)*(.5-Z_lat))
                elif stochastic_proecess_name=='ROU':

                    tmp_lat = sigma_lat
                #
                res[idx, i] = tmp_lat
            
            #
            #
            return res
        
        
        
        """
        #Simulation. 
        results = []
        #---------------------------------------------
        for iterr in range(N_paths):
            #result.shape is (len(tspan),2), '2' corresponds to Z.
            #   the first column is lateral displacement, and the 2nd columns is the noize. 
            #
            realtime_STATE = copy.deepcopy(STATE_init)
            #
            delta_ts = np.diff(tspan)
            #
            for t,deltat in zip(tspan[1:], delta_ts):
                #get F and L
                
                
                
                pass
            
            
            
            result = sdeint.itoint(F, L, STATE_init, tspan)
            results.append(result)
            #res_Y.append(result[:,0])
            #res_Z.append(result[:,1])
        #-----------------------------------------
        #np.array(res_Y) shape is N_paths,len(tspan)
        #np.array(res_Z) shape is N_paths,len(tspan)
        return results
        """
        #Simulation. 
        results = []
        #---------------------------------------------
        for iterr in range(N_paths):
            #result.shape is (len(tspan),2), '2' corresponds to Z.
            #   the first column is lateral displacement, and the 2nd columns is the noize. 
            result = sdeint.itoint(F, L, STATE_init, tspan)
            results.append(result)
            #res_Y.append(result[:,0])
            #res_Z.append(result[:,1])
        #-----------------------------------------
        #np.array(res_Y) shape is N_paths,len(tspan)
        #np.array(res_Z) shape is N_paths,len(tspan)
        return results,road_attrs
        #return pd.DataFrame(res_Y, columns =  tspan).T,pd.DataFrame(res_Z, columns =  tspan).T
        
        
        """
        
        #==================================

        
        """
        

        
    
    
    def __init__(self, lanes_ids = [0, 1, 2, 3], lws = [3.5, 3.5, 3.5, 3.5], length = 1000):
        """
        
        
        Static Attributes:
        
            self.lanes_ids
            self.lws
            self.length
            self.lws_dict
            self.left_lane_id
            self.right_lane_id
            self.ellipse_y_left
            self.ellipse_y_right
            self.length
            self.lanes_middle_line
            self.lanes_marks_coors
            self.road_bounds
            
        ---------------------------------------------------------------
        @input: lws
        
            a lists containing the lane withs of each lane. 
            
            
            
        """
        
        
        #========================================self.lanes_ids, self.lws, self.length
        #   lane id
        self.lanes_ids = lanes_ids
        self.lws = lws
        self.length = length
        
        #========================================self.lws_dict
        self.lws_dict = {laneid:lw for laneid,lw in zip(lanes_ids, lws)}
        #========================================self.left_lane_id and self.right_lane_id
        #   calculate the left-lane and right_lane. 
        self.left_lane_id = {}
        self.right_lane_id = {}
        for idx in range(len(lanes_ids)-1):
            laneid = self.lanes_ids[idx]
            self.right_lane_id[laneid] = self.lanes_ids[idx + 1] 
        #
        for idx in range(1, len(lanes_ids)):
            laneid = self.lanes_ids[idx]
            self.left_lane_id[laneid] = self.lanes_ids[idx - 1] 
        #========================================self.ellipse_y_left and self.ellipse_y_right
        #calcualte the ellipse_y
        self.ellipse_y_left = {}
        self.ellipse_y_right = {}
        for idx in range( len(lanes_ids)):
            laneid = self.lanes_ids[idx]
            #self.ellipse_y_left
            if idx==0:
                self.ellipse_y_left[laneid] = 0
                #
                self.ellipse_y_right[laneid] = self.lws_dict[laneid]/2.0 + self.lws_dict[self.right_lane_id[laneid]]/2.0
                continue
            #self.ellipse_y_left
            if idx==len(lanes_ids)-1:
                self.ellipse_y_right[laneid] = 0
                self.ellipse_y_left[laneid] = self.lws_dict[laneid]/2.0 + self.lws_dict[self.left_lane_id[laneid]]/2.0
                continue
            #-----------
            self.ellipse_y_left[laneid] = self.lws_dict[laneid]/2.0 + self.lws_dict[self.left_lane_id[laneid]]/2.0
            self.ellipse_y_right[laneid] = self.lws_dict[laneid]/2.0 + self.lws_dict[self.right_lane_id[laneid]]/2.0
        
        #========================================self.length
        self.length = length
        #
        #========================================self.lanes_middle_line
        #calculate the lanes middle line coordinate. 
        #self.lanes_middle_line[land_id] = the lateral coordinate of the lane middle line. 
        #   NOTE that the origin locates at the rightmost lane boundary. 
        self.lanes_middle_line = {}
        for idx in range(len(lanes_ids)):
            #
            laneid = self.lanes_ids[idx]
            #
            self.lanes_middle_line[laneid]  = self.lws_dict[laneid]/2.0 + sum(lws[idx+1:])
            #
        #========================================self.lanes_marks_coors
        #self.lanes_marks_coors[laneid] = (left_mark_coor, right_mark_coor), both are floats. 
        self.lanes_marks_coors = {}
        for idx in range(len(lanes_ids)):
            #
            laneid = self.lanes_ids[idx]
            #
            self.lanes_marks_coors[laneid]  = (self.lanes_middle_line[laneid] - self.lws_dict[laneid]/2.0, self.lanes_middle_line[laneid] + self.lws_dict[laneid]/2.0)
        #======================================self.road_bounds
        self.road_bounds = (0, sum(lws))
        #lw_boundary_lanes
        self.lw_boundary_lanes = (self.lws[0], self.lws[-1])
        
        #========================================Dynmaic properties. 
        #   ----------------self.vehs_at_lanes, self.vehs_dict,self.vehs_target_lane
        #self.vehs_at_lanes[lane_id] = [vid1, vid2,....]. NOTE THAT THEY ARE SPORTED FROM 1st vehicle to last vehicle. 
        self.vehs_at_lanes  =  {lane_ids:[] for lane_ids in lanes_ids}
        #self.vehs_dict[vehicle_id] = [x, vx, y, vy, zlon, zlat]
        self.vehs_dict = {}
        #self.vehs_target_lane = {vid:lane_id}, the target lane id of each vehicle. 
        #   then the target lateral location is determined via: self.lanes_middle_line[self.vehs_target_lane[vid]]
        self.vehs_target_lane = {}
        #   self.snapshots[moment] is a dict. 
        #   self.snapshots[moment][vid] is a dict. 
        #   self.snapshots[moment][vid] keys include 'leader','neighbores','potentials.'
        self.snapshots = {}
        #-------------------------------
    
    pass

class FD_analysis():
    """
    
    """

    @classmethod
    def plot_FDs_given_mprs_results_given_lanes_number_averageoverlane_changecolor(self, FD_mprs_given_lanesnumber, ax = False, figsize = (5,3), alpha = .4, markersize = 10, marker = False):
        """
        Note that this method just change the marker, not the coloer. 
        
        If want to change the color, using :
        
            - self.plot_FDs_given_mprs_results_given_lanes_number_averageoverlane_changecolor()
        ---------------------------------------------------------
        @input: FD_mprs_given_lanesnumber
        
            FD_mprs_given_lanesnumber[mpr][desired_density] = (Q,K,V)
            
            Q is a dict, Q[laneid] = [q1,q2,...qn], eqch qi is a float. 
        
            It is obtained via: 
                #FD_mprs[lanesnumber][mpr][desired_density] = (Q,K,V)
                #Q is a dict, Q[laneid] = [q1,q2,...qn], eqch qi is a float. 
                FD_mprs = pickle.load(open(dataspath + 'RES_FD_mprs.pickle', 'rb'))
            
            and then FD_mprs_given_lanesnumber = FD_mprs[lanesnumber]
            
        

        
        
        """
        #
        if isinstance(marker, bool):
            #color = np.random.uniform(size = (3,))
            marker = np.random.choice(['.', ',', 'o', 'v', '^', '<', '>', '1', '2', '3', '4', '8', 's', 'p', '*', 'h', 'H', '+', 'x', 'D', 'd', '|', '_', 'P', 'X', ])
        """
        if isinstance(marker, bool):
            marker = np.random.choice(['.', ',', 'o', 'v', '^', '<', '>', '1', '2', '3', '4', '8', 's', 'p', '*', 'h', 'H', '+', 'x', 'D', 'd', '|', '_', 'P', 'X', 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,])
        """
        #
        #
        if isinstance(ax, bool):
            fig,ax = plt.subplots(figsize = figsize)#.add_subplot(projection='3d')
            
            #ax = plt.figure().add_subplot(projection='3d')
            #ax.set_xlabel('t');ax.set_ylabel('x');ax.set_zlabel('speed'); 
            #ax.grid();
            #ax = host_subplot(111)
        #
        
        
        for mpr in FD_mprs_given_lanesnumber.keys():
            #
            legend_added = True
            #
            color = np.random.uniform(size = (3,))
            #marker = np.random.choice(['.', ',', 'o', 'v', '^', '<', '>', '1', '2', '3', '4', '8', 's', 'p', '*', 'h', 'H', '+', 'x', 'D', 'd', '|', '_', 'P', 'X'])
            #
            for desired_density in FD_mprs_given_lanesnumber[mpr].keys():
                #Q[laneid] = [q1,q2,...qn]
                Q,K,V = FD_mprs_given_lanesnumber[mpr][desired_density]
                #
                
                ks = [np.mean(K[laneid]) for laneid in sorted(Q.keys())]
                qs = [np.mean(Q[laneid]) for laneid in sorted(Q.keys())]

                if legend_added:
                #color = np.random.uniform(size = (3,))
                    #
                    ax.plot([np.mean(ks)], [np.mean(qs)], marker = marker, color = color, alpha = alpha, label = 'mpr = ' + str(mpr), markersize = markersize)
                    #
                    legend_added = False
                else:
                    ax.plot([np.mean(ks)], [np.mean(qs)], marker = marker, color = color, alpha = alpha, markersize = markersize)
                    
                    
                    
                    #ax.plot([np.mean(K[laneid])], [np.mean(Q[laneid])],'.', alpha = alpha)
                    
                    """
                    if legend_added:
                    #color = np.random.uniform(size = (3,))
                        #
                        ax.plot([np.mean(K[laneid])], [np.mean(Q[laneid])],'.', color = color, alpha = alpha, label = label)
                        #
                        legend_added = False
                    else:
                        ax.plot([np.mean(K[laneid])], [np.mean(Q[laneid])],'.', color = color, alpha = alpha)
                    """
                
            
            #
        return ax
    
    @classmethod
    def capacity_from_FD(self, FD_density_as_key, typee = 'minimal', only_use_later_percentage = False):
        """
        Calculate the capaity from the FD.
        
        @input: FD_density_as_key
        
            FD_density_as_key[density] = (Q,V,K), Q[lane_id] is a list. 
        
        @intput: typee
        
            typee is either 'mean' or 'minimal'
            
            If is mean, the returned capacity is the average over all moments
            If is minimal, the returned capacity is the minimal flow rate. 
        
        
        @OUTPUT: capacity
            
            a float. 
            
        """
        
        #select
        densities = sorted(FD_density_as_key.keys())
        somedensity = np.random.choice(list(FD_density_as_key.keys()))
        lane_ids = list(FD_density_as_key[somedensity][0].keys())

        if not isinstance(only_use_later_percentage, bool):
            #FD_multilane[somedensity][0] is Q, a dict, the keys are lane ids. 
            idx = int(len(FD_density_as_key[somedensity][0][lane_ids[0]])*(1-only_use_later_percentage))
        else:
            idx = 0
            
        if typee=='mean':
            #----------------------------------------
            QS = []
            VS = []
            KS = []
            for density in FD_density_as_key.keys():
                #Q[laneid] is a list. 
                Q,V,K = FD_density_as_key[density]
                qs_lanes = [np.mean(Q[laneid][idx:]) for laneid in Q.keys()]
                vs_lanes = [np.mean(V[laneid][idx:]) for laneid in V.keys()]
                ks_lanes = [np.mean(K[laneid][idx:]) for laneid in K.keys()]
                
                QS.append(np.mean(qs_lanes))
                VS.append(np.mean(vs_lanes))
                KS.append(np.mean(ks_lanes))
            #
            capacity = max(QS)
            #idx = np.where(np.array(QS)==capacity)[0][0]
        elif typee=='minimal':
            #
            capacity = np.inf
            #
            for laneid in lane_ids:
                qs = [np.mean(FD_density_as_key[density][0][laneid][idx:]) for density in sorted(FD_density_as_key.keys())]
                vs = [np.mean(FD_density_as_key[density][1][laneid][idx:]) for density in sorted(FD_density_as_key.keys())]
                ks = [np.mean(FD_density_as_key[density][2][laneid][idx:]) for density in sorted(FD_density_as_key.keys())]
                #
                idx = np.where(np.array(qs)==max(qs))[0][0]
                #print(max(qs))
                #capacity_laneids = min(capacity_laneids, max(qs))
                capacity = min(capacity, min(FD_density_as_key[densities[idx]][0][laneid][idx:]))
        
        return capacity
    
    @classmethod
    def CAF_mixedAVs(self, FD_miexedAVs, base_capacity = 1952, only_use_later_percentage = False, exclude_width_threshodl = 2.0, sortt = False):
        """
        @input: FD_miexedAVs
        
            FD_miexedAVs[lanesnumber][mpr][desired_density] = (Q,V,K), Q[laneid] is a list. 
            
            They are obtained via:
            CAF_lanewidth
                reload(CAF)
                #FD_lanewidths[lanesnumber][lanewidth][mpr][desired_density] = (Q,V,K), Q[laneid] is a list. 
                FD_lanewidths = pickle.load(open(dataspath + 'RES_FD_lanewidths_new.pickle', 'rb'))
        @OUTPUT: capacities
            
            Capacities[lanewidth][mpr] = capacity
            
            
            pd.DataFrame(Capacities), rows are mprs and columns are the lane widths. 
        
        
        """
        #Capacities[lanewidth][mpr] = capacity
        Capacities = {}
        #
        #lanewidths and mprs
        lanesNs = sorted(FD_miexedAVs.keys())
        mprs = sorted(FD_miexedAVs[lanesNs[0]].keys())
        densities = sorted(FD_miexedAVs[lanesNs[0]][mprs[0]].keys())
        lane_ids = list(FD_miexedAVs[lanesNs[0]][mprs[0]][densities[0]][0].keys())
        #
        if not isinstance(only_use_later_percentage, bool):
            #FD_lanewidths[somedensity][0] is Q, a dict, the keys are lane ids. 
            idx = int(len(FD_miexedAVs[lanesNs[0]][mprs[0]][densities[0]][0][lane_ids[0]])*(1-only_use_later_percentage))
        else:
            idx = 0
        #
        for lanesN in lanesNs:
            #if lanewidth<exclude_width_threshodl:continue
            Capacities[lanesN] = {}
            for mpr in mprs:
                QS = [];VS = [];KS = []
                for density in FD_miexedAVs[lanesN][mpr].keys():
                    #Q[laneid] is a list. 
                    Q,V,K = FD_miexedAVs[lanesN][mpr][density]
                    #
                    qs_lanes = [np.mean(Q[laneid][idx:]) for laneid in Q.keys()]
                    vs_lanes = [np.mean(V[laneid][idx:]) for laneid in V.keys()]
                    ks_lanes = [np.mean(K[laneid][idx:]) for laneid in K.keys()]
                    #
                    QS.append(np.mean(qs_lanes))
                    VS.append(np.mean(vs_lanes))
                    KS.append(np.mean(ks_lanes))
                    #
                #
                capacity = max(QS)
                #idx = np.where(np.array(QS)==capacity)[0][0]
                #
                Capacities[lanesN][mpr] = capacity
            
        #Capacities.loc[mpr, lanewidth]
        Capacities = pd.DataFrame(Capacities)
        Capacities_returned = copy.deepcopy(Capacities)
        
        if sortt:
            for mpr in Capacities_returned.index:
                Capacities_returned.loc[mpr, :] = list(sorted(Capacities.loc[mpr, :].values))
            
        return Capacities_returned
    
    
    
    @classmethod
    def CAF_lanewidth(self, FD_lanewidths, base_capacity = 1952, only_use_later_percentage = False, exclude_width_threshodl = 2.0, sortt = False):
        """
        @input: FD_lanewidths
        
            FD_lanewidths[lanewidth][mpr][desired_density] = (Q,V,K), Q[laneid] is a list. 
            
            They are obtained via:
            CAF_lanewidth
                reload(CAF)
                #FD_lanewidths[lanesnumber][lanewidth][mpr][desired_density] = (Q,V,K), Q[laneid] is a list. 
                FD_lanewidths = pickle.load(open(dataspath + 'RES_FD_lanewidths_new.pickle', 'rb'))
        @OUTPUT: capacities
            
            Capacities[lanewidth][mpr] = capacity
            
            
            pd.DataFrame(Capacities), rows are mprs and columns are the lane widths. 
        
        
        """
        #Capacities[lanewidth][mpr] = capacity
        Capacities = {}
        #
        #lanewidths and mprs
        lanewidths = sorted(FD_lanewidths.keys())
        mprs = sorted(FD_lanewidths[lanewidths[0]].keys())
        densities = sorted(FD_lanewidths[lanewidths[0]][mprs[0]].keys())
        lane_ids = list(FD_lanewidths[lanewidths[0]][mprs[0]][densities[0]][0].keys())
        #
        if not isinstance(only_use_later_percentage, bool):
            #FD_lanewidths[somedensity][0] is Q, a dict, the keys are lane ids. 
            idx = int(len(FD_lanewidths[lanewidths[0]][mprs[0]][densities[0]][0][lane_ids[0]])*(1-only_use_later_percentage))
        else:
            idx = 0
        #
        for lanewidth in lanewidths:
            if lanewidth<exclude_width_threshodl:continue
            Capacities[lanewidth] = {}
            for mpr in mprs:
                QS = [];VS = [];KS = []
                for density in FD_lanewidths[lanewidth][mpr].keys():
                    #Q[laneid] is a list. 
                    Q,V,K = FD_lanewidths[lanewidth][mpr][density]
                    #
                    qs_lanes = [np.mean(Q[laneid][idx:]) for laneid in Q.keys()]
                    vs_lanes = [np.mean(V[laneid][idx:]) for laneid in V.keys()]
                    ks_lanes = [np.mean(K[laneid][idx:]) for laneid in K.keys()]
                    #
                    QS.append(np.mean(qs_lanes))
                    VS.append(np.mean(vs_lanes))
                    KS.append(np.mean(ks_lanes))
                    #
                #
                capacity = max(QS)
                #idx = np.where(np.array(QS)==capacity)[0][0]
                #
                Capacities[lanewidth][mpr] = capacity
            
        #Capacities.loc[mpr, lanewidth]
        Capacities = pd.DataFrame(Capacities)
        Capacities_returned = copy.deepcopy(Capacities)
        
        if sortt:
            for mpr in Capacities_returned.index:
                Capacities_returned.loc[mpr, :] = list(sorted(Capacities.loc[mpr, :].values))
            
        return Capacities_returned
        
    
    @classmethod
    def CAF_averageoverlanes(self, FD_multilane, base_capacity = 1952, only_use_later_percentage = False):
        """
        calculate the CAF. The 
        
        @input: FD_multilane
        
            FD_multilane[desireddensity] = (Q,V,K), Q[lane_id] is a list. 
        
        @input: base_capacity
        
            unit is veh/h. 
        
        ------------------------------------------------
        @Steps:
            
            - For each density, calcuate
        
        
        """
        #select
        somedensity = np.random.choice(list(FD_multilane.keys()))
        lane_ids = list(FD_multilane[somedensity][0].keys())

        if not isinstance(only_use_later_percentage, bool):
            #FD_multilane[somedensity][0] is Q, a dict, the keys are lane ids. 
            idx = int(len(FD_multilane[somedensity][0][lane_ids[0]])*(1-only_use_later_percentage))
        else:
            idx = 0
            
            
        #----------------------------------------
        QS = []
        VS = []
        KS = []
        for density in FD_multilane.keys():
            #Q[laneid] is a list. 
            Q,V,K = FD_multilane[density]
            qs_lanes = [np.mean(Q[laneid][idx:]) for laneid in Q.keys()]
            vs_lanes = [np.mean(V[laneid][idx:]) for laneid in V.keys()]
            ks_lanes = [np.mean(K[laneid][idx:]) for laneid in K.keys()]
            
            QS.append(np.mean(qs_lanes))
            VS.append(np.mean(vs_lanes))
            KS.append(np.mean(ks_lanes))
            
            
            pass
        #
        capacity = max(QS)
        idx = np.where(np.array(QS)==capacity)[0][0]
        
        
        return 1.0*capacity/base_capacity,KS[idx]
        

    @classmethod
    def CAF_by_minimal_of_lane_cap(self, FD_multilane, base_capacity = 1952, only_use_later_percentage = False):
        """
        calculate the CAF. The 
        
        @input: FD_multilane
        
            FD_multilane[desireddensity] = (Q,V,K), Q[lane_id] is a list. 
        
        @input: base_capacity
        
            unit is veh/h. 
        
        ------------------------------------------------
        @Steps:
            
            - For each density, calcuate
        
        
        """
        #select
        densities = sorted(FD_multilane.keys())
        somedensity = np.random.choice(list(FD_multilane.keys()))
        #
        lane_ids = list(FD_multilane[somedensity][0].keys())

        if not isinstance(only_use_later_percentage, bool):
            #FD_multilane[somedensity][0] is Q, a dict, the keys are lane ids. 
            idx = int(len(FD_multilane[somedensity][0][lane_ids[0]])*(1-only_use_later_percentage))
        else:
            idx = 0
            
            
        #----------------------------------------

        capacity_laneids = np.inf
        #
        for laneid in lane_ids:
            qs = [np.mean(FD_multilane[density][0][laneid][idx:]) for density in sorted(FD_multilane.keys())]
            vs = [np.mean(FD_multilane[density][1][laneid][idx:]) for density in sorted(FD_multilane.keys())]
            ks = [np.mean(FD_multilane[density][2][laneid][idx:]) for density in sorted(FD_multilane.keys())]
            #
            idx = np.where(np.array(qs)==max(qs))[0][0]
            #print(max(qs))
            #capacity_laneids = min(capacity_laneids, max(qs))
            capacity_laneids = min(capacity_laneids, min(FD_multilane[densities[idx]][0][laneid][idx:]))
            
            
        #
        return 1.0*capacity_laneids/base_capacity


    @classmethod
    def plot_FD_multilane_qsvs_distribution_ARCHIEVE(self, FD_multilane, ax = False, figsize = (5,3), alpha = .4, markersize = 10, color = False, marker = 's', only_use_later_percentage = False):
        """
        
        
        @input: FD_multilane

            FD_multilane[desireddensity] = (Q,V,K), Q[lane_id] is a list. 

                reload(CAF)
                #FD_multilanes[lanesnumber][desireddensity] = (Q,V,K), Q[lane_id] is a list. 
                FD_multilanes = pickle.load(open(dataspath + 'RES_FD_multilane.pickle', 'rb'))
            
                FD_multilane = FD_multilanes[2]
        
        @input: only_use_later_percentage
        
            a float within (0, 1)
            
            
        
        
        """
        #select
        somedensity = np.random.choice(list(FD_multilane.keys()))
        lane_ids = list(FD_multilane[somedensity][0].keys())
        colors = [np.random.uniform(size = (3,)) for i in lane_ids]
        #if isinstance(color,bool):
        #    color = np.random.uniform(size = (3,))
        #
        markers = np.random.choice([',', 'o', 'v', '^', '<', '>', '1', '2', '3', '4', '8', 's', 'p', '*', 'h', 'H', '+', 'x', 'D', 'd', '|', '_', 'P', 'X', ], len(lane_ids))
        
        #
        if isinstance(ax, bool):
            fig,ax = plt.subplots(figsize = figsize)#.add_subplot(projection='3d')

        if not isinstance(only_use_later_percentage, bool):
            #FD_multilane[somedensity][0] is Q, a dict, the keys are lane ids. 
            idx = int(len(FD_multilane[somedensity][0][lane_ids[0]])*(1-only_use_later_percentage))
        else:
            idx = 0
        #
        
        #
        for laneid,color,marker in zip(lane_ids, colors,markers):
            #
            legend_added = True
            for density in FD_multilane.keys():
                qs = FD_multilane[density][0][laneid][idx:]
                vs = np.array(FD_multilane[density][1][laneid][idx:])
                ks = FD_multilane[density][2][laneid][idx:]
                #
                if legend_added:
                #color = np.random.uniform(size = (3,))
                    #
                    #ax.plot(qs, 2*vs/1.609344, marker = marker, color = color, alpha = alpha, markersize = markersize, label = str(laneid))
                    ax.plot(qs, 2*vs, marker = marker, color = color, alpha = alpha, markersize = markersize, label = str(laneid))
                    #
                    legend_added = False
                else:
                    #ax.plot(qs, 2*vs/1.609344, marker = marker, color = color, alpha = alpha, markersize = markersize,)
                    ax.plot(qs, 2*vs, marker = marker, color = color, alpha = alpha, markersize = markersize,)
                 
            """
            qs = [np.mean(FD_multilane[density][0][laneid][idx:]) for density in FD_multilane.keys()]
            vs = np.array([np.mean(FD_multilane[density][1][laneid][idx:]) for density in FD_multilane.keys()])
            ks = [np.mean(FD_multilane[density][2][laneid][idx:]) for density in FD_multilane.keys()]
            #
            ax.plot(qs, 2*vs, marker = marker, color = color, alpha = alpha, markersize = markersize, label = str(laneid))
            """
            
            """
            if legend_added:
            #color = np.random.uniform(size = (3,))
                #
                ax.plot([np.mean(ks)], [np.mean(qs)], marker = marker, color = color, alpha = alpha, label = 'mpr = ' + str(mpr), markersize = markersize)
                #
                legend_added = False
            else:
                ax.plot([np.mean(ks)], [np.mean(qs)], marker = marker, color = color, alpha = alpha, markersize = markersize)
            
            """
        ax.set_ylabel('speed ( km/h )');ax.set_xlabel('Q (veh/h) ')
        #
        return ax


    @classmethod
    def plot_FD_multilane_qsvs_ARCHIEVE(self, FD_multilane, ax = False, figsize = (5,3), alpha = .4, markersize = 10, color = False, marker = 's', only_use_later_percentage = False):
        """
        
        
        @input: FD_multilane

            FD_multilane[desireddensity] = (Q,V,K), Q[lane_id] is a list. 

                reload(CAF)
                #FD_multilanes[lanesnumber][desireddensity] = (Q,V,K), Q[lane_id] is a list. 
                FD_multilanes = pickle.load(open(dataspath + 'RES_FD_multilane.pickle', 'rb'))
            
                FD_multilane = FD_multilanes[2]
        
        @input: only_use_later_percentage
        
            a float within (0, 1)
            
            
        
        
        """
        #select
        somedensity = np.random.choice(list(FD_multilane.keys()))
        lane_ids = list(FD_multilane[somedensity][0].keys())
        colors = [np.random.uniform(size = (3,)) for i in lane_ids]
        #if isinstance(color,bool):
        #    color = np.random.uniform(size = (3,))
        #
        markers = np.random.choice([',', 'o', 'v', '^', '<', '>', '1', '2', '3', '4', '8', 's', 'p', '*', 'h', 'H', '+', 'x', 'D', 'd', '|', '_', 'P', 'X', ], len(lane_ids))
        
        
        #
        if isinstance(ax, bool):
            fig,ax = plt.subplots(figsize = figsize)#.add_subplot(projection='3d')

        if not isinstance(only_use_later_percentage, bool):
            #FD_multilane[somedensity][0] is Q, a dict, the keys are lane ids. 
            idx = int(len(FD_multilane[somedensity][0][lane_ids[0]])*(1-only_use_later_percentage))
        else:
            idx = 0
        #
        
        #
        for laneid,color,marker in zip(lane_ids, colors,markers):
            

            qs = [np.mean(FD_multilane[density][0][laneid][idx:]) for density in FD_multilane.keys()]
            vs = np.array([np.mean(FD_multilane[density][1][laneid][idx:]) for density in FD_multilane.keys()])
            ks = [np.mean(FD_multilane[density][2][laneid][idx:]) for density in FD_multilane.keys()]
            #
            ax.plot(qs, 2*vs, marker = marker, color = color, alpha = alpha, markersize = markersize, label = str(laneid))
            #ax.plot(qs, 2*vs/1.609344, marker = marker, color = color, alpha = alpha, markersize = markersize, label = str(laneid))
            
            """
            if legend_added:
            #color = np.random.uniform(size = (3,))
                #
                ax.plot([np.mean(ks)], [np.mean(qs)], marker = marker, color = color, alpha = alpha, label = 'mpr = ' + str(mpr), markersize = markersize)
                #
                legend_added = False
            else:
                ax.plot([np.mean(ks)], [np.mean(qs)], marker = marker, color = color, alpha = alpha, markersize = markersize)
            
            """
        ax.set_ylabel('speed ( km/h )');ax.set_xlabel('Q (veh/h) ')
        #
        return ax


    @classmethod
    def plot_FD_multilane_qsvs(self, FD_multilane, ax = False, figsize = (5,3), alpha = .4, markersize = 10, color = False, marker = 's', only_use_later_percentage = False):
        """
        
        
        @input: FD_multilane

            FD_multilane[desireddensity] = (Q,V,K), Q[lane_id] is a list. 

                reload(CAF)
                #FD_multilanes[lanesnumber][desireddensity] = (Q,V,K), Q[lane_id] is a list. 
                FD_multilanes = pickle.load(open(dataspath + 'RES_FD_multilane.pickle', 'rb'))
            
                FD_multilane = FD_multilanes[2]
        
        @input: only_use_later_percentage
        
            a float within (0, 1)
            
            
        
        
        """
        #select
        somedensity = np.random.choice(list(FD_multilane.keys()))
        lane_ids = list(FD_multilane[somedensity][0].keys())
        colors = [np.random.uniform(size = (3,)) for i in lane_ids]
        #if isinstance(color,bool):
        #    color = np.random.uniform(size = (3,))
        #
        markers = np.random.choice([',', 'o', 'v', '^', '<', '>', '1', '2', '3', '4', '8', 's', 'p', '*', 'h', 'H', '+', 'x', 'D', 'd', '|', '_', 'P', 'X', ], len(lane_ids))
        
        
        #
        if isinstance(ax, bool):
            fig,ax = plt.subplots(figsize = figsize)#.add_subplot(projection='3d')

        if not isinstance(only_use_later_percentage, bool):
            #FD_multilane[somedensity][0] is Q, a dict, the keys are lane ids. 
            idx = int(len(FD_multilane[somedensity][0][lane_ids[0]])*(1-only_use_later_percentage))
        else:
            idx = 0
        #
        
        #
        for laneid,color,marker in zip(lane_ids, colors,markers):
            

            qs = [np.mean(FD_multilane[density][0][laneid][idx:]) for density in FD_multilane.keys()]
            vs = np.array([np.mean(FD_multilane[density][1][laneid][idx:]) for density in FD_multilane.keys()])
            ks = [np.mean(FD_multilane[density][2][laneid][idx:]) for density in FD_multilane.keys()]
            #
            ax.plot(qs, vs, marker = marker, color = color, alpha = alpha, markersize = markersize, label = str(laneid))
            
            """
            if legend_added:
            #color = np.random.uniform(size = (3,))
                #
                ax.plot([np.mean(ks)], [np.mean(qs)], marker = marker, color = color, alpha = alpha, label = 'mpr = ' + str(mpr), markersize = markersize)
                #
                legend_added = False
            else:
                ax.plot([np.mean(ks)], [np.mean(qs)], marker = marker, color = color, alpha = alpha, markersize = markersize)
            
            """
        ax.set_ylabel('speed ( km/h )');ax.set_xlabel('Q (veh/h) ')
        #
        return ax


    @classmethod
    def plot_FD_multilane_distribution(self, FD_multilane, ax = False, figsize = (5,3), alpha = .4, markersize = 10, color = False, marker = 's', only_use_later_percentage = False):
        """
        
        ---------------------------------------
        @input: FD_multilane

            FD_multilane[desireddensity] = (Q,V,K), Q[lane_id] is a list. 

                reload(CAF)
                #FD_multilanes[lanesnumber][desireddensity] = (Q,V,K), Q[lane_id] is a list. 
                FD_multilanes = pickle.load(open(dataspath + 'RES_FD_multilane.pickle', 'rb'))
            
                FD_multilane = FD_multilanes[2]
        
        @input: only_use_later_percentage
        
            a float within (0, 1)
            
            
        
        
        """
        #select
        somedensity = np.random.choice(list(FD_multilane.keys()))
        lane_ids = list(FD_multilane[somedensity][0].keys())
        #colors = [np.random.uniform(size = (3,)) for i in lane_ids]
        colors = ['C'+str(idx) for idx in range(len(lane_ids))]
        #if isinstance(color,bool):
        #    color = np.random.uniform(size = (3,))
        #
        markers = np.random.choice([',', 'o', 'v', '^', '<', '>', '1', '2', '3', '4', '8', 's', 'p', '*', 'h', 'H', '+', 'x', 'D', 'd', '|', '_', 'P', 'X', ], len(lane_ids))
        
        #
        if isinstance(ax, bool):
            fig,ax = plt.subplots(figsize = figsize)#.add_subplot(projection='3d')

        if not isinstance(only_use_later_percentage, bool):
            #FD_multilane[somedensity][0] is Q, a dict, the keys are lane ids. 
            idx = int(len(FD_multilane[somedensity][0][lane_ids[0]])*(1-only_use_later_percentage))
        else:
            idx = 0
        #
        
        #
        for laneid,color,marker in zip(lane_ids, colors,markers):
            label_added = True
            for density in FD_multilane.keys():
                qs = FD_multilane[density][0][laneid][idx:]
                vs = FD_multilane[density][1][laneid][idx:]
                ks = FD_multilane[density][2][laneid][idx:]
                #
                if label_added:
                    ax.plot(ks, qs, marker = marker, color = color, alpha = alpha, markersize = markersize, label = str(laneid))
                    label_added = False
                else:
                    
                    ax.plot(ks, qs, marker = marker, color = color, alpha = alpha, markersize = markersize)
                
                
                pass
            
            
            """
            qs = [np.mean(FD_multilane[density][0][laneid][idx:]) for density in FD_multilane.keys()]
            vs = [np.mean(FD_multilane[density][1][laneid][idx:]) for density in FD_multilane.keys()]
            ks = [np.mean(FD_multilane[density][2][laneid][idx:]) for density in FD_multilane.keys()]
            #
            ax.plot(ks, qs, marker = marker, color = color, alpha = alpha, markersize = markersize, label = str(laneid))
            """
            
            """
            if legend_added:
            #color = np.random.uniform(size = (3,))
                #
                ax.plot([np.mean(ks)], [np.mean(qs)], marker = marker, color = color, alpha = alpha, label = 'mpr = ' + str(mpr), markersize = markersize)
                #
                legend_added = False
            else:
                ax.plot([np.mean(ks)], [np.mean(qs)], marker = marker, color = color, alpha = alpha, markersize = markersize)
            
            """
        return ax


    @classmethod
    def plot_Q_timeseries_laneaverage(self, FD_multilane, ax = False, figsize = (5,3), alpha = .4, markersize = 10, color = False, marker = 's', only_use_later_percentage = False, exclude_lane = False, label = ' '):
        """
        
        
        @input: FD_multilane

            FD_multilane[desireddensity] = (Q,V,K), Q[lane_id] is a list. 

                reload(CAF)
                #FD_multilanes[lanesnumber][desireddensity] = (Q,V,K), Q[lane_id] is a list. 
                FD_multilanes = pickle.load(open(dataspath + 'RES_FD_multilane.pickle', 'rb'))
            
                FD_multilane = FD_multilanes[2]
        
        @input: only_use_later_percentage
        
            a float within (0, 1)
            
            
        
        
        """
        
        #
        somedensity = np.random.choice(list(FD_multilane.keys()))
        lane_ids = list(FD_multilane[somedensity][0].keys())
        #colors = [np.random.uniform(size = (3,)) for i in lane_ids]
        colors = ['C'+str(idx) for idx in range(len(lane_ids))]
        #if isinstance(color,bool):
        #    color = np.random.uniform(size = (3,))
        #
        markers = np.random.choice([',', 'o', 'v', '^', '<', '>', '1', '2', '3', '4', '8', 's', 'p', '*', 'h', 'H', '+', 'x', 'D', 'd', '|', '_', 'P', 'X', ], len(lane_ids))
        
        #
        if isinstance(ax, bool):
            fig,ax = plt.subplots(figsize = figsize)#.add_subplot(projection='3d')

        if not isinstance(only_use_later_percentage, bool):
            #FD_multilane[somedensity][0] is Q, a dict, the keys are lane ids. 
            idx = int(len(FD_multilane[somedensity][0][lane_ids[0]])*(1-only_use_later_percentage))
        else:
            idx = 0
        #
        VS = []
        KS = []
        for density in sorted(FD_multilane.keys()):
            #
            vs = 0*np.array(FD_multilane[density][1][lane_ids[0]][idx:])
            ks = 0*np.array(FD_multilane[density][2][lane_ids[0]][idx:])
            for laneid,_,marker in zip(lane_ids, colors,markers):
                if laneid==exclude_lane:continue
                vs = vs + np.array(FD_multilane[density][1][laneid][idx:])
                ks = ks + np.array(FD_multilane[density][2][laneid][idx:])
            #ks length is [idx:]
            qs  = ks*vs/len(lane_ids)//len(lane_ids)
            #
            #ax.plot(range(len(qs)), qs, marker = marker, color = color, alpha = alpha, markersize = markersize, label = str(laneid))
            #ax.plot([density]*len(qs), qs, marker = marker, color = color, alpha = alpha, markersize = markersize, label = str(laneid))
            ax.plot([density]*len(qs), qs, marker = marker, color = color, alpha = alpha, markersize = markersize, )
            #
            VS.append(np.mean(vs)/len(lane_ids))
            KS.append(np.mean(ks)/len(lane_ids))
            #
        ax.plot(sorted(FD_multilane.keys()), np.array(VS)*np.array(KS),label = label, linewidth = 4)
        
        return ax
        
        
        
        
        #
        for laneid,color,marker in zip(lane_ids, colors,markers):
            """
            qs = [np.mean(FD_multilane[density][0][laneid][idx:]) for density in FD_multilane.keys()]
            vs = [np.mean(FD_multilane[density][1][laneid][idx:]) for density in FD_multilane.keys()]
            ks = [np.mean(FD_multilane[density][2][laneid][idx:]) for density in FD_multilane.keys()]
            """
            for density in FD_multilane.keys():
                qs  =FD_multilane[density][0][laneid][idx:]
                #
                ax.plot(range(len(qs)), qs, marker = marker, color = color, alpha = alpha, markersize = markersize, label = str(laneid))
            
            """
            if legend_added:
            #color = np.random.uniform(size = (3,))
                #
                ax.plot([np.mean(ks)], [np.mean(qs)], marker = marker, color = color, alpha = alpha, label = 'mpr = ' + str(mpr), markersize = markersize)
                #
                legend_added = False
            else:
                ax.plot([np.mean(ks)], [np.mean(qs)], marker = marker, color = color, alpha = alpha, markersize = markersize)
            
            """
        return ax
        
        pass
    


    @classmethod
    def plot_Q_timeseries(self, FD_multilane, ax = False, figsize = (5,3), alpha = .4, markersize = 10, color = False, marker = 's', only_use_later_percentage = False):
        """
        
        
        @input: FD_multilane

            FD_multilane[desireddensity] = (Q,V,K), Q[lane_id] is a list. 

                reload(CAF)
                #FD_multilanes[lanesnumber][desireddensity] = (Q,V,K), Q[lane_id] is a list. 
                FD_multilanes = pickle.load(open(dataspath + 'RES_FD_multilane.pickle', 'rb'))
            
                FD_multilane = FD_multilanes[2]
        
        @input: only_use_later_percentage
        
            a float within (0, 1)
            
            
        
        
        """
        
        #
        somedensity = np.random.choice(list(FD_multilane.keys()))
        lane_ids = list(FD_multilane[somedensity][0].keys())
        #colors = [np.random.uniform(size = (3,)) for i in lane_ids]
        colors = ['C'+str(idx) for idx in range(len(lane_ids))]
        #if isinstance(color,bool):
        #    color = np.random.uniform(size = (3,))
        #
        markers = np.random.choice([',', 'o', 'v', '^', '<', '>', '1', '2', '3', '4', '8', 's', 'p', '*', 'h', 'H', '+', 'x', 'D', 'd', '|', '_', 'P', 'X', ], len(lane_ids))
        
        #
        if isinstance(ax, bool):
            fig,ax = plt.subplots(figsize = figsize)#.add_subplot(projection='3d')

        if not isinstance(only_use_later_percentage, bool):
            #FD_multilane[somedensity][0] is Q, a dict, the keys are lane ids. 
            idx = int(len(FD_multilane[somedensity][0][lane_ids[0]])*(1-only_use_later_percentage))
        else:
            idx = 0
        #
        
        #
        for laneid,color,marker in zip(lane_ids, colors,markers):
            """
            qs = [np.mean(FD_multilane[density][0][laneid][idx:]) for density in FD_multilane.keys()]
            vs = [np.mean(FD_multilane[density][1][laneid][idx:]) for density in FD_multilane.keys()]
            ks = [np.mean(FD_multilane[density][2][laneid][idx:]) for density in FD_multilane.keys()]
            """
            for density in FD_multilane.keys():
                qs  =FD_multilane[density][0][laneid][idx:]
                #
                ax.plot(range(len(qs)), qs, marker = marker, color = color, alpha = alpha, markersize = markersize, label = str(laneid))
            
            """
            if legend_added:
            #color = np.random.uniform(size = (3,))
                #
                ax.plot([np.mean(ks)], [np.mean(qs)], marker = marker, color = color, alpha = alpha, label = 'mpr = ' + str(mpr), markersize = markersize)
                #
                legend_added = False
            else:
                ax.plot([np.mean(ks)], [np.mean(qs)], marker = marker, color = color, alpha = alpha, markersize = markersize)
            
            """
        return ax
        
        pass
    

    @classmethod
    def plot_FD_multilane_lanes_total(self, FD_multilane, ax = False, figsize = (5,3), alpha = .4, markersize = 10, color = False, marker = 's', only_use_later_percentage = False , label = ' ', exclude_lane = False):
        """
        @input: exclude_lane
        
            certain lane is dedicated lane, whose density may be fixed. 
            
            Thus to calculate the FD, this lane is excluded. 
            
        
        @input: FD_multilane

            FD_multilane[desireddensity] = (Q,V,K), Q[lane_id] is a list. 

                reload(CAF)
                #FD_multilanes[lanesnumber][desireddensity] = (Q,V,K), Q[lane_id] is a list. 
                FD_multilanes = pickle.load(open(dataspath + 'RES_FD_multilane.pickle', 'rb'))
            
                FD_multilane = FD_multilanes[2]
        
        @input: only_use_later_percentage
        
            a float within (0, 1)
            
            
        
        
        """
        #select
        somedensity = np.random.choice(list(FD_multilane.keys()))
        lane_ids = list(FD_multilane[somedensity][0].keys())
        #colors = [np.random.uniform(size = (3,)) for i in lane_ids]
        colors = ['C'+str(idx) for idx in range(len(lane_ids))]
        #if isinstance(color,bool):
        #    color = np.random.uniform(size = (3,))
        #
        markers = np.random.choice([',', 'o', 'v', '^', '<', '>', '1', '2', '3', '4', '8', 's', 'p', '*', 'h', 'H', '+', 'x', 'D', 'd', '|', '_', 'P', 'X', ], len(lane_ids))
        
        #
        if isinstance(ax, bool):
            fig,ax = plt.subplots(figsize = figsize)#.add_subplot(projection='3d')
            

        if not isinstance(only_use_later_percentage, bool):
            #FD_multilane[somedensity][0] is Q, a dict, the keys are lane ids. 
            idx = int(len(FD_multilane[somedensity][0][lane_ids[0]])*(1-only_use_later_percentage))
        else:
            idx = 0
        #
        QS = []
        VS = []
        KS = []
        #
        densities = []
        for density in FD_multilane.keys():
            #
            vs = []
            ks = []
            qs = []
            for laneid,color,marker in zip(lane_ids, colors,markers):
                if laneid==exclude_lane:continue
                #print(np.mean(FD_multilane[density][1][laneid][idx:]))
                vs.append(np.mean(FD_multilane[density][1][laneid][idx:]))
                ks.append(np.mean(FD_multilane[density][2][laneid][idx:]))
                #
                #qs.append(np.mean(FD_multilane[density][0][laneid][idx:]))
                qs.append(vs[-1]*ks[-1])
            """
            qs = [np.mean(FD_multilane[density][0][laneid][idx:]) for laneid,color,marker in zip(lane_ids, colors,markers)]
            vs = [np.mean(FD_multilane[density][1][laneid][idx:]) for laneid,color,marker in zip(lane_ids, colors,markers)]
            ks = [np.mean(FD_multilane[density][2][laneid][idx:]) for laneid,color,marker in zip(lane_ids, colors,markers)]
            """
            
            #QS.append(np.mean(qs))
            VS.append(np.mean(vs))
            KS.append(np.mean(ks))
            QS.append(sum(qs))
            densities.append(density)
        #
        #ax.plot(QS,  VS, alpha = alpha, markersize = markersize, label = label)
        ax.plot(densities, np.array(QS)/4.0,  alpha = alpha, markersize = markersize, label = label)
        ax.set_xlabel('K (veh/km)');ax.set_ylabel('Q (veh/h)');
        
        return ax



    @classmethod
    def plot_FD_multilane_averageoverlane(self, FD_multilane, ax = False, figsize = (5,3), alpha = .4, markersize = 10, color = False, marker = 's', only_use_later_percentage = False , label = ' ', exclude_lane = False):
        """
        @input: exclude_lane
        
            certain lane is dedicated lane, whose density may be fixed. 
            
            Thus to calculate the FD, this lane is excluded. 
            
        
        @input: FD_multilane

            FD_multilane[desireddensity] = (Q,V,K), Q[lane_id] is a list. 

                reload(CAF)
                #FD_multilanes[lanesnumber][desireddensity] = (Q,V,K), Q[lane_id] is a list. 
                FD_multilanes = pickle.load(open(dataspath + 'RES_FD_multilane.pickle', 'rb'))
            
                FD_multilane = FD_multilanes[2]
        
        @input: only_use_later_percentage
        
            a float within (0, 1)
            
            
        
        
        """
        #select
        somedensity = np.random.choice(list(FD_multilane.keys()))
        lane_ids = list(FD_multilane[somedensity][0].keys())
        #colors = [np.random.uniform(size = (3,)) for i in lane_ids]
        colors = ['C'+str(idx) for idx in range(len(lane_ids))]
        #if isinstance(color,bool):
        #    color = np.random.uniform(size = (3,))
        #
        markers = np.random.choice([',', 'o', 'v', '^', '<', '>', '1', '2', '3', '4', '8', 's', 'p', '*', 'h', 'H', '+', 'x', 'D', 'd', '|', '_', 'P', 'X', ], len(lane_ids))
        
        #
        if isinstance(ax, bool):
            fig,ax = plt.subplots(figsize = figsize)#.add_subplot(projection='3d')
            

        if not isinstance(only_use_later_percentage, bool):
            #FD_multilane[somedensity][0] is Q, a dict, the keys are lane ids. 
            idx = int(len(FD_multilane[somedensity][0][lane_ids[0]])*(1-only_use_later_percentage))
        else:
            idx = 0
        #
        QS = []
        VS = []
        KS = []
        densities = []
        for density in FD_multilane.keys():
            #
            vs = []
            ks = []
            for laneid,color,marker in zip(lane_ids, colors,markers):
                if laneid==exclude_lane:continue
                vs.extend(FD_multilane[density][1][laneid][idx:])
                ks.extend(FD_multilane[density][2][laneid][idx:])
            """
            qs = [np.mean(FD_multilane[density][0][laneid][idx:]) for laneid,color,marker in zip(lane_ids, colors,markers)]
            vs = [np.mean(FD_multilane[density][1][laneid][idx:]) for laneid,color,marker in zip(lane_ids, colors,markers)]
            ks = [np.mean(FD_multilane[density][2][laneid][idx:]) for laneid,color,marker in zip(lane_ids, colors,markers)]
            """
            
            #QS.append(np.mean(qs))
            VS.append(np.mean(vs))
            KS.append(np.mean(ks))
            QS.append(np.mean(ks)*np.mean(vs))
            densities.append(density)
        #
        #ax.plot(QS,  VS, alpha = alpha, markersize = markersize, label = label)
        ax.plot(densities, QS,  alpha = alpha, markersize = markersize, label = label)
        ax.set_xlabel('K (veh/km)');ax.set_ylabel('Q (veh/h)');
        
        return ax
        
        
        for laneid,color,marker in zip(lane_ids, colors,markers):
            
            qs = [np.mean(FD_multilane[density][0][laneid][idx:]) for density in FD_multilane.keys()]
            vs = [np.mean(FD_multilane[density][1][laneid][idx:]) for density in FD_multilane.keys()]
            ks = [np.mean(FD_multilane[density][2][laneid][idx:]) for density in FD_multilane.keys()]
            #
            ax.plot(ks, qs, marker = marker, color = color, alpha = alpha, markersize = markersize, label = str(laneid))
            
            """
            if legend_added:
            #color = np.random.uniform(size = (3,))
                #
                ax.plot([np.mean(ks)], [np.mean(qs)], marker = marker, color = color, alpha = alpha, label = 'mpr = ' + str(mpr), markersize = markersize)
                #
                legend_added = False
            else:
                ax.plot([np.mean(ks)], [np.mean(qs)], marker = marker, color = color, alpha = alpha, markersize = markersize)
            
            """
        return ax



    @classmethod
    def plot_FD_multilane(self, FD_multilane, ax = False, figsize = (5,3), alpha = .4, markersize = 10, color = False, marker = 's', only_use_later_percentage = False):
        """
        
        
        @input: FD_multilane

            FD_multilane[desireddensity] = (Q,V,K), Q[lane_id] is a list. 

                reload(CAF)
                #FD_multilanes[lanesnumber][desireddensity] = (Q,V,K), Q[lane_id] is a list. 
                FD_multilanes = pickle.load(open(dataspath + 'RES_FD_multilane.pickle', 'rb'))
            
                FD_multilane = FD_multilanes[2]
        
        @input: only_use_later_percentage
        
            a float within (0, 1)
            
            
        
        
        """
        #select
        somedensity = np.random.choice(list(FD_multilane.keys()))
        lane_ids = list(FD_multilane[somedensity][0].keys())
        #colors = [np.random.uniform(size = (3,)) for i in lane_ids]
        colors = ['C'+str(idx) for idx in range(len(lane_ids))]
        #if isinstance(color,bool):
        #    color = np.random.uniform(size = (3,))
        #
        markers = np.random.choice([',', 'o', 'v', '^', '<', '>', '1', '2', '3', '4', '8', 's', 'p', '*', 'h', 'H', '+', 'x', 'D', 'd', '|', '_', 'P', 'X', ], len(lane_ids))
        
        #
        if isinstance(ax, bool):
            fig,ax = plt.subplots(figsize = figsize)#.add_subplot(projection='3d')

        if not isinstance(only_use_later_percentage, bool):
            #FD_multilaneplot_FD_multilane_averageoverlane[somedensity][0] is Q, a dict, the keys are lane ids. 
            idx = int(len(FD_multilane[somedensity][0][lane_ids[0]])*(1-only_use_later_percentage))
        else:
            idx = 0
        #
        
        #
        for laneid,color,marker in zip(lane_ids, colors,markers):
            
            qs = [np.mean(FD_multilane[density][0][laneid][idx:]) for density in FD_multilane.keys()]
            vs = [np.mean(FD_multilane[density][1][laneid][idx:]) for density in FD_multilane.keys()]
            ks = [np.mean(FD_multilane[density][2][laneid][idx:]) for density in FD_multilane.keys()]
            #
            ax.plot(ks, qs, marker = marker, color = color, alpha = alpha, markersize = markersize, label = str(laneid))
            
            """
            if legend_added:
            #color = np.random.uniform(size = (3,))
                #
                ax.plot([np.mean(ks)], [np.mean(qs)], marker = marker, color = color, alpha = alpha, label = 'mpr = ' + str(mpr), markersize = markersize)
                #
                legend_added = False
            else:
                ax.plot([np.mean(ks)], [np.mean(qs)], marker = marker, color = color, alpha = alpha, markersize = markersize)
            
            """
        return ax


    @classmethod
    def plot_FD_singlelane_distribution(self, FD_singlelane, ax = False, figsize = (5,3), alpha = .4, markersize = 10, color = False, marker = 's', only_use_later_percentage = False):
        """
        
        
        @input: FD_singlelane
            
            FD_singlelane[]
        
            
            reload(CAF)
            #FD_singlelane[desireddensity] = (Q,V,K), Q V K are all list. 
            FD_singlelane = pickle.load(open(dataspath + 'RES_FD_singlelane.pickle', 'rb'))
        
        
        
        @input: only_use_later_percentage
        
            a float within (0, 1)
            
            
        
        
        """
        #
        if isinstance(ax, bool):
            fig,ax = plt.subplots(figsize = figsize)#.add_subplot(projection='3d')
        #
        if isinstance(color, bool):
            color = np.random.uniform(size = (3,))
        for desired_density in FD_singlelane.keys():
            #qs = [q1,q2,...qn]
            if isinstance(only_use_later_percentage, bool):
                qs,vs,ks = FD_singlelane[desired_density]
            else:
                qs0,vs0,ks0 = FD_singlelane[desired_density]
                #
                idx = int(len(qs0)*(1-only_use_later_percentage))
                #
                qs = qs0[idx:]
                vs = vs0[idx:]
                ks = ks0[idx:]
                
            ax.plot(ks, qs, marker = marker, color = color, alpha = alpha, markersize = markersize)
            
            #ax.plot([np.mean(ks)], [np.mean(qs)], marker = marker, color = color, alpha = alpha, markersize = markersize)
            
            """
            if legend_added:
            #color = np.random.uniform(size = (3,))
                #
                ax.plot([np.mean(ks)], [np.mean(qs)], marker = marker, color = color, alpha = alpha, label = 'mpr = ' + str(mpr), markersize = markersize)
                #
                legend_added = False
            else:
                ax.plot([np.mean(ks)], [np.mean(qs)], marker = marker, color = color, alpha = alpha, markersize = markersize)
            
            """
            
            

        return ax


    @classmethod
    def plot_FD_singlelane_QV(self, FD_singlelane, ax = False, figsize = (5,3), alpha = .4, markersize = 10, color = False, marker = 's', only_use_later_percentage = False):
        """
        
        
        @input: FD_singlelane
            
            FD_singlelane[]
        
            
            reload(CAF)
            #FD_singlelane[desireddensity] = (Q,V,K), Q V K are all list. 
            FD_singlelane = pickle.load(open(dataspath + 'RES_FD_singlelane.pickle', 'rb'))
        
        
        
        @input: only_use_later_percentage
        
            a float within (0, 1)
            
            
        
        
        """
        #
        if isinstance(ax, bool):
            fig,ax = plt.subplots(figsize = figsize)#.add_subplot(projection='3d')
        #
        if isinstance(color, bool):
            color = np.random.uniform(size = (3,))
        for desired_density in FD_singlelane.keys():
            #qs = [q1,q2,...qn]
            if isinstance(only_use_later_percentage, bool):
                qs,vs,ks = FD_singlelane[desired_density]
            else:
                qs0,vs0,ks0 = FD_singlelane[desired_density]
                #
                idx = int(len(qs0)*(1-only_use_later_percentage))
                #
                qs = qs0[idx:]
                vs = vs0[idx:]
                ks = ks0[idx:]
                
            
            ax.plot( [np.mean(qs)], [np.mean(vs)],marker = marker, color = color, alpha = alpha, markersize = markersize)
            
            """
            if legend_added:
            #color = np.random.uniform(size = (3,))
                #
                ax.plot([np.mean(ks)], [np.mean(qs)], marker = marker, color = color, alpha = alpha, label = 'mpr = ' + str(mpr), markersize = markersize)
                #
                legend_added = False
            else:
                ax.plot([np.mean(ks)], [np.mean(qs)], marker = marker, color = color, alpha = alpha, markersize = markersize)
            
            """
            
            

        return ax

    @classmethod
    def plot_FD_singlelane(self, FD_singlelane, ax = False, figsize = (5,3), alpha = .4, markersize = 10, color = False, marker = 's', only_use_later_percentage = False):
        """
        
        
        @input: FD_singlelane
            
            FD_singlelane[]
        
            
            reload(CAF)
            #FD_singlelane[desireddensity] = (Q,V,K), Q V K are all list. 
            FD_singlelane = pickle.load(open(dataspath + 'RES_FD_singlelane.pickle', 'rb'))
        
        
        
        @input: only_use_later_percentage
        
            a float within (0, 1)
            
            
        
        
        """
        #
        if isinstance(ax, bool):
            fig,ax = plt.subplots(figsize = figsize)#.add_subplot(projection='3d')
        #
        if isinstance(color, bool):
            color = np.random.uniform(size = (3,))
        for desired_density in FD_singlelane.keys():
            #qs = [q1,q2,...qn]
            if isinstance(only_use_later_percentage, bool):
                qs,vs,ks = FD_singlelane[desired_density]
            else:
                qs0,vs0,ks0 = FD_singlelane[desired_density]
                #
                idx = int(len(qs0)*(1-only_use_later_percentage))
                #
                qs = qs0[idx:]
                vs = vs0[idx:]
                ks = ks0[idx:]
                
            
            ax.plot([np.mean(ks)], [np.mean(qs)], marker = marker, color = color, alpha = alpha, markersize = markersize)
            
            """
            if legend_added:
            #color = np.random.uniform(size = (3,))
                #
                ax.plot([np.mean(ks)], [np.mean(qs)], marker = marker, color = color, alpha = alpha, label = 'mpr = ' + str(mpr), markersize = markersize)
                #
                legend_added = False
            else:
                ax.plot([np.mean(ks)], [np.mean(qs)], marker = marker, color = color, alpha = alpha, markersize = markersize)
            
            """
            
            

        return ax

    
    @classmethod
    def plot_capacity_lanesnumber_mpr_askey(self, capacity, ax = False, figsize = (5,3), alpha = .4, markersize = 10, color = False):
        """
        
        @input: capacity
        
            capacity[lanesnumber][mpr] = float, the capacity, unit is veh/h. 
        
        @
        
        """
        #
        if isinstance(ax, bool):
            fig,ax = plt.subplots(figsize = figsize)#.add_subplot(projection='3d')
            
            #ax = plt.figure().add_subplot(projection='3d')
            #ax.set_xlabel('t');ax.set_ylabel('x');ax.set_zlabel('speed'); 
            #ax.grid();
            #ax = host_subplot(111)
        
        #
        for ln in capacity.keys():
            mprs = sorted(capacity[ln].keys())
            CAPs = [capacity[ln][mpr] for mpr in mprs]
            ax.plot(mprs, CAPs, label = 'lanes number ' + str(ln))
            
            pass
        ax.set_xlabel('MPR (*100%)');ax.set_ylabel('capacity (veh/h)');
        ax.grid('on')
        ax.legend()
        
        return ax
        pass
    

    
    @classmethod
    def plot_FDs_given_mprs_results_given_lanes_number_averageoverlane_changemarker(self, FD_mprs_given_lanesnumber, ax = False, figsize = (5,3), alpha = .4, markersize = 10, color = False):
        """
        Note that this method just change the marker, not the coloer. 
        
        If want to change the color, using :
        
            - self.plot_FDs_given_mprs_results_given_lanes_number_averageoverlane_changecolor()
        ---------------------------------------------------------
        @input: FD_mprs_given_lanesnumber
        
            FD_mprs_given_lanesnumber[mpr][desired_density] = (Q,K,V)
            
            Q is a dict, Q[laneid] = [q1,q2,...qn], eqch qi is a float. 
        
            It is obtained via: 
                #FD_mprs[lanesnumber][mpr][desired_density] = (Q,K,V)
                #Q is a dict, Q[laneid] = [q1,q2,...qn], eqch qi is a float. 
                FD_mprs = pickle.load(open(dataspath + 'RES_FD_mprs.pickle', 'rb'))
            
            and then FD_mprs_given_lanesnumber = FD_mprs[lanesnumber]
            
        

        
        
        """
        #
        if isinstance(color, bool):
            color = np.random.uniform(size = (3,))
            #marker = np.random.choice(['.', ',', 'o', 'v', '^', '<', '>', '1', '2', '3', '4', '8', 's', 'p', '*', 'h', 'H', '+', 'x', 'D', 'd', '|', '_', 'P', 'X', 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,])
        """
        if isinstance(marker, bool):
            marker = np.random.choice(['.', ',', 'o', 'v', '^', '<', '>', '1', '2', '3', '4', '8', 's', 'p', '*', 'h', 'H', '+', 'x', 'D', 'd', '|', '_', 'P', 'X', 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,])
        """
        #
        #
        if isinstance(ax, bool):
            fig,ax = plt.subplots(figsize = figsize)#.add_subplot(projection='3d')
            
            #ax = plt.figure().add_subplot(projection='3d')
            #ax.set_xlabel('t');ax.set_ylabel('x');ax.set_zlabel('speed'); 
            #ax.grid();
            #ax = host_subplot(111)
        #
        
        
        for mpr in FD_mprs_given_lanesnumber.keys():
            #
            legend_added = True
            #
            marker = np.random.choice(['.', ',', 'o', 'v', '^', '<', '>', '1', '2', '3', '4', '8', 's', 'p', '*', 'h', 'H', '+', 'x', 'D', 'd', '|', '_', 'P', 'X'])
            #
            for desired_density in FD_mprs_given_lanesnumber[mpr].keys():
                #Q[laneid] = [q1,q2,...qn]
                Q,K,V = FD_mprs_given_lanesnumber[mpr][desired_density]
                #
                
                ks = [np.mean(K[laneid]) for laneid in sorted(Q.keys())]
                qs = [np.mean(Q[laneid]) for laneid in sorted(Q.keys())]

                if legend_added:
                #color = np.random.uniform(size = (3,))
                    #
                    ax.plot([np.mean(ks)], [np.mean(qs)], marker = marker, color = color, alpha = alpha, label = 'mpr = ' + str(mpr), markersize = markersize)
                    #
                    legend_added = False
                else:
                    ax.plot([np.mean(ks)], [np.mean(qs)], marker = marker, color = color, alpha = alpha, markersize = markersize)
                    
                    
                    
                    #ax.plot([np.mean(K[laneid])], [np.mean(Q[laneid])],'.', alpha = alpha)
                    
                    """
                    if legend_added:
                    #color = np.random.uniform(size = (3,))
                        #
                        ax.plot([np.mean(K[laneid])], [np.mean(Q[laneid])],'.', color = color, alpha = alpha, label = label)
                        #
                        legend_added = False
                    else:
                        ax.plot([np.mean(K[laneid])], [np.mean(Q[laneid])],'.', color = color, alpha = alpha)
                    """
                
            
            #
        return ax
    
    
    @classmethod
    def plot_FDs_given_mprs_results_given_lanes_number(self, FD_mprs_given_lanesnumber, ax = False, figsize = (5,3), alpha = .4, markersize = 10):
        """
        
        
        @input: FD_mprs_given_lanesnumber
        
            FD_mprs_given_lanesnumber[mpr][desired_density] = (Q,K,V)
            
            Q is a dict, Q[laneid] = [q1,q2,...qn], eqch qi is a float. 
        
            It is obtained via: 
                #FD_mprs[lanesnumber][mpr][desired_density] = (Q,K,V)
                #Q is a dict, Q[laneid] = [q1,q2,...qn], eqch qi is a float. 
                FD_mprs = pickle.load(open(dataspath + 'RES_FD_mprs.pickle', 'rb'))
            
            and then FD_mprs_given_lanesnumber = FD_mprs[lanesnumber]
            
        

        
        
        """
        if isinstance(ax, bool):
            fig,ax = plt.subplots(figsize = figsize)#.add_subplot(projection='3d')
            
            #ax = plt.figure().add_subplot(projection='3d')
            #ax.set_xlabel('t');ax.set_ylabel('x');ax.set_zlabel('speed'); 
            #ax.grid();
            #ax = host_subplot(111)
        #
        
        
        for mpr in FD_mprs_given_lanesnumber.keys():
            #
            legend_added = True
            color = np.random.uniform(size = (3,))
            #
            for desired_density in FD_mprs_given_lanesnumber[mpr].keys():
                #Q[laneid] = [q1,q2,...qn]
                Q,K,V = FD_mprs_given_lanesnumber[mpr][desired_density]
                #
                for laneid in Q.keys():
                    #
                    if legend_added:
                    #color = np.random.uniform(size = (3,))
                        #
                        ax.plot([np.mean(K[laneid])], [np.mean(Q[laneid])],'^-', color = color, alpha = alpha, label = 'mpr = ' + str(mpr), markersize = markersize)
                        #
                        legend_added = False
                    else:
                        ax.plot([np.mean(K[laneid])], [np.mean(Q[laneid])],'.', color = color, alpha = alpha,markersize = markersize)
                    
                    
                    
                    #ax.plot([np.mean(K[laneid])], [np.mean(Q[laneid])],'.', alpha = alpha)
                    
                    """
                    if legend_added:
                    #color = np.random.uniform(size = (3,))
                        #
                        ax.plot([np.mean(K[laneid])], [np.mean(Q[laneid])],'.', color = color, alpha = alpha, label = label)
                        #
                        legend_added = False
                    else:
                        ax.plot([np.mean(K[laneid])], [np.mean(Q[laneid])],'.', color = color, alpha = alpha)
                    """
                
            
            #
        return ax
        




    
#####################################################################################
##################################################################################
#####################################################################################
##################################################################################
#####################################################################################
##################################################################################    
#####################################################################################
##################################################################################
import seaborn as sns
import matplotlib.collections as mcoll
import matplotlib.ticker as ticker



def Split_highD(dataframe):
    '''
        split the 'highD' into 'forward-direction' and 'reverse-direction'
    '''
    #----------------------------- split direction
    data = dataframe
    vids = data.id.unique().tolist()
    group = data.groupby('id')

    vids_forward = [id for id in vids if group.get_group(id).x.values[0] < group.get_group(id).x.values[-1]]
    vids_reverse = [id for id in vids if id not in vids_forward]

    data['direction'] = data['id'].apply(lambda x: 1 if x in vids_forward else -1)
    
    #----------------------------- split dataframes
    data_forward = data.iloc[data[data['direction'] == 1].index]
    data_reverse = data.iloc[data[data['direction'] == -1].index]
    
    #----------------------------- extract useful data
    sample_forward = data_forward[['frame', 'id', 'x', 'y', 'laneId', 'height']]
    sample_reverse = data_reverse[['frame', 'id', 'x', 'y', 'laneId', 'height']]
    
    #----------------------------- rename the index
    sample_forward.index = [str(i) for i in range(sample_forward.shape[0])]
    sample_reverse.index = [str(i) for i in range(sample_reverse.shape[0])]
    
    return sample_forward, sample_reverse



def Split_HighD_Dataset(highD):
    '''
        Split the dataframe with two direction
    '''
    #-------------------- the forward-direction
    forward = highD[(highD['laneId']==6) | (highD['laneId']==7) | (highD['laneId']==8)]
    forward = forward[['frame', 'id', 'x', 'y', 'laneId']]
    
    #-------------------- the reverse-direction
    reverse = highD[(highD['laneId']==2) | (highD['laneId']==3) | (highD['laneId']==4)]
    reverse = reverse[['frame', 'id', 'x', 'y', 'laneId']]
    
    return forward, reverse



def Get_Lane_Boundary(dataframe):
    '''
        Get Lane Boundary
    '''
    laneBoundary = []
    for lane in [6,7,8]:
        if lane == 8:
            laneBoundary.append(dataframe[dataframe['laneId']==lane].y.min())
            laneBoundary.append(dataframe[dataframe['laneId']==lane].y.max())
        else:
            laneBoundary.append(dataframe[dataframe['laneId']==lane].y.min())
    
    return laneBoundary



def ExtractData(data, L, laneBoundary):
    '''
        Extract vehicle's position 
        
        @ Input:
        --------------------------
            data: the dataframe
            L   : threshold
            lr  : standard lane width divided by left lane width
            mr  ：standard lane width divided by middle lane width
            rr  : standard lane width divided by right lane width  
            laneBoundary: the lateral position of lane boundaries
            
        @ Output:
        -------------------------
        x1      : the lateral postion of ego-vehicle related to left lane boundary   
        x2      : the lateral postion of other vehicles related to the ego-vehicle
        results : the relative lateral position: array([[x1,x2],...])
        
    '''  
    #------------------------------ transfer the lane width
    laneWidth = np.diff(laneBoundary)  
    lr, mr, rr = 3.5/laneWidth   # transfer ratio related to standard lane width (3.5 meter)

    
    #------------------------------ data in the mid-lane 
    data_midlane = data.iloc[data[data['laneId']==7].index]
    data_midlane.index = [str(i) for i in range(data_midlane.shape[0])]
    index = data_midlane.index

    Results = []
#     for idx in tqdm(index):
    for idx in index:
        frame, id, x, y, laneId, width = data_midlane.loc[idx]

        #------------------------------ Left and Right Lanes
        Left = data[(data['frame']==frame) & (data['id']!=id) & (data['laneId']==6) & (data['x']>= x-L) & (data['x']<= x+L)]
        Right = data[(data['frame']==frame) & (data['id']!=id) & (data['laneId']==8) & (data['x']>= x-L) & (data['x']<= x+L)]

        #------------------------------ The Relative Lateral Postion of ego-vehicle('x1')  
        y1 = (y - laneBoundary[1]) * mr
        
        #----------------------------- The Lateral Postion Related to the ego-vehicle ('x2')  
        temp = []
        if Left.shape[0] != 0:
            for i in range(Left.shape[0]):
#                 y2 = abs(y - Left.values[i,3]) * lr
                y2 = (y - laneBoundary[1]) * mr + (laneBoundary[1] - Left.values[i,3] - width) * lr
                temp.append([y1,y2])
        
        if Right.shape[0] != 0:
            for i in range(Right.shape[0]):
#                 y2 = abs(y - Right.values[i,3]) * rr
                y2 = (laneBoundary[2] - y - width) * mr + (Right.values[i,3] - laneBoundary[2]) * rr
                temp.append([y1,y2])
        
        Results.append(temp)    
        
        #----------------------------- Remove Empty Elements
        results = np.array([element[0] for element in Results if element != []])
        
    return results



def HeatMap_Visulization(x1,x2,bw):
    
    X = x1
    Y = x2
    values = np.vstack([X, Y])
    
    #--------------------------- Get the boundary
    xmin, xmax, ymin, ymax = [0, 3.5, 0,3.5]
        
    #--------------------------- Create a new kernal
    kernel = stats.gaussian_kde(values, bw_method=bw)
    
    #--------------------------- Meshgrid
    Xm, Ym = np.mgrid[xmin:xmax:200j, ymin:ymax:100j]
    positions = np.vstack([Xm.ravel(), Ym.ravel()])
    
    #--------------------------- Calculate 'pdf'
    Z = np.reshape(kernel(positions).T, Xm.shape)
    
    return Xm, Ym, Z



def Plot_HeatMap(Xm, Ym, Z, name):
    fig,ax = plt.subplots(figsize = (5,5))
    plt.axvline(x = 1.75, color='k', linewidth=1)
    plt.axhline(y = 1.75, color='k', linewidth=1)

    con = ax.contourf(Xm, Ym, Z, 20, cmap='binary')
    plt.xlabel('x1 (m)')
    plt.ylabel('x2 (m)')

    plt.xlim(0, 3.5)
    plt.ylim(0, 3.5)
    plt.savefig('D:/OneDrive/ZJU/Researche Group/15. Tasks/lateral_position_comparison/figs/' + name + '.jpg', dpi=300)

    

def ExtractId(data, L, laneBoundary):
    '''
        Extract vehicle's position 
        
        @ Input:
        --------------------------
            data: the dataframe
            L   : threshold
            lr  : standard lane width divided by left lane width
            mr  ：standard lane width divided by middle lane width
            rr  : standard lane width divided by right lane width  
            laneBoundary: the lateral position of lane boundaries
            
        @ Output:
        -------------------------
        x1      : the lateral postion of ego-vehicle related to left lane boundary   
        x2      : the lateral postion of other vehicles related to the ego-vehicle
        results : the relative lateral position: array([[x1,x2],...])
        
    '''  
    #------------------------------ transfer the lane width
    laneWidth = np.diff(laneBoundary)  
    lr, mr, rr = 3.5/laneWidth   # transfer ratio related to standard lane width (3.5 meter)

    
    #------------------------------ data in the mid-lane 
    data_midlane = data.iloc[data[data['laneId']==7].index]
    data_midlane.index = [str(i) for i in range(data_midlane.shape[0])]
    index = data_midlane.index

    results = []
    for idx in tqdm(index):
#     for idx in index:
        frame, id, x, y, laneId, width = data_midlane.loc[idx]

        #------------------------------ Left and Right Lanes
        Left = data[(data['frame']==frame) & (data['id']!=id) & (data['laneId']==6) & (data['x']>= x-L) & (data['x']<= x+L)]
        Right = data[(data['frame']==frame) & (data['id']!=id) & (data['laneId']==8) & (data['x']>= x-L) & (data['x']<= x+L)]     
        
        #----------------------------- Print vehicle's Id
        if Left.shape[0] != 0 and Right.shape[0] != 0:
#             print(Left.values[0,1], id, Right.values[0,1])
            vid = [Left.values[0,1], id, Right.values[0,1]]
        
            results.append(vid)    
        
    return results



class GradientLine:
    
    @classmethod
    def colorline(self,
        x, y, z=None, cmap=plt.get_cmap('copper'), norm=plt.Normalize(0.0, 1.0),
            linewidth=3, alpha=1.0):
        """
        http://nbviewer.ipython.org/github/dpsanders/matplotlib-examples/blob/master/colorline.ipynb
        http://matplotlib.org/examples/pylab_examples/multicolored_line.html
        Plot a colored line with coordinates x and y
        Optionally specify colors in the array z
        Optionally specify a colormap, a norm function and a line width
        """

        # Default colors equally spaced on [0,1]:
        if z is None:
            z = np.linspace(0.0, 1.0, len(x))

        # Special case if a single number:
        if not hasattr(z, "__iter__"):  # to check for numerical input -- this is a hack
            z = np.array([z])

        z = np.asarray(z)

        segments = self.make_segments(x, y)
        lc = mcoll.LineCollection(segments, array=z, cmap=cmap, norm=norm, linewidth=linewidth, alpha=alpha)

        ax = plt.gca()
        ax.add_collection(lc)

        return lc

    @classmethod
    def make_segments(self,x, y):
        """
        Create list of line segments from x and y coordinates, in the correct format
        for LineCollection: an array of the form numlines x (points per line) x 2 (x
        and y) array
        """

        points = np.array([x, y]).T.reshape(-1, 1, 2)
        segments = np.concatenate([points[:-1], points[1:]], axis=1)
        return segments

    @classmethod
    def plot_results_path(self,x, y, z, linewidth_car=4):

        #-------------normalize 'z'
        z = z / z.max()


        # 'jet', 'cool'
        lc = self.colorline(x, y, z, cmap=plt.get_cmap('gist_rainbow'), linewidth=linewidth_car)  # 'jet' #'cool'
        return lc
    
    @classmethod
    def plot_gd_bar(self,fig, ax, lc, max_pro, max_tran=0, cars_num=1, car_num=0, offset=0):
        cax = fig.add_axes([ax.get_position().x1 + 0.045,
                            ax.get_position().y0 + (car_num / cars_num) * ax.get_position().height + 0.02,
                            0.0225,
                            ax.get_position().height - (
                                        (cars_num - car_num - 1) / cars_num) * ax.get_position().height - offset - 0.05])
        cb = plt.colorbar(lc, cax=cax)

        # 调整渐变色图例显示数据范围
        def label_cbrt(x, pos):
            return "{:.1f}".format(max_pro * np.cbrt(x) + max_tran)

        cb.formatter = ticker.FuncFormatter(label_cbrt)
        cb.ax.tick_params(labelsize=11)
        cb.ax.set_xlabel('  time(s)', fontsize=12) #设置colorbar的标签字体及其大小

        cb.update_ticks()

        return cb


#################################################################
#################################################################
#################################################################
#################################################################
#################################################################
#################################################################
def rename_dataframe(dataset):
    '''
        Rename the dataset
    '''
    n_col = dataset.shape[1]
    
    if (n_col == 25) and ('Section_ID' in dataset.columns.tolist()):
        dataset.rename(columns={"v_length":"length", "v_length":"width", 'v_Vel':'Velocity', 'Local_X':'y',
                                'lane':'laneId', 'Lane_ID':'laneId', 'Vehicle_ID':'id', 'Frame_ID':'frame',
                                'Local_Y':'x'}, inplace=True)
        
        # calculate velocity and acceleration
        dataset = calculate_ngsim_speed_acceleration(dataset)
        
    elif n_col == 26:
        dataset.rename(columns={"width":"length", "height":"width"}, inplace=True)
    
    elif n_col == 16:
        dataset.rename(columns={"frameId":"frame", "trackId":"id", 'laneId':'laneId', 'xVelocity':'yVelocity',
                               'yVelocity':'xVelocity', 'localY':'x', 'localX':'y', 'yAcceleration':'xAcceleration',
                               'xAcceleration':'yAcceleration'}, inplace=True) 

    return dataset


def filter_lane_keep_data(full_data):
    '''
        Filter the lane-keep data 
        from the full data
    '''
    vids = full_data.id.unique()

    ## filter lane-keep
    vehicles = []
    for id in vids:
        veh = full_data[full_data['id']==id]
        if veh.laneId.unique().shape[0] == 1:
            vehicles.append(veh)

    ## concat these sub-dataframe
    vehicles = pd.concat(vehicles)
    
    return vehicles


def extract_laneBoundary(data):
    '''
        Extract the lane boundary from 
        the full dataset
    '''
    ## get lanes and its conrresponding lane boundary
    lanes = np.sort(data.laneId.unique())

    ## filter lane boundaries
    laneBoundary = {}
    for l in lanes:
        temp = data[data['laneId']==l]
        laneBoundary[l] = [temp.y.describe()['min'], temp.y.describe()['max']]

    ## shift lane boundaries
    for i in range(len(lanes)-1):
        # the local lane
        l0 = lanes[i]
        b0 = laneBoundary[l0]

        # the next lane
        l1 = lanes[i+1]
        b1 = laneBoundary[l1]

        # shift boundaries
        if b0[1]!=b1[0] and b1[0]-b0[1]<=2:
            # take the average value as the mid-boundary
            mid_b = round((b1[0]+b0[1]) / 2, 2)

            # uptate data
            laneBoundary[l0] = [b0[0], mid_b]
            laneBoundary[l1] = [mid_b, b1[1]]
            
    return laneBoundary


def plot_laneBoundary(laneBoundary):
    '''
        Plot the lane boundary
    '''
    for l, b in laneBoundary.items():
        plt.axhline(b[0], lw=2, c='k')
        plt.axhline(b[1], lw=2, c='k')



def calculate_lateral_distribution_im(lane_data, lane_boundary, num = 10):
    '''
        Calculate the lateral position 
        distribution in a road lane
    '''
    b = lane_boundary
    
    
    ## shift lateral position
    mid_b = np.mean(b)
    #y_new = (lane_data.y - mid_b) / (np.diff(b) / 1)
    #y_new = lane_data.y
    #lane_data['y'] = copy.deepcopy(y_new)
    #print(lane_data.loc['y'])
    #lane_data.loc[:,'y'] = y_new.values
    #
    effective_ys = lane_data[(lane_data['y']>=min(b)) & (lane_data['y']<max(b))]['y'].values
    y_new = (lane_data.y - mid_b) / (abs(np.diff(b)))
    #print(effective_ys)
    return np.std(y_new),np.mean(y_new),scipy.stats.skew(y_new)
    #return np.std(y_new),(np.mean(effective_ys)-mid_b)/(max(b)-min(b)),scipy.stats.skew(y_new)
    """
    ## filter data
    p = []
    #Y = np.linspace(-0.5, 0.5, num)
    Y = np.linspace(min(b), max(b), num)
    for k in range(1, Y.shape[0]):
        #n = lane_data[(lane_data['y']>=Y[k-1]) & (lane_data['y']<Y[k])].shape[0]
        n = lane_data[(lane_data['y']>=Y[k-1]) & (lane_data['y']<Y[k])].shape[0]
        p.append(n)

    ## calculate density
    p = np.array(p) / sum(p) / np.diff(Y)[0]
    
    return Y[1:], p 
    """
   
    
    

def calculate_lateral_distribution(lane_data, lane_boundary, num):
    '''
        Calculate the lateral position 
        distribution in a road lane
    '''
    b = lane_boundary
    
    
    ## shift lateral position
    mid_b = np.mean(b)
    y_new = (lane_data.y - mid_b) / (np.diff(b) / 1)
    #lane_data['y'] = copy.deepcopy(y_new)
    #print(lane_data.loc['y'])
    lane_data.loc[:,'y'] = y_new.values
    
    ## filter data
    p = []
    Y = np.linspace(-0.5, 0.5, num)
    for k in range(1, Y.shape[0]):
        n = lane_data[(lane_data['y']>=Y[k-1]) & (lane_data['y']<Y[k])].shape[0]
        p.append(n)

    ## calculate density
    p = np.array(p) / sum(p) / np.diff(Y)[0]
    
    return Y[1:], p    
    
    
    
    
    
    
    
    
    
    



